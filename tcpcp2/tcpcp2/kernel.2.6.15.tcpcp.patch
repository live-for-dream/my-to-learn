Copyright (C) 2005-2006 NTT Corporation

diff -urbpBPN osdl/include/linux/syscalls.h osdl.tcpcp/include/linux/syscalls.h
--- osdl/include/linux/syscalls.h	2006-01-20 02:32:26.000000000 +0000
+++ osdl.tcpcp/include/linux/syscalls.h	2006-02-09 04:48:32.000000000 +0000
@@ -3,6 +3,7 @@
  *
  * Copyright (c) 2004 Randy Dunlap
  * Copyright (c) 2004 Open Source Development Labs
+ * Copyright (C) 2005 NTT Corporation
  *
  * This file is released under the GPLv2.
  * See the file COPYING for more details.
@@ -512,4 +513,25 @@ asmlinkage long sys_ioprio_get(int which
 asmlinkage long sys_set_mempolicy(int mode, unsigned long __user *nmask,
 					unsigned long maxnode);
 
+#if defined(CONFIG_TCPCP) || defined(CONFIG_TCPCP_MODULE)
+/* for TCPCP. */
+asmlinkage long tcpcp_sys_socket(int, int, int);
+
+#define plugin_dummy() __asm__ __volatile__("nop\n\t" \
+	"nop\n\t" \
+	"nop\n\t" \
+	"nop\n\t" \
+	"nop\n\t" \
+	"nop\n\t" \
+	"nop\n\t" \
+	"nop\n\t" \
+	"nop\n\t" \
+	"nop\n\t" \
+	"nop\n\t" \
+	"nop\n\t" \
+	"nop\n\t" \
+	"nop\n\t")
+
+#endif
+
 #endif
diff -urbpBPN osdl/include/linux/tcp.h osdl.tcpcp/include/linux/tcp.h
--- osdl/include/linux/tcp.h	2006-01-20 02:32:30.000000000 +0000
+++ osdl.tcpcp/include/linux/tcp.h	2006-02-09 04:48:32.000000000 +0000
@@ -362,6 +362,11 @@ struct tcp_sock {
 		__u32	seq;
 		__u32	time;
 	} rcvq_space;
+
+#if defined(CONFIG_TCPCP) || defined(CONFIG_TCPCP_MODULE)
+	__u32		ts_offset;	/* offset from tcp_time_stamp */
+	__u32		set_flag; /* flag state maintenance after switch of faction */
+#endif
 };
 
 static inline struct tcp_sock *tcp_sk(const struct sock *sk)
@@ -376,6 +381,9 @@ struct tcp_timewait_sock {
 	__u32			  tw_rcv_wnd;
 	__u32			  tw_ts_recent;
 	long			  tw_ts_recent_stamp;
+#if defined(CONFIG_TCPCP) || defined(CONFIG_TCPCP_MODULE)
+	__u32			  ts_offset; /* offset from tcp_time_stamp */
+#endif
 };
 
 static inline struct tcp_timewait_sock *tcp_twsk(const struct sock *sk)
diff -urbpBPN osdl/include/linux/tcpcp.h osdl.tcpcp/include/linux/tcpcp.h
--- osdl/include/linux/tcpcp.h	1970-01-01 00:00:00.000000000 +0000
+++ osdl.tcpcp/include/linux/tcpcp.h	2006-02-09 04:48:32.000000000 +0000
@@ -0,0 +1,439 @@
+/*
+ * linux/tcpcp.h - TCP connection passing, data structures and prototypes
+ *
+ * Written 2002 by Werner Almesberger
+ *
+ * Copyright (C) 2005 NTT Corporation
+ */
+
+#ifndef _LINUX_TCPCP_H
+#define _LINUX_TCPCP_H
+
+#ifdef __KERNEL__
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/in6.h>
+#include <linux/tcp.h>
+#endif /* __KERNEL__ */
+
+#ifdef CONFIG_TCPCP_DEBUG
+#define DPRINTK(...) printk(KERN_DEBUG __VA_ARGS__)
+#else
+#define DPRINTK(...)
+#endif
+
+
+#define TCPCP_MODULE_NAME	"tcpcp"
+
+#define	TCPCP_FLAG_MAKE_SI	0x01
+#define	TCPCP_FLAG_STOP		0x02
+#define	TCPCP_FLAG_CLOSE	0x04
+#define	TCPCP_FLAG_SET_SI	0x08
+#define	TCPCP_FLAG_START	0x10
+#define	TCPCP_FLAG_ALL		0x80
+
+#define plugin_dummy() __asm__ __volatile__("nop\n\t" \
+	"nop\n\t" \
+	"nop\n\t" \
+	"nop\n\t" \
+	"nop\n\t" \
+	"nop\n\t" \
+	"nop\n\t" \
+	"nop\n\t" \
+	"nop\n\t" \
+	"nop\n\t" \
+	"nop\n\t" \
+	"nop\n\t" \
+	"nop\n\t" \
+	"nop\n\t")
+
+
+/* ----- TCP Socket Informations (TCP-SIs) --------------------------------- */
+
+/**
+ * TCP Socket Information (TCP-SI) option: packet information
+ **/
+struct tcpcp_si_skb {
+	uint8_t type;		/* TCP-SI option type */
+				/*  1: TCPCP_SIE_BUF_SND */
+				/*  2: TCPCP_SIE_BUF_RCV */
+	uint8_t __pad1;
+	uint16_t length;	/* segment data length */
+	uint8_t flags;		/* TCP header flags */
+	uint8_t sacked;		/* state flags for SACK/FACK */
+	uint8_t __pad2[2];
+	uint16_t tso_segs;
+	uint16_t tso_size;
+	uint32_t seq;		/* sequence number of first byte */
+	uint8_t data[0];        /* data, padded to multiple of 4 bytes */
+};
+
+enum {
+	TCPCP_SIE_BUF_SND = 1,	/* send buffer (only TCP segment, no IP) */
+	TCPCP_SIE_BUF_RCV = 2,	/* receive buffer (only TCP segment, no IP) */
+};
+
+/**
+ * TCP-SI element: globally unique TCP connection ID
+ **/
+struct tcpcp_sie_id4 {
+	uint32_t ip_src;	/* source IPv4 address */
+	uint32_t ip_dst;	/* destination IPv4 address */
+};
+
+struct tcpcp_sie_id6 {
+	struct in6_addr ip_src;	/* source IPv6 address */
+	struct in6_addr ip_dst;	/* destination IPv6 address */
+	uint32_t scope_id;	/* scope id */
+};
+
+struct tcpcp_sie_id {
+	uint8_t ip_version;	/* IP version */
+				/*  4: IPv4 */
+				/*  6: IPv6 */
+	uint8_t __pad[3];
+	union {
+		struct tcpcp_sie_id4 v4;	/* IPv4 */
+		struct tcpcp_sie_id6 v6;	/* IPv6 */
+	} ip;
+	uint16_t tcp_sport;	/* TCP source port */
+	uint16_t tcp_dport; 	/* TCP destinatipon port */
+};
+
+/**
+ * TCP-SI element: fixed general data
+ **/
+struct tcpcp_sie_fixgen {
+	uint8_t tcp_flags;	/* TCP flags; from linux/tcp.h */
+				/*  1: TCPI_OPT_TIMESTAMPS */
+				/*  2: TCPI_OPT_SACK */
+				/*  4: TCPI_OPT_WSCALE */
+				/*  8: TCPI_OPT_ECN */
+	uint8_t snd_wscale;	/* send window scale (0 if unused) */
+	uint8_t rcv_wscale;	/* receive window scale (0 if unused) */
+	uint8_t __pad;
+	uint16_t snd_mss;	/* MSS sent */
+	uint16_t rcv_mss;	/* MSS received */
+};
+
+/**
+ * TCP-SI element: variable general data
+ **/
+struct tcpcp_sie_vargen {
+	uint8_t state;		/* connection state; from linux/tcp.h */
+				/*  1: TCP_ESTABLISHED */
+				/*  2: TCP_SYN_SENT */
+				/*  3: TCP_SYN_RECV */
+				/*  4: TCP_FIN_WAIT1 */
+				/*  5: TCP_FIN_WAIT2 */
+				/*  6: TCP_TIME_WAIT */
+				/*  7: TCP_CLOSE */
+				/*  8: TCP_CLOSE_WAIT */
+				/*  9: TCP_LAST_ACK */
+				/* 10: TCP_LISTEN */
+				/* 11: TCP_CLOSING */
+				/* Note: TCP-SI may not ever use some of */
+				/*       these values. */
+	uint8_t __pad[3];
+	uint32_t snd_nxt;	/* sequence number of next new byte to send */
+	uint32_t rcv_nxt;	/* sequence number of next new byte expected */
+				/* to receive */
+	uint32_t snd_wnd;	/* window received from peer */
+	uint32_t rcv_wnd;	/* window advertized to peer */
+	uint32_t ts_recent;	/* cached timestamp from peer (0 if none) */
+	uint32_t ts_gen;	/* current locally generated timestamp */
+				/* (0 if not using timestamps) */
+};
+
+/**
+ * TCP-SI element: socket options (socket)
+ **/
+struct tcpcp_sie_sk_sockopt {
+	uint8_t flags;		/* flags */
+				/*  1: TCPCP_SIE_SOCK_REUSEADDR */
+				/*  2: TCPCP_SIE_SOCK_KEEPOPEN */
+				/*  4: TCPCP_SIE_SOCK_LINGER */
+	uint8_t userlocks;	/* %SO_SNDBUF and %SO_RCVBUF settings */
+	uint8_t __pad[2];
+	uint32_t priority;	/* %SO_PRIORITY setting */
+	uint32_t sndbuf;	/* size of send buffer in bytes */
+	uint32_t rcvbuf;	/* size of receive buffer in bytes */
+	uint32_t l_linger;	/* How long to linger for */
+};
+
+enum {
+	TCPCP_SIE_SOCK_REUSEADDR	= 1,
+	TCPCP_SIE_SOCK_KEEPOPEN		= 2,
+	TCPCP_SIE_SOCK_LINGER		= 4,
+};
+
+/**
+ * TCP-SI element: socket options (IPv4)
+ **/
+struct tcpcp_sie_ipv4_sockopt {
+	uint8_t flags;		/* flags */
+				/*  1: TCPCP_SIE_IP_DEFAULT_TTL */
+	uint8_t uc_ttl;		/* unicast TTL */
+	uint8_t pmtudisc;	/* IP_MTU_DISCOVER state */
+	uint8_t tos;		/* TOS */
+	uint8_t opt_len;
+	uint8_t __pad[3];
+	uint8_t opt_data[40];
+};
+
+enum {
+	TCPCP_SIE_IP_DEFAULT_TTL = 1,
+};
+
+/**
+ * TCP-SI element: socket options (IPv6)
+ **/
+struct tcpcp_sie_ipv6_sockopt {
+	uint8_t flags;		/* flags */
+				/*  1: TCPCP_SIE_IPV6_DEFAULT_HOPLIMIT */
+	uint8_t hop_limit;	/* unicast hop limit */
+	uint8_t pmtudisc;	/* IPV6_MTU_DISCOVER state */
+	uint8_t __pad;
+};
+
+enum {
+	TCPCP_SIE_IPV6_DEFAULT_HOPLIMIT = 1,
+};
+
+/**
+ * TCP-SI element: socket options (TCP)
+ **/
+struct tcpcp_sie_tcp_sockopt {
+	uint8_t nonagle;	/* Disable Nagle aliorithm ? */
+	uint8_t keepcnt;	/* num of allowed keep alive probes */
+	uint8_t __pad[2];
+	uint16_t keepidle;	/* time before keep alive takes place */
+	uint16_t keepintvl;	/* time interval between keep alive */
+				/* probes */
+};
+
+/**
+ * TCP-SI element: socket options
+ **/
+struct tcpcp_sie_sockopt {
+	struct tcpcp_sie_sk_sockopt sk;			/* socket */
+	union {
+		struct tcpcp_sie_ipv4_sockopt v4;	/* IPv4 */
+		struct tcpcp_sie_ipv6_sockopt v6;	/* IPv6 */
+	} ip;
+	struct tcpcp_sie_tcp_sockopt tcp;		/* TCP */
+};
+
+/**
+ * TCP Socket Information (TCP-SI) header
+ **/
+struct tcpcp_si_hdr {
+	uint32_t si_length;		/* total length of TCP-SI / 4byte */
+	uint32_t fd;
+	struct tcpcp_sie_id id;		/* globally unique TCP connection ID */
+	struct tcpcp_sie_fixgen fixgen;	/* fixed general data */
+	struct tcpcp_sie_vargen vargen;	/* variable general data */
+	struct tcpcp_sie_sockopt sockopt;	/* socket option */
+	struct tcpcp_si_skb si_skb[0];
+};
+
+/**
+ * TCP Socket Informations (TCP-SIs) total header
+ **/
+struct tcpcp_total_si_hdr {
+	uint32_t total_si_length;	/* total length of TCP-SIs / 4byte */
+	uint8_t major;			/* incompatible structure revision */
+					/*  0: current version */
+	uint8_t minor;			/* compatible structure extension */
+					/*  0: current version */
+	uint16_t si_cnt;
+	struct tcpcp_si_hdr si_hdr[0];
+};
+
+
+/* ----- FD Result (FDR) Information (only "ALL") -------------------------- */
+
+struct fdr {
+	int fd;
+	int result;
+};
+
+struct result {
+	unsigned int fd_all;    /* total of fd that succeeds in processing */
+	unsigned int fd_ng;     /* Number of fd that fails in processing */
+	unsigned int buf_size;
+	unsigned int fdrs_size;
+};
+
+
+/* ---- Process, Request, TCP-SIs and FDR Info. Entry ---------------------- */
+
+#ifdef __KERNEL__
+
+/**
+ * TCP-SI buffer (It's used at setting TCP-SI)
+ **/
+struct tcpcp_si_skb_buf {
+	unsigned int max_buf_len;
+	unsigned int buf_len;
+	unsigned int skb_cnt;
+	char *si_skb;
+};
+
+struct tcpcp_si_buf {
+	struct tcpcp_si_hdr si_hdr;	/* TCP-SI header */
+	struct tcpcp_si_skb_buf snd_buf;
+	struct tcpcp_si_skb_buf rcv_buf;
+};
+
+#define TCPCP_PAGE_NUM_SET_SI	24
+#define TCPCP_SI_SKB_BUF_SIZE		PAGE_SIZE * TCPCP_PAGE_NUM_SET_SI
+
+/**
+ * common entry (It's used at making TCP-SIs or FDR Info.)
+ **/
+struct tcpcp_com_entry {
+	struct tcpcp_com_entry *next;	/* next entry */
+	unsigned int max_data_len;
+	unsigned int data_len;		/* length of data */
+	char data[0];
+};
+
+#define TCPCP_PAGE_NUM_MAKE_SI_ONE  3
+#define TCPCP_COM_ENTRY_SIZE_FOR_ONE	PAGE_SIZE * TCPCP_PAGE_NUM_MAKE_SI_ONE
+#define TCPCP_COM_ENTRY_SIZE_FOR_ALL	(PAGE_SIZE << 5) /* MAX_GFP_ORDER */
+
+/**
+ * Request Entry
+ **/
+struct tcpcp_req_entry {
+	struct list_head node;
+	struct list_head timer_node;
+	uint32_t fd;
+	struct sock *sk;
+	pid_t pid;
+	unsigned char flag;
+	char dummy[3];
+	unsigned int timeout;
+	struct result res;
+	struct tcpcp_com_entry *s_entry;	/* TCP-SIs Entry */
+	struct tcpcp_com_entry *f_entry;	/* FDR Entry (only "ALL") */
+	struct tcpcp_proc_entry *p_entry;	/* parent Process Entry */
+};
+
+#define TCPCP_WATCH_INTERVAL    	HZ
+#define TCPCP_RETRY_WATCH_INTERVAL	TCPCP_WATCH_INTERVAL / 10
+#define TCPCP_REQ_ENTRY_TIMEOUT		HZ * 10
+
+/**
+ * Process Entry
+ **/
+struct tcpcp_proc_entry {
+	struct list_head node;
+	gid_t tgid;
+	unsigned char flag;
+	char dummy[3];
+	struct list_head r_list_head;	/* Request List */
+};
+
+/**
+ * Process List or Timeout List
+ **/
+struct tcpcp_list {
+	struct list_head head;
+	rwlock_t lock;
+};
+#endif /* __KERNEL__ */
+
+
+/* ---- -------------------------------------------------------------------- */
+
+enum option {
+	TCPCP_MAKE_SI		= 16,
+	TCPCP_MAKE_SI_ALL,
+	TCPCP_GET_SI,
+	TCPCP_STOP,
+	TCPCP_STOP_ALL,
+	TCPCP_CLOSE,
+	TCPCP_CLOSE_ALL,
+	TCPCP_SET_SI,
+	TCPCP_SET_SI_ALL,
+	TCPCP_START,
+	TCPCP_START_ALL,
+	TCPCP_GET_RES_SIZE,
+	TCPCP_GET_RES,
+};
+
+#define TCPCP_SET_FLAG_OFF	0
+#define TCPCP_SET_FLAG_ON       1
+
+
+/*
+ * Buffers are in sequence, first all send, then all out-of-order buffers.
+ * Buffers must not overlap, and may not contain any extraneous data (e.g.
+ * ack'ed bytes, or such). snd_nxt does not have to be at a buffer boundary.
+ */
+
+
+#ifdef __KERNEL__
+
+#if defined(CONFIG_TCPCP) || defined(CONFIG_TCPCP_MODULE)
+
+#include <net/sock.h>
+
+/**
+ * Hooks
+ **/
+extern int (*tcpcp_com_ope_hook)(struct sock *sk, int optname,
+				 struct result *user_res);
+extern int (*tcpcp_get_si_hook)(struct sock *sk,
+				struct tcpcp_total_si_hdr *user_si,
+				unsigned int *user_size);
+extern int (*tcpcp_get_res_hook)(struct sock *sk, struct fdr *user_fdrs,
+				 unsigned int *user_size);
+extern int (*tcpcp_set_si_hook)(struct sock *sk, int optname,
+				const struct tcpcp_total_si_hdr *user_si,
+				unsigned int size);
+extern void (*tcpcp_close_hook)(struct sock *sk);
+
+/**
+ *
+ **/
+extern struct tcp_func tcpcp_ipv4_af_specific;
+#if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)
+extern struct tcp_func tcpcp_ipv6_af_specific;
+extern struct tcp_func tcpcp_ipv6_af_mapped;
+#endif
+extern struct sk_filter drop_all;
+
+int tcpcp_discard_xmit(struct sk_buff *skb, int ipfragok);
+void tcpcp_fix_seq(struct sock *sk, __u32 seq, __u32 ackseq);
+void tcpcp_fix_ts(struct sock *sk, __u32 ack_tsecr);
+
+/**
+ * Hook call functions 
+ **/
+int tcpcp_call_com_ope_hook(struct sock *sk, int optname,
+			    struct result *user_res);
+int tcpcp_call_set_si_hook(struct sock *sk, int optname,
+			   const struct tcpcp_total_si_hdr *user_si,
+			   unsigned int size);
+int tcpcp_call_get_si_hook(struct sock *sk, struct tcpcp_total_si_hdr *user_si,
+			   unsigned int *user_size);
+int tcpcp_call_get_res_hook(struct sock *sk, struct fdr *user_fdrs,
+			    unsigned int *user_size);
+void tcpcp_call_close_hook(struct sock *sk);
+
+#else /* defined(CONFIG_TCPCP) || defined(CONFIG_TCPCP_MODULE) */
+
+#define tcpcp_call_com_ope_hook(sk, optname, val) (-ENOPROTOOPT)
+#define tcpcp_call_set_si_hook(sk, optname, val, size) (-ENOPROTOOPT)
+#define tcpcp_call_get_si_hook(sk, val, size) (-ENOPROTOOPT)
+#define tcpcp_call_get_res_hook(sk, val, size) (-ENOPROTOOPT)
+#define tcpcp_call_close_hook(sk) (-ENOPROTOOPT)
+
+#endif /* !defined(CONFIG_TCPCP) && !defined(CONFIG_TCPCP_MODULE) */
+
+#endif /* __KERNEL__ */
+
+#endif /* _LINUX_TCPCP_H */
diff -urbpBPN osdl/include/net/ip.h osdl.tcpcp/include/net/ip.h
--- osdl/include/net/ip.h	2006-01-20 02:32:36.000000000 +0000
+++ osdl.tcpcp/include/net/ip.h	2006-02-09 04:48:32.000000000 +0000
@@ -343,6 +343,26 @@ extern void ip_options_undo(struct ip_op
 extern void ip_forward_options(struct sk_buff *skb);
 extern int ip_options_rcv_srr(struct sk_buff *skb);
 
+#if defined(CONFIG_TCPCP) || defined(CONFIG_TCPCP_MODULE)
+/* for TCPCP. */
+extern int tcpcp_ip_options_get(struct ip_options **optp, unsigned char *data, int optlen);
+
+#define plugin_dummy() __asm__ __volatile__("nop\n\t" \
+	"nop\n\t" \
+	"nop\n\t" \
+	"nop\n\t" \
+	"nop\n\t" \
+	"nop\n\t" \
+	"nop\n\t" \
+	"nop\n\t" \
+	"nop\n\t" \
+	"nop\n\t" \
+	"nop\n\t" \
+	"nop\n\t" \
+	"nop\n\t" \
+	"nop\n\t")
+#endif
+
 /*
  *	Functions provided by ip_sockglue.c
  */
diff -urbpBPN osdl/include/net/ipv6.h osdl.tcpcp/include/net/ipv6.h
--- osdl/include/net/ipv6.h	2006-01-20 02:32:36.000000000 +0000
+++ osdl.tcpcp/include/net/ipv6.h	2006-02-09 04:48:32.000000000 +0000
@@ -454,6 +454,28 @@ extern int			ip6_dst_lookup(struct sock 
 					       struct dst_entry **dst,
 					       struct flowi *fl);
 
+#if defined(CONFIG_TCPCP) || defined(CONFIG_TCPCP_MODULE)
+/* for TCPCP. */
+extern int			tcpcp_ip6_dst_lookup(struct sock *sk,
+			      		struct dst_entry **dst,
+			  		struct flowi *fl);
+
+#define plugin_dummy() __asm__ __volatile__("nop\n\t" \
+	"nop\n\t" \
+	"nop\n\t" \
+	"nop\n\t" \
+	"nop\n\t" \
+	"nop\n\t" \
+	"nop\n\t" \
+	"nop\n\t" \
+	"nop\n\t" \
+	"nop\n\t" \
+	"nop\n\t" \
+	"nop\n\t" \
+	"nop\n\t" \
+	"nop\n\t")
+#endif
+
 /*
  *	skb processing functions
  */
@@ -566,5 +588,11 @@ extern void ipv6_sysctl_register(void);
 extern void ipv6_sysctl_unregister(void);
 #endif
 
+/*
+ * for TCP connection passing
+ */
+extern struct tcp_func ipv6_mapped;
+extern struct tcp_func ipv6_specific;
+
 #endif /* __KERNEL__ */
 #endif /* _NET_IPV6_H */
diff -urbpBPN osdl/include/net/route.h osdl.tcpcp/include/net/route.h
--- osdl/include/net/route.h	2006-01-20 02:32:36.000000000 +0000
+++ osdl.tcpcp/include/net/route.h	2006-02-09 04:48:32.000000000 +0000
@@ -129,6 +129,29 @@ extern int		ip_rt_dump(struct sk_buff *s
 struct in_ifaddr;
 extern void fib_add_ifaddr(struct in_ifaddr *);
 
+#if defined(CONFIG_TCPCP) || defined(CONFIG_TCPCP_MODULE)
+/* for TCPCP. */
+extern int tcpcp_ip_route_output_key(struct rtable **, const struct flowi *flp);
+extern int tcpcp_ip_route_output_flow(struct rtable **rp, struct flowi *flp, struct sock *sk, int flags);
+extern void tcpcp_rt_bind_peer(struct rtable *rt, int create);
+
+#define plugin_dummy() __asm__ __volatile__("nop\n\t" \
+	"nop\n\t" \
+	"nop\n\t" \
+	"nop\n\t" \
+	"nop\n\t" \
+	"nop\n\t" \
+	"nop\n\t" \
+	"nop\n\t" \
+	"nop\n\t" \
+	"nop\n\t" \
+	"nop\n\t" \
+	"nop\n\t" \
+	"nop\n\t" \
+	"nop\n\t")
+
+#endif
+
 static inline void ip_rt_put(struct rtable * rt)
 {
 	if (rt)
diff -urbpBPN osdl/include/net/tcp.h osdl.tcpcp/include/net/tcp.h
--- osdl/include/net/tcp.h	2006-01-20 02:32:36.000000000 +0000
+++ osdl.tcpcp/include/net/tcp.h	2006-02-09 04:48:32.000000000 +0000
@@ -447,6 +447,18 @@ extern struct sock *cookie_v4_check(stru
 extern __u32 cookie_v4_init_sequence(struct sock *sk, struct sk_buff *skb, 
 				     __u16 *mss);
 
+/* tcp_ipv4.c */
+
+extern struct tcp_func ipv4_specific;
+
+#if defined(CONFIG_TCPCP) || defined(CONFIG_TCPCP_MODULE)
+#if defined(CONFIG_IPV6) || defined (CONFIG_IPV6_MODULE)
+/* tcp_ipv6.c */
+extern struct tcp_func ipv6_mapped;
+extern struct tcp_func ipv6_specific;
+#endif
+#endif
+
 /* tcp_output.c */
 
 extern void __tcp_push_pending_frames(struct sock *sk, struct tcp_sock *tp,
@@ -490,6 +502,43 @@ typedef int (*sk_read_actor_t)(read_desc
 extern int tcp_read_sock(struct sock *sk, read_descriptor_t *desc,
 			 sk_read_actor_t recv_actor);
 
+#if defined(CONFIG_TCPCP) || defined(CONFIG_TCPCP_MODULE)
+/* for TCPCP. */
+extern void tcpcp_send_probe0(struct sock *);
+extern int tcpcp_retransmit_skb(struct sock *, struct sk_buff *);
+extern void tcpcp_select_initial_window(int __space, __u32 mss,
+				      __u32 *rcv_wnd, __u32 *window_clamp,
+				      int wscale_ok, __u8 *rcv_wscale);
+
+extern void tcpcp_set_keepalive(struct sock *sk, int val);
+
+extern void tcpcp_init_buffer_space(struct sock *sk);
+extern void tcpcp_clear_retrans(struct tcp_sock *tp);
+extern void tcpcp_ca_init(struct tcp_sock *tp);
+extern int tcpcp_v4_hash_connect(struct sock *sk);
+
+#if defined(CONFIG_IPV6) || defined (CONFIG_IPV6_MODULE)
+extern int tcpcp_v6_hash_connect(struct sock *sk);
+
+#endif
+
+#define plugin_dummy() __asm__ __volatile__("nop\n\t" \
+	"nop\n\t" \
+	"nop\n\t" \
+	"nop\n\t" \
+	"nop\n\t" \
+	"nop\n\t" \
+	"nop\n\t" \
+	"nop\n\t" \
+	"nop\n\t" \
+	"nop\n\t" \
+	"nop\n\t" \
+	"nop\n\t" \
+	"nop\n\t" \
+	"nop\n\t")
+
+#endif
+
 /* Initialize RCV_MSS value.
  * RCV_MSS is an our guess about MSS used by the peer.
  * We haven't any direct information about the MSS.
@@ -558,6 +607,12 @@ extern u32	__tcp_select_window(struct so
  */
 #define tcp_time_stamp		((__u32)(jiffies))
 
+#if defined(CONFIG_TCPCP) || defined(CONFIG_TCPCP_MODULE)
+#define tp_time_stamp(tp)	(tcp_time_stamp+(tp)->ts_offset)
+#else
+#define tp_time_stamp(tp)	tcp_time_stamp
+#endif
+
 /* This is what the send packet queuing engine uses to pass
  * TCP per-packet control information to the transmission
  * code.  We also store the host-order sequence numbers in
diff -urbpBPN osdl/net/ipv4/Kconfig osdl.tcpcp/net/ipv4/Kconfig
--- osdl/net/ipv4/Kconfig	2006-01-20 02:32:04.000000000 +0000
+++ osdl.tcpcp/net/ipv4/Kconfig	2006-02-09 04:48:33.000000000 +0000
@@ -331,6 +331,21 @@ config ARPD
 	  and you should also say Y to "Kernel/User network link driver",
 	  below. If unsure, say N.
 
+config TCPCP
+	tristate "IP: TCP connection passing (EXPERIMENTAL)"
+	depends on INET && EXPERIMENTAL
+	depends on IPV6 || IPV6=n
+	---help---
+	  Support for retrieving socket information of TCP connections, and
+	  re-creating connections from this information. Highly experimental,
+	  so if in doubt, just say "No".
+
+config TCPCP_DEBUG
+	bool "debug"
+	depends on TCPCP
+	---help---
+	  underconstruction.
+
 config SYN_COOKIES
 	bool "IP: TCP syncookie support (disabled per default)"
 	---help---
diff -urbpBPN osdl/net/ipv4/Makefile osdl.tcpcp/net/ipv4/Makefile
--- osdl/net/ipv4/Makefile	2006-01-20 02:32:04.000000000 +0000
+++ osdl.tcpcp/net/ipv4/Makefile	2006-02-09 04:48:33.000000000 +0000
@@ -9,7 +9,8 @@ obj-y     := route.o inetpeer.o protocol
 	     tcp.o tcp_input.o tcp_output.o tcp_timer.o tcp_ipv4.o \
 	     tcp_minisocks.o tcp_cong.o \
 	     datagram.o raw.o udp.o arp.o icmp.o devinet.o af_inet.o igmp.o \
-	     sysctl_net_ipv4.o fib_frontend.o fib_semantics.o netfilter.o
+	     sysctl_net_ipv4.o fib_frontend.o fib_semantics.o netfilter.o \
+	     tcpcp_hooks.o
 
 obj-$(CONFIG_IP_FIB_HASH) += fib_hash.o
 obj-$(CONFIG_IP_FIB_TRIE) += fib_trie.o
@@ -40,6 +41,7 @@ obj-$(CONFIG_TCP_CONG_HYBLA) += tcp_hybl
 obj-$(CONFIG_TCP_CONG_HTCP) += tcp_htcp.o
 obj-$(CONFIG_TCP_CONG_VEGAS) += tcp_vegas.o
 obj-$(CONFIG_TCP_CONG_SCALABLE) += tcp_scalable.o
+obj-$(CONFIG_TCPCP) += tcpcp.o
 
 obj-$(CONFIG_XFRM) += xfrm4_policy.o xfrm4_state.o xfrm4_input.o \
 		      xfrm4_output.o
diff -urbpBPN osdl/net/ipv4/ip_options.c osdl.tcpcp/net/ipv4/ip_options.c
--- osdl/net/ipv4/ip_options.c	2006-01-20 02:32:05.000000000 +0000
+++ osdl.tcpcp/net/ipv4/ip_options.c	2006-02-09 04:48:33.000000000 +0000
@@ -23,6 +23,10 @@
 #include <net/ip.h>
 #include <net/icmp.h>
 
+#if defined(CONFIG_TCPCP) || defined(CONFIG_TCPCP_MODULE)
+#include <linux/tcpcp.h>
+#endif
+
 /* 
  * Write options to IP header, record destination address to
  * source route option, address of outgoing interface
@@ -638,3 +642,20 @@ int ip_options_rcv_srr(struct sk_buff *s
 	}
 	return 0;
 }
+
+#if defined(CONFIG_TCPCP) || defined(CONFIG_TCPCP_MODULE)
+int tcpcp_ip_options_get(struct ip_options **optp, unsigned char *data,
+			 int optlen)
+{
+	/* plug-in. */
+	plugin_dummy();
+
+	/* start. */
+	DPRINTK("TCPCP : %s : start.\n", __FUNCTION__);
+
+	return ip_options_get(optp, data, optlen);
+}
+
+EXPORT_SYMBOL(tcpcp_ip_options_get);
+EXPORT_SYMBOL(ip_options_undo);
+#endif
diff -urbpBPN osdl/net/ipv4/route.c osdl.tcpcp/net/ipv4/route.c
--- osdl/net/ipv4/route.c	2006-01-20 02:32:05.000000000 +0000
+++ osdl.tcpcp/net/ipv4/route.c	2006-02-09 04:48:33.000000000 +0000
@@ -110,6 +110,10 @@
 #define RT_FL_TOS(oldflp) \
     ((u32)(oldflp->fl4_tos & (IPTOS_RT_MASK | RTO_ONLINK)))
 
+#if defined(CONFIG_TCPCP) || defined(CONFIG_TCPCP_MODULE)
+#include <linux/tcpcp.h>
+#endif
+
 #define IP_MAX_MTU	0xFFF0
 
 #define RT_GC_TIMEOUT (300*HZ)
@@ -2563,6 +2567,7 @@ int __ip_route_output_key(struct rtable 
 	unsigned hash;
 	struct rtable *rth;
 
+int error;
 	hash = rt_hash_code(flp->fl4_dst, flp->fl4_src ^ (flp->oif << 5), flp->fl4_tos);
 
 	rcu_read_lock_bh();
@@ -2600,7 +2605,8 @@ int __ip_route_output_key(struct rtable 
 	}
 	rcu_read_unlock_bh();
 
-	return ip_route_output_slow(rp, flp);
+	error = ip_route_output_slow(rp, flp);
+	return error;
 }
 
 EXPORT_SYMBOL_GPL(__ip_route_output_key);
@@ -3210,3 +3216,47 @@ int __init ip_rt_init(void)
 EXPORT_SYMBOL(__ip_select_ident);
 EXPORT_SYMBOL(ip_route_input);
 EXPORT_SYMBOL(ip_route_output_key);
+
+#if defined(CONFIG_TCPCP) || defined(CONFIG_TCPCP_MODULE)
+void tcpcp_rt_bind_peer(struct rtable *rt, int create)
+{
+	/* plug-in. */
+	plugin_dummy();
+
+	/* start */
+	printk(KERN_DEBUG "TCPCP : %s : start.\n", __FUNCTION__);
+
+	rt_bind_peer(rt, create);
+
+	/* end. */
+	printk(KERN_DEBUG "TCPCP : %s : end.\n", __FUNCTION__);
+	return;
+}
+
+int tcpcp_ip_route_output_flow(struct rtable **rp, struct flowi *flp,
+			       struct sock *sk, int flags)
+{
+	/* plug-in. */
+	plugin_dummy();
+
+	/* start. */
+	DPRINTK("TCPCP : %s : start.\n", __FUNCTION__);
+
+	return ip_route_output_flow(rp, flp, sk, flags);
+}
+
+int tcpcp_ip_route_output_key(struct rtable **rp, const struct flowi *flp)
+{
+	/* plug-in. */
+	plugin_dummy();
+
+	/* start. */
+	DPRINTK("TCPCP : %s : start.\n", __FUNCTION__);
+
+	return __ip_route_output_key(rp, flp);
+}
+
+EXPORT_SYMBOL(tcpcp_rt_bind_peer);
+EXPORT_SYMBOL(tcpcp_ip_route_output_flow);
+EXPORT_SYMBOL(tcpcp_ip_route_output_key);
+#endif
diff -urbpBPN osdl/net/ipv4/tcp.c osdl.tcpcp/net/ipv4/tcp.c
--- osdl/net/ipv4/tcp.c	2006-01-20 02:32:05.000000000 +0000
+++ osdl.tcpcp/net/ipv4/tcp.c	2006-02-09 04:48:33.000000000 +0000
@@ -267,6 +267,10 @@
 #include <asm/uaccess.h>
 #include <asm/ioctls.h>
 
+#if defined(CONFIG_TCPCP) || defined(CONFIG_TCPCP_MODULE)
+#include <linux/tcpcp.h>
+#endif
+ 
 int sysctl_tcp_fin_timeout = TCP_FIN_TIMEOUT;
 
 DEFINE_SNMP_STAT(struct tcp_mib, tcp_statistics) __read_mostly;
@@ -1469,6 +1473,15 @@ void tcp_close(struct sock *sk, long tim
 	int data_was_unread = 0;
 
 	lock_sock(sk);
+
+#if defined(CONFIG_TCPCP) || defined(CONFIG_TCPCP_MODULE)
+	/* start. */
+	DPRINTK("TCPCP : %s : start. sk=0x%p, timeout=%ld\n",
+		__FUNCTION__, sk, timeout);
+
+	tcpcp_call_close_hook(sk);
+#endif
+
 	sk->sk_shutdown = SHUTDOWN_MASK;
 
 	if (sk->sk_state == TCP_LISTEN) {
@@ -1612,6 +1625,11 @@ out:
 	bh_unlock_sock(sk);
 	local_bh_enable();
 	sock_put(sk);
+
+#if defined(CONFIG_TCPCP) || defined(CONFIG_TCPCP_MODULE)
+	/* end. */
+	DPRINTK("TCPCP : %s : end.\n", __FUNCTION__);
+#endif
 }
 
 /* These states need RST on ABORT according to RFC793 */
@@ -1695,6 +1713,12 @@ int tcp_setsockopt(struct sock *sk, int 
 	int val;
 	int err = 0;
 
+#if defined(CONFIG_TCPCP) || defined(CONFIG_TCPCP_MODULE)
+	/* start. */
+	DPRINTK("TCPCP : %s : start. sk=%p, optname=%d\n",
+		__FUNCTION__, sk, optname);
+#endif
+
 	if (level != SOL_TCP)
 		return tp->af_specific->setsockopt(sk, level, optname,
 						   optval, optlen);
@@ -1863,11 +1887,28 @@ int tcp_setsockopt(struct sock *sk, int 
 		}
 		break;
 
+#if defined(CONFIG_TCPCP) || defined(CONFIG_TCPCP_MODULE)
+	case TCPCP_SET_SI:
+	case TCPCP_SET_SI_ALL:
+		err = tcpcp_call_set_si_hook(sk, optname,
+			(struct tcpcp_total_si_hdr *)optval, optlen);
+		if (err != 0) {
+			release_sock(sk);
+			return err;
+		}
+		break;
+#endif
+
 	default:
 		err = -ENOPROTOOPT;
 		break;
 	};
 	release_sock(sk);
+
+#if defined(CONFIG_TCPCP) || defined(CONFIG_TCPCP_MODULE)
+	/* end. */
+	DPRINTK("TCPCP : %s : end. err=%d\n", __FUNCTION__, err);
+#endif
 	return err;
 }
 
@@ -1937,6 +1978,13 @@ int tcp_getsockopt(struct sock *sk, int 
 	struct inet_connection_sock *icsk = inet_csk(sk);
 	struct tcp_sock *tp = tcp_sk(sk);
 	int val, len;
+#if defined(CONFIG_TCPCP) || defined(CONFIG_TCPCP_MODULE)
+	int error = 0;
+
+	/* start. */
+	DPRINTK("TCPCP : %s : start. sk=%p, optname=%d\n",
+		__FUNCTION__, sk, optname);
+#endif
 
 	if (level != SOL_TCP)
 		return tp->af_specific->getsockopt(sk, level, optname,
@@ -2014,6 +2062,62 @@ int tcp_getsockopt(struct sock *sk, int 
 		if (copy_to_user(optval, icsk->icsk_ca_ops->name, len))
 			return -EFAULT;
 		return 0;
+
+#if defined(CONFIG_TCPCP) || defined(CONFIG_TCPCP_MODULE)
+	case TCPCP_MAKE_SI:
+	case TCPCP_MAKE_SI_ALL:
+	case TCPCP_STOP:
+	case TCPCP_STOP_ALL:
+	case TCPCP_CLOSE_ALL:
+	case TCPCP_START:
+	case TCPCP_START_ALL:
+	case TCPCP_GET_RES_SIZE: {
+		struct result res;
+
+		/* @@@ for DEBUG @@@ */
+		DPRINTK("TCPCP : %s : case TCPCP_COM_OPE\n", __FUNCTION__);
+
+		error = tcpcp_call_com_ope_hook(sk, optname, &res);
+		if (error != 0) {
+			DPRINTK("TCPCP : %s : [Error] can't common operation."
+				" error=%d\n", __FUNCTION__, error);
+			return error;
+		}
+		/* @@@ for DEBUG @@@ */
+		DPRINTK("TCPCP : %s : after tcpcp_call_com_ope_hook.\n",
+			__FUNCTION__);
+
+		len = sizeof(struct result);
+		if (put_user(len, optlen))
+			return -EFAULT;
+		if (copy_to_user(optval, &res, len))
+			return -EFAULT;
+
+		/* end. */
+		DPRINTK("TCPCP : %s : end.\n", __FUNCTION__);
+		return 0;
+	}
+	case TCPCP_GET_SI:
+		/* @@@ for DEBUG @@@ */
+		DPRINTK("TCPCP : %s : case TCPCP_GET_SI\n", __FUNCTION__);
+
+		error = tcpcp_call_get_si_hook(sk,
+				(struct tcpcp_total_si_hdr *)optval, optlen);
+
+		/* end. */
+		DPRINTK("TCPCP : %s : end. error=%d\n", __FUNCTION__, error);
+		return error;
+	case TCPCP_GET_RES:
+		/* @@@ for DEBUG @@@ */
+		DPRINTK("TCPCP : %s : case TCPCP_GET_RES\n", __FUNCTION__);
+
+		error = tcpcp_call_get_res_hook(sk, (struct fdr *)optval,
+						optlen);
+		/* end. */
+		DPRINTK("TCPCP : %s : end. error=%d\n", __FUNCTION__, error);
+		return error;
+#endif /* defined(CONFIG_TCPCP) || defined(CONFIG_TCPCP_MODULE) */
+
 	default:
 		return -ENOPROTOOPT;
 	};
diff -urbpBPN osdl/net/ipv4/tcp_input.c osdl.tcpcp/net/ipv4/tcp_input.c
--- osdl/net/ipv4/tcp_input.c	2006-01-20 02:32:05.000000000 +0000
+++ osdl.tcpcp/net/ipv4/tcp_input.c	2006-02-09 04:48:33.000000000 +0000
@@ -72,6 +72,10 @@
 #include <linux/ipsec.h>
 #include <asm/unaligned.h>
 
+#if defined(CONFIG_TCPCP) || defined(CONFIG_TCPCP_MODULE)
+#include <linux/tcpcp.h>
+#endif
+
 int sysctl_tcp_timestamps = 1;
 int sysctl_tcp_window_scaling = 1;
 int sysctl_tcp_sack = 1;
@@ -1363,7 +1367,12 @@ static inline int tcp_fackets_out(struct
 
 static inline int tcp_skb_timedout(struct sock *sk, struct sk_buff *skb)
 {
+#if defined(CONFIG_TCPCP) || defined(CONFIG_TCPCP_MODULE)
+	return (tp_time_stamp(tcp_sk(sk)) - TCP_SKB_CB(skb)->when
+		> inet_csk(sk)->icsk_rto);
+#else
 	return (tcp_time_stamp - TCP_SKB_CB(skb)->when > inet_csk(sk)->icsk_rto);
+#endif
 }
 
 static inline int tcp_head_timedout(struct sock *sk, struct tcp_sock *tp)
@@ -2032,7 +2041,11 @@ static void tcp_ack_saw_tstamp(struct so
 	 * in window is lost... Voila.	 			--ANK (010210)
 	 */
 	struct tcp_sock *tp = tcp_sk(sk);
+#if defined(CONFIG_TCPCP) || defined(CONFIG_TCPCP_MODULE)
+	const __u32 seq_rtt = tp_time_stamp(tp) - tp->rx_opt.rcv_tsecr;
+#else
 	const __u32 seq_rtt = tcp_time_stamp - tp->rx_opt.rcv_tsecr;
+#endif
 	tcp_rtt_estimator(sk, seq_rtt);
 	tcp_set_rto(sk);
 	inet_csk(sk)->icsk_backoff = 0;
@@ -2162,7 +2175,11 @@ static int tcp_clean_rtx_queue(struct so
 	struct tcp_sock *tp = tcp_sk(sk);
 	const struct inet_connection_sock *icsk = inet_csk(sk);
 	struct sk_buff *skb;
+#if defined(CONFIG_TCPCP) || defined(CONFIG_TCPCP_MODULE)
+	__u32 now = tp_time_stamp(tp);
+#else
 	__u32 now = tcp_time_stamp;
+#endif
 	int acked = 0;
 	__s32 seq_rtt = -1;
 	u32 pkts_acked = 0;
@@ -3727,6 +3744,30 @@ int tcp_rcv_established(struct sock *sk,
 {
 	struct tcp_sock *tp = tcp_sk(sk);
 
+#if defined(CONFIG_TCPCP) || defined(CONFIG_TCPCP_MODULE)
+	/* When TCPCP SI setting operation is performed. */
+	if (tp->set_flag == TCPCP_SET_FLAG_ON) {
+		DPRINTK("TCPCP : %s : start fix up seq and ts.\n",
+			__FUNCTION__);
+
+		/* clear probe0 and retransmit timer. */
+		inet_csk_clear_xmit_timer(sk, ICSK_TIME_PROBE0);
+		inet_csk_clear_xmit_timer(sk, ICSK_TIME_RETRANS);
+
+		/* fix up sequence number. */
+		tcpcp_fix_seq(sk, ntohl(th->seq), ntohl(th->ack_seq));
+
+		/* parse TCP options. */
+		if (tcp_fast_parse_options(skb, th, tp) && tp->rx_opt.saw_tstamp)
+			/* fix up timestamp. */
+			tcpcp_fix_ts(sk, tp->rx_opt.rcv_tsecr);
+
+		/* reset set_flag. */
+		tp->set_flag = TCPCP_SET_FLAG_OFF;
+		DPRINTK("TCPCP : %s : end fix up seq and ts.\n", __FUNCTION__);
+	}
+#endif
+
 	/*
 	 *	Header prediction.
 	 *	The code loosely follows the one in the famous 
@@ -3989,7 +4030,11 @@ static int tcp_rcv_synsent_state_process
 
 		if (tp->rx_opt.saw_tstamp && tp->rx_opt.rcv_tsecr &&
 		    !between(tp->rx_opt.rcv_tsecr, tp->retrans_stamp,
+#if defined(CONFIG_TCPCP) || defined(CONFIG_TCPCP_MODULE)
+			     tp_time_stamp(tp))) {
+#else
 			     tcp_time_stamp)) {
+#endif
 			NET_INC_STATS_BH(LINUX_MIB_PAWSACTIVEREJECTED);
 			goto reset_and_undo;
 		}
@@ -4475,3 +4520,59 @@ EXPORT_SYMBOL(sysctl_tcp_abc);
 EXPORT_SYMBOL(tcp_parse_options);
 EXPORT_SYMBOL(tcp_rcv_established);
 EXPORT_SYMBOL(tcp_rcv_state_process);
+
+#if defined(CONFIG_TCPCP) || defined(CONFIG_TCPCP_MODULE)
+void tcpcp_init_buffer_space(struct sock *sk)
+{
+	/* plug-in. */
+	plugin_dummy();
+
+	/* start. */
+	DPRINTK("TCPCP : %s : start.\n", __FUNCTION__);
+
+	tcp_init_buffer_space(sk);
+
+	/* end. */
+	DPRINTK("TCPCP : %s : end.\n", __FUNCTION__);
+	return;
+}
+
+void tcpcp_clear_retrans(struct tcp_sock *tp)
+{
+	/* plug-in. */
+	plugin_dummy();
+
+	/* start. */
+	DPRINTK("TCPCP : %s : start.\n", __FUNCTION__);
+
+	tcp_clear_retrans(tp);
+
+	/* end. */
+	DPRINTK("TCPCP : %s : end.\n", __FUNCTION__);
+	return;
+}
+
+void tcpcp_ca_init(struct tcp_sock *tp)
+{
+	/* plug-in. */
+	plugin_dummy();
+
+	/* start. */
+	DPRINTK("TCPCP : %s : start.\n", __FUNCTION__);
+
+	/*XXX tcp_ca_init(tp);*/
+
+	/* end. */
+	DPRINTK("TCPCP : %s : end.\n", __FUNCTION__);
+	return;
+}
+
+EXPORT_SYMBOL(sysctl_tcp_timestamps);
+EXPORT_SYMBOL(sysctl_tcp_window_scaling);
+EXPORT_SYMBOL(sysctl_tcp_sack);
+EXPORT_SYMBOL(sysctl_tcp_adv_win_scale);
+
+EXPORT_SYMBOL(tcpcp_init_buffer_space);
+EXPORT_SYMBOL(tcpcp_clear_retrans);
+EXPORT_SYMBOL(tcpcp_ca_init);
+#endif
diff -urbpBPN osdl/net/ipv4/tcp_ipv4.c osdl.tcpcp/net/ipv4/tcp_ipv4.c
--- osdl/net/ipv4/tcp_ipv4.c	2006-01-20 02:32:05.000000000 +0000
+++ osdl.tcpcp/net/ipv4/tcp_ipv4.c	2006-02-09 04:48:33.000000000 +0000
@@ -77,6 +77,10 @@
 #include <linux/proc_fs.h>
 #include <linux/seq_file.h>
 
+#if defined(CONFIG_TCPCP) || defined(CONFIG_TCPCP_MODULE)
+#include <linux/tcpcp.h>
+#endif
+
 int sysctl_tcp_tw_reuse;
 int sysctl_tcp_low_latency;
 
@@ -315,6 +319,19 @@ out:
 	}
 }
 
+#if defined(CONFIG_TCPCP) || defined(CONFIG_TCPCP_MODULE)
+int tcpcp_v4_hash_connect(struct sock *sk)
+{
+	/* plug-in. */
+	plugin_dummy();
+
+	/* start. */
+	DPRINTK("TCPCP : %s : start.\n", __FUNCTION__);
+
+	return tcp_v4_hash_connect(sk);
+}
+#endif
+
 /* This will initiate an outgoing connection. */
 int tcp_v4_connect(struct sock *sk, struct sockaddr *uaddr, int addr_len)
 {
@@ -2030,3 +2047,6 @@ EXPORT_SYMBOL(sysctl_local_port_range);
 EXPORT_SYMBOL(sysctl_tcp_low_latency);
 EXPORT_SYMBOL(sysctl_tcp_tw_reuse);
 
+#if defined(CONFIG_TCPCP) || defined(CONFIG_TCPCP_MODULE)
+EXPORT_SYMBOL(tcpcp_v4_hash_connect);
+#endif
diff -urbpBPN osdl/net/ipv4/tcp_minisocks.c osdl.tcpcp/net/ipv4/tcp_minisocks.c
--- osdl/net/ipv4/tcp_minisocks.c	2006-01-20 02:32:05.000000000 +0000
+++ osdl.tcpcp/net/ipv4/tcp_minisocks.c	2006-02-09 04:48:33.000000000 +0000
@@ -305,6 +305,11 @@ void tcp_time_wait(struct sock *sk, int 
 			tw->tw_ipv6only = np->ipv6only;
 		}
 #endif
+
+#if defined(CONFIG_TCPCP) || defined(CONFIG_TCPCP_MODULE)
+		tcptw->ts_offset = tp->ts_offset;
+#endif
+
 		/* Linkage updates. */
 		__inet_twsk_hashdance(tw, sk, &tcp_hashinfo);
 
diff -urbpBPN osdl/net/ipv4/tcp_output.c osdl.tcpcp/net/ipv4/tcp_output.c
--- osdl/net/ipv4/tcp_output.c	2006-01-20 02:32:06.000000000 +0000
+++ osdl.tcpcp/net/ipv4/tcp_output.c	2006-02-09 04:48:33.000000000 +0000
@@ -42,6 +42,10 @@
 #include <linux/module.h>
 #include <linux/smp_lock.h>
 
+#if defined(CONFIG_TCPCP) || defined(CONFIG_TCPCP_MODULE)
+#include <linux/tcpcp.h>
+#endif
+
 /* People can turn this off for buggy TCP's found in printers etc. */
 int sysctl_tcp_retrans_collapse = 1;
 
@@ -1051,7 +1055,11 @@ static int tcp_write_xmit(struct sock *s
 		    unlikely(tso_fragment(sk, skb, limit, mss_now)))
 			break;
 
+#if defined(CONFIG_TCPCP) || defined(CONFIG_TCPCP_MODULE)
+		TCP_SKB_CB(skb)->when = tp_time_stamp(tp);
+#else
 		TCP_SKB_CB(skb)->when = tcp_time_stamp;
+#endif
 
 		if (unlikely(tcp_transmit_skb(sk, skb, 1, GFP_ATOMIC)))
 					break;
@@ -1124,7 +1132,11 @@ void tcp_push_one(struct sock *sk, unsig
 			return;
 
 		/* Send it out now. */
+#if defined(CONFIG_TCPCP) || defined(CONFIG_TCPCP_MODULE)
+			TCP_SKB_CB(skb)->when = tp_time_stamp(tp);
+#else
 			TCP_SKB_CB(skb)->when = tcp_time_stamp;
+#endif
 
 		if (likely(!tcp_transmit_skb(sk, skb, 1, sk->sk_allocation))) {
 			update_send_head(sk, tp, skb);
@@ -1444,8 +1456,11 @@ int tcp_retransmit_skb(struct sock *sk, 
 	/* Make a copy, if the first transmission SKB clone we made
 	 * is still in somebody's hands, else make a clone.
 	 */
+#if defined(CONFIG_TCPCP) || defined(CONFIG_TCPCP_MODULE)
+	TCP_SKB_CB(skb)->when = tp_time_stamp(tp);
+#else
 	TCP_SKB_CB(skb)->when = tcp_time_stamp;
-
+#endif
 	err = tcp_transmit_skb(sk, skb, 1, GFP_ATOMIC);
 
 	if (err == 0) {
@@ -1679,7 +1694,11 @@ void tcp_send_active_reset(struct sock *
 	/* Send it off. */
 	TCP_SKB_CB(skb)->seq = tcp_acceptable_seq(sk, tp);
 	TCP_SKB_CB(skb)->end_seq = TCP_SKB_CB(skb)->seq;
+#if defined(CONFIG_TCPCP) || defined(CONFIG_TCPCP_MODULE)
+	TCP_SKB_CB(skb)->when = tp_time_stamp(tp);
+#else
 	TCP_SKB_CB(skb)->when = tcp_time_stamp;
+#endif
 	if (tcp_transmit_skb(sk, skb, 0, priority))
 		NET_INC_STATS(LINUX_MIB_TCPABORTFAILED);
 }
@@ -1714,7 +1733,11 @@ int tcp_send_synack(struct sock *sk)
 		TCP_SKB_CB(skb)->flags |= TCPCB_FLAG_ACK;
 		TCP_ECN_send_synack(tcp_sk(sk), skb);
 	}
+#if defined(CONFIG_TCPCP) || defined(CONFIG_TCPCP_MODULE)
+	TCP_SKB_CB(skb)->when = tp_time_stamp(tcp_sk(sk));
+#else
 	TCP_SKB_CB(skb)->when = tcp_time_stamp;
+#endif
 	return tcp_transmit_skb(sk, skb, 1, GFP_ATOMIC);
 }
 
@@ -1778,7 +1801,11 @@ struct sk_buff * tcp_make_synack(struct 
 	/* RFC1323: The window in SYN & SYN/ACK segments is never scaled. */
 	th->window = htons(req->rcv_wnd);
 
+#if defined(CONFIG_TCPCP) || defined(CONFIG_TCPCP_MODULE)
+	TCP_SKB_CB(skb)->when = tp_time_stamp(tp);
+#else
 	TCP_SKB_CB(skb)->when = tcp_time_stamp;
+#endif
 	tcp_syn_build_options((__u32 *)(th + 1), dst_metric(dst, RTAX_ADVMSS), ireq->tstamp_ok,
 			      ireq->sack_ok, ireq->wscale_ok, ireq->rcv_wscale,
 			      TCP_SKB_CB(skb)->when,
@@ -1870,7 +1897,11 @@ int tcp_connect(struct sock *sk)
 	tp->pushed_seq = tp->write_seq;
 
 	/* Send it off. */
+#if defined(CONFIG_TCPCP) || defined(CONFIG_TCPCP_MODULE)
+	TCP_SKB_CB(buff)->when = tp_time_stamp(tp);
+#else
 	TCP_SKB_CB(buff)->when = tcp_time_stamp;
+#endif
 	tp->retrans_stamp = TCP_SKB_CB(buff)->when;
 	skb_header_release(buff);
 	__skb_queue_tail(&sk->sk_write_queue, buff);
@@ -1971,7 +2002,11 @@ void tcp_send_ack(struct sock *sk)
 
 		/* Send it off, this clears delayed acks for us. */
 		TCP_SKB_CB(buff)->seq = TCP_SKB_CB(buff)->end_seq = tcp_acceptable_seq(sk, tp);
+#if defined(CONFIG_TCPCP) || defined(CONFIG_TCPCP_MODULE)
+		TCP_SKB_CB(buff)->when = tp_time_stamp(tp);
+#else
 		TCP_SKB_CB(buff)->when = tcp_time_stamp;
+#endif
 		tcp_transmit_skb(sk, buff, 0, GFP_ATOMIC);
 	}
 }
@@ -2011,7 +2046,11 @@ static int tcp_xmit_probe_skb(struct soc
 	 */
 	TCP_SKB_CB(skb)->seq = urgent ? tp->snd_una : tp->snd_una - 1;
 	TCP_SKB_CB(skb)->end_seq = TCP_SKB_CB(skb)->seq;
+#if defined(CONFIG_TCPCP) || defined(CONFIG_TCPCP_MODULE)
+	TCP_SKB_CB(skb)->when = tp_time_stamp(tp);
+#else
 	TCP_SKB_CB(skb)->when = tcp_time_stamp;
+#endif
 	return tcp_transmit_skb(sk, skb, 0, GFP_ATOMIC);
 }
 
@@ -2044,7 +2083,11 @@ int tcp_write_wakeup(struct sock *sk)
 				tcp_set_skb_tso_segs(sk, skb, mss);
 
 			TCP_SKB_CB(skb)->flags |= TCPCB_FLAG_PSH;
+#if defined(CONFIG_TCPCP) || defined(CONFIG_TCPCP_MODULE)
+			TCP_SKB_CB(skb)->when = tp_time_stamp(tp);
+#else
 			TCP_SKB_CB(skb)->when = tcp_time_stamp;
+#endif
 			err = tcp_transmit_skb(sk, skb, 1, GFP_ATOMIC);
 			if (!err) {
 				update_send_head(sk, tp, skb);
@@ -2070,14 +2113,22 @@ void tcp_send_probe0(struct sock *sk)
 	int err;
 
 	err = tcp_write_wakeup(sk);
+#if defined(CONFIG_TCPCP) || defined(CONFIG_TCPCP_MODULE)
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : set_flag=%d\n", __FUNCTION__, tp->set_flag);
 
+	if (tp->set_flag == TCPCP_SET_FLAG_ON)
+		goto reset_timer;
+#endif
 	if (tp->packets_out || !sk->sk_send_head) {
 		/* Cancel probe timer, if it is not required. */
 		icsk->icsk_probes_out = 0;
 		icsk->icsk_backoff = 0;
 		return;
 	}
-
+#if defined(CONFIG_TCPCP) || defined(CONFIG_TCPCP_MODULE)
+reset_timer:
+#endif
 	if (err <= 0) {
 		if (icsk->icsk_backoff < sysctl_tcp_retries2)
 			icsk->icsk_backoff++;
@@ -2106,3 +2157,53 @@ EXPORT_SYMBOL(tcp_make_synack);
 EXPORT_SYMBOL(tcp_simple_retransmit);
 EXPORT_SYMBOL(tcp_sync_mss);
 EXPORT_SYMBOL(sysctl_tcp_tso_win_divisor);
+
+#if defined(CONFIG_TCPCP) || defined(CONFIG_TCPCP_MODULE)
+void tcpcp_send_probe0(struct sock *sk)
+{
+	/* plug-in. */
+	plugin_dummy();
+
+	/* start. */
+	DPRINTK("TCPCP : %s : start.\n", __FUNCTION__);
+
+	tcp_send_probe0(sk);
+
+	/* end. */
+	DPRINTK("TCPCP : %s : end.\n", __FUNCTION__);
+	return;
+}
+
+int tcpcp_retransmit_skb(struct sock *sk, struct sk_buff *skb)
+{
+	/* plug-in. */
+	plugin_dummy();
+
+	/* start. */
+	DPRINTK("TCPCP : %s : start.\n", __FUNCTION__);
+
+	return tcp_retransmit_skb(sk, skb);
+}
+
+void tcpcp_select_initial_window(int __space, __u32 mss,
+				__u32 *rcv_wnd, __u32 *window_clamp,
+				int wscale_ok, __u8 *rcv_wscale)
+{
+	/* plug-in. */
+	plugin_dummy();
+
+	/* start. */
+	DPRINTK("TCPCP : %s : start.\n", __FUNCTION__);
+
+	tcp_select_initial_window(__space, mss, rcv_wnd, window_clamp,
+				  wscale_ok, rcv_wscale);
+
+	/* end. */
+	DPRINTK("TCPCP : %s : end.\n", __FUNCTION__);
+	return;
+}
+
+EXPORT_SYMBOL(tcpcp_send_probe0);
+EXPORT_SYMBOL(tcpcp_retransmit_skb);
+EXPORT_SYMBOL(tcpcp_select_initial_window);
+#endif
diff -urbpBPN osdl/net/ipv4/tcp_timer.c osdl.tcpcp/net/ipv4/tcp_timer.c
--- osdl/net/ipv4/tcp_timer.c	2006-01-20 02:32:04.000000000 +0000
+++ osdl.tcpcp/net/ipv4/tcp_timer.c	2006-02-09 04:48:33.000000000 +0000
@@ -23,6 +23,10 @@
 #include <linux/module.h>
 #include <net/tcp.h>
 
+#if defined(CONFIG_TCPCP) || defined(CONFIG_TCPCP_MODULE)
+#include <linux/tcpcp.h>
+#endif
+
 int sysctl_tcp_syn_retries = TCP_SYN_RETRIES; 
 int sysctl_tcp_synack_retries = TCP_SYNACK_RETRIES; 
 int sysctl_tcp_keepalive_time = TCP_KEEPALIVE_TIME;
@@ -237,11 +241,17 @@ static void tcp_probe_timer(struct sock 
 	struct tcp_sock *tp = tcp_sk(sk);
 	int max_probes;
 
+#if defined(CONFIG_TCPCP) || defined(CONFIG_TCPCP_MODULE)
+        if (tp->set_flag == TCPCP_SET_FLAG_ON)
+                goto send_probe;
+#endif
 	if (tp->packets_out || !sk->sk_send_head) {
 		icsk->icsk_probes_out = 0;
 		return;
 	}
-
+#if defined(CONFIG_TCPCP) || defined(CONFIG_TCPCP_MODULE)
+send_probe:
+#endif
 	/* *WARNING* RFC 1122 forbids this
 	 *
 	 * It doesn't AFAIK, because we kill the retransmit timer -AK
@@ -526,3 +536,26 @@ out:
 	bh_unlock_sock(sk);
 	sock_put(sk);
 }
+
+#if defined(CONFIG_TCPCP) || defined(CONFIG_TCPCP_MODULE)
+void tcpcp_set_keepalive(struct sock *sk, int val)
+{
+	/* plug-in. */
+	plugin_dummy();
+
+	/* start. */
+	DPRINTK("TCPCP : %s : start.\n", __FUNCTION__);
+
+	tcp_set_keepalive(sk, val);
+
+	/* end. */	
+	DPRINTK("TCPCP : %s : end.\n", __FUNCTION__);
+	return;
+}
+
+EXPORT_SYMBOL(sysctl_tcp_keepalive_time);
+EXPORT_SYMBOL(sysctl_tcp_keepalive_probes);
+EXPORT_SYMBOL(sysctl_tcp_keepalive_intvl);
+
+EXPORT_SYMBOL(tcpcp_set_keepalive);
+#endif
diff -urbpBPN osdl/net/ipv4/tcpcp.c osdl.tcpcp/net/ipv4/tcpcp.c
--- osdl/net/ipv4/tcpcp.c	1970-01-01 00:00:00.000000000 +0000
+++ osdl.tcpcp/net/ipv4/tcpcp.c	2006-02-09 04:48:33.000000000 +0000
@@ -0,0 +1,7372 @@
+/*
+ * tcpcp.c - TCP connection passing
+ *
+ * Written 2002,2004 by Werner Almesberger
+ *
+ * Copyright (C) 2005 NTT Corporation
+ */
+
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/fs.h>
+#include <linux/errno.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+#include <linux/net.h>
+#include <linux/tcp.h>
+#include <linux/security.h>
+#include <linux/tcpcp.h>
+#include <net/sock.h>
+#include <net/tcp.h>
+#include <net/inet_common.h>
+#include <net/ipv6.h>
+#include <asm/uaccess.h>
+
+#include <linux/file.h>
+#include <linux/syscalls.h>
+#if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)
+#include <net/ip6_route.h>
+#include <net/transp_v6.h>
+#include <net/addrconf.h>
+#endif
+
+#define TCPCP_CURRENT_SI_MAJOR	0
+#define TCPCP_CURRENT_SI_MINOR	0
+
+MODULE_LICENSE("GPL");
+
+static struct tcpcp_list proc_list;
+static struct tcpcp_list timeout_list;
+
+static void tcpcp_watch_timeout(unsigned long);
+static struct timer_list tcpcp_timer
+	= TIMER_INITIALIZER(tcpcp_watch_timeout, 0, 0);
+
+DECLARE_RWSEM(tcpcp_sem);
+
+#ifdef CONFIG_TCPCP_DEBUG
+/* @@@ for DEBUG @@@ */
+static void __print_list(void);
+static void print_list(void);
+static void skb_queue_check(struct sk_buff_head *queue);
+static void check_fd(void);
+#endif
+
+/* ----- check socket ------------------------------------------------------ */
+
+/**
+ * tcpcp_check_sk_type - check type of TCP socket.
+ *
+ * [Args]
+ *   (IN) *sk : TCP socket
+ *
+ * [Return]
+ *   0               : OK.
+ *  -EPFNOSUPPORT    : NG.
+ *  -ESOCKTNOSUPPORT : NG.
+ *  -EPROTONOSUPPORT : NG.
+ **/
+static int tcpcp_check_sk_type(struct sock *sk)
+{
+	/* plug-in. */
+	plugin_dummy();
+
+	/* start. */
+	DPRINTK("TCPCP : %s : start. sk=0x%p\n", __FUNCTION__, sk);
+
+#if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)
+	if ((sk->sk_family != PF_INET) && (sk->sk_family != PF_INET6)) {
+#else
+	if (sk->sk_family != PF_INET) {
+#endif
+		DPRINTK("TCPCP : %s : The specified socket family is not" \
+			" supported.\n", __FUNCTION__);
+		return -EPFNOSUPPORT;
+	}
+
+	if (sk->sk_type != SOCK_STREAM) {
+		DPRINTK("TCPCP : %s : The specified socket type is not" \
+			" supported.\n", __FUNCTION__);
+		return -ESOCKTNOSUPPORT;
+	}
+
+	if (sk->sk_protocol != IPPROTO_TCP) {
+		DPRINTK("TCPCP : %s : The specified socket protocol is not" \
+			" supported.\n", __FUNCTION__);
+		return -EPROTONOSUPPORT;
+	}
+
+	/* end. */
+	DPRINTK("TCPCP : %s : end.\n", __FUNCTION__);
+	return 0;
+}
+
+/**
+ * tcpcp_check_sk_state - check state of TCP socket.
+ *
+ * [Args]
+ *   (IN) *sk  : TCP socket
+ *   (IN) flag : TCPCP operation flag
+ *
+ * [Return]
+ *   0      : OK.
+ *  -EBADFD : NG.
+ **/
+static int tcpcp_check_sk_state(struct sock *sk, unsigned char flag)
+{
+	unsigned char cflag;
+
+	/* plug-in. */
+	plugin_dummy();
+
+	/* start. */
+	DPRINTK("TCPCP : %s : start. sk=0x%p, flag=%u\n",
+		__FUNCTION__, sk, flag);
+
+	/* The bit which shows ALL is set as 0. */
+	cflag = flag & ~TCPCP_FLAG_ALL;
+
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : sk->sk_socket->state=%d\n",
+		__FUNCTION__, sk->sk_socket->state);
+	DPRINTK("TCPCP : %s : sk->sk_state=%d\n",
+		__FUNCTION__, sk->sk_state);
+
+	switch (cflag) {
+	case TCPCP_FLAG_STOP:
+		if ((sk->sk_socket->state != SS_CONNECTING)
+		    && (sk->sk_socket->state != SS_CONNECTED)) {
+			DPRINTK("TCPCP : %s : Invalid socket state" \
+				"(sk->sk_socket->state).\n", __FUNCTION__);
+			return -EBADFD;
+		}
+		if (sk->sk_state == TCP_CLOSE) {
+			DPRINTK("TCPCP : %s : Invalid socket state" \
+				"(sk->sk_state).\n", __FUNCTION__);
+			return -EBADFD;
+		}
+		break;
+
+	case TCPCP_FLAG_MAKE_SI:
+		if ((sk->sk_socket->state != SS_CONNECTING)
+		    && (sk->sk_socket->state != SS_CONNECTED)) {
+			DPRINTK("TCPCP : %s : Invalid socket state" \
+				"(sk->sk_socket->state).\n", __FUNCTION__);
+			return -EBADFD;
+		}
+		if (sk->sk_state != TCP_ESTABLISHED) {
+			DPRINTK("TCPCP : %s : Invalid socket state" \
+				"(sk->sk_state).\n", __FUNCTION__);
+			return -EBADFD;
+		}
+		break;
+
+	case TCPCP_FLAG_SET_SI:
+		if (!(flag & TCPCP_FLAG_ALL)) {
+			if (sk->sk_state != TCP_CLOSE) {
+				DPRINTK("TCPCP : %s : Invalid socket state" \
+					"(sk->sk_state).\n", __FUNCTION__);
+				return -EBADFD;
+			}
+		}
+		break;
+
+	case TCPCP_FLAG_START:
+	case TCPCP_FLAG_CLOSE:
+		break;
+
+	default:
+		DPRINTK("TCPCP : %s : Invalid operation flag.\n", __FUNCTION__);
+		return -EBADFD;
+	}
+
+	/* end. */
+	DPRINTK("TCPCP : %s : end.\n", __FUNCTION__);
+	return 0;
+}
+
+/**
+ * tcpcp_get_sk_i - check FD and get SOCKET_I().
+ *
+ * [Args]
+ *   (IN) *sk      : TCP socket
+ *   (IN) fd       : FD
+ *   (IN) *r_entry : Request Entry (to get flag "ONE" / "ALL" and set FD)
+ *
+ * [Return]
+ *   normal : SOCKET_I()
+ *   NULL   : not target FD
+ **/
+static struct sock *tcpcp_get_sk_i(struct sock *sk, int fd,
+				   struct tcpcp_req_entry *r_entry)
+{
+	struct files_struct *files = current->files;
+	struct file *filp;
+	struct sock *sk_i;
+	unsigned char flag = r_entry->flag;
+	int error = 0;
+
+	/* plug-in. */
+	plugin_dummy();
+
+	/* start. */
+	DPRINTK("TCPCP : %s : start. sk=0x%p, fd=%d, r_entry=0x%p\n",
+		__FUNCTION__, sk, fd, r_entry);
+
+	/* get file pointer. */
+	filp = fcheck_files(files, fd);
+	if (filp == NULL) {
+		DPRINTK("TCPCP : %s : Can't get file pointer.\n", __FUNCTION__);
+		return NULL;
+	}
+
+	if (!S_ISSOCK(filp->f_dentry->d_inode->i_mode)) {
+		DPRINTK("TCPCP : %s : Can't get socket.\n", __FUNCTION__);
+		return NULL;
+	}
+
+	/* get socket from FD. */
+	sk_i = SOCKET_I(filp->f_dentry->d_inode)->sk;
+	if (sk_i == NULL) {
+		DPRINTK("TCPCP : %s : Can't get SOCKET_I.\n", __FUNCTION__);
+		return NULL;
+	}
+
+	if (flag & TCPCP_FLAG_ALL) {
+		/* check dummy FD. (only "ALL") */
+		if (sk_i == sk) {
+			r_entry->fd = fd;
+			DPRINTK("TCPCP : %s : Dummy FD number is %d.\n",
+				__FUNCTION__, fd);
+			return NULL;
+		}
+
+		/* check type of socket. (only "ALL") */
+		error = tcpcp_check_sk_type(sk_i);
+		if (error != 0) {
+			DPRINTK("TCPCP : %s : This socket is not target.\n",
+				__FUNCTION__);
+			return NULL;
+		}
+
+		/* check state of TCP socket. (only "ALL") */
+		error = tcpcp_check_sk_state(sk_i, flag);
+		if (error != 0) {
+			DPRINTK("TCPCP : %s : This socket is not target.\n",
+				__FUNCTION__);
+			return NULL;
+		}
+	} else {
+		/* check target FD. (only "ONE") */
+		if (sk_i != sk) {
+			DPRINTK("TCPCP : %s : This socket is not target.\n",
+				__FUNCTION__);
+			return NULL;
+		}
+
+		r_entry->fd = fd;
+		DPRINTK("TCPCP : %s : Target FD number is %d.\n",
+			__FUNCTION__, fd);
+	}
+
+	/* end. */
+	DPRINTK("TCPCP : %s : end. sk_i=0x%p\n", __FUNCTION__, sk_i);
+	return sk_i;
+}
+
+
+/* ----- Entry management (non-API) ---------------------------------------- */
+
+/* ----- common entry ----- */
+
+/**
+ * tcpcp_add_com_entry - add and change common entry.
+ *
+ * [Args]
+ *   (IN) flag        : "ONE" / "ALL"
+ *   (IN/OUT) **entry : (IN)  now common entry (or NULL)
+ *                      (OUT) new common entry
+ *
+ * [Return]
+ *   0      : OK.
+ *  -ENOMEM : NG.
+ **/
+static int tcpcp_add_com_entry(unsigned char flag,
+			       struct tcpcp_com_entry **entry)
+{
+	struct tcpcp_com_entry *new_entry;
+	unsigned int entry_size;
+
+	/* plug-in. */
+	plugin_dummy();
+
+	/* start. */
+	DPRINTK("TCPCP : %s : start. flag=%u\n", __FUNCTION__, flag);
+
+#ifdef CONFIG_TCPCP_DEBUG
+	/* @@@ print Process List with lock. (for DEBUG) @@@ */
+	print_list();
+#endif
+
+	/* select entry size. */
+	if (flag & TCPCP_FLAG_ALL)
+		entry_size = TCPCP_COM_ENTRY_SIZE_FOR_ALL;
+	else
+		entry_size = TCPCP_COM_ENTRY_SIZE_FOR_ONE;
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : entry_size=%u\n", __FUNCTION__, entry_size);
+
+	/* allocate common entry. */
+	new_entry = kmalloc(entry_size, GFP_KERNEL);
+	if (new_entry == NULL) {
+		DPRINTK("TCPCP : %s : [Error] can't allocate common entry.\n",
+			__FUNCTION__);
+		return -ENOMEM;
+	}
+
+	/* initialize common entry. */
+	memset(new_entry, 0, entry_size);
+	new_entry->next = NULL;
+	new_entry->max_data_len = entry_size - sizeof(struct tcpcp_com_entry);
+	new_entry->data_len = 0;
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : new_entry=0x%p\n",
+		__FUNCTION__, new_entry);
+	DPRINTK("TCPCP : %s : new_entry->max_data_len=%u\n",
+		__FUNCTION__, new_entry->max_data_len);
+	DPRINTK("TCPCP : %s : new_entry->data_len    =%u\n",
+		__FUNCTION__, new_entry->data_len);
+
+
+	if ((*entry) != NULL) {
+		/* link common entry. */
+		(*entry)->next = new_entry;
+		/* @@@ for DEBUG @@@ */
+		DPRINTK("TCPCP : %s :  *entry       =0x%p\n",
+			__FUNCTION__, *entry);
+		DPRINTK("TCPCP : %s : (*entry)->next=0x%p\n",
+			__FUNCTION__, (*entry)->next);
+	}
+
+	/* change now entry. */
+	(*entry) = new_entry;
+
+#ifdef CONFIG_TCPCP_DEBUG
+	/* @@@ print Process List with lock. (for DEBUG) @@@ */
+	print_list();
+#endif
+
+	/* end. */
+	DPRINTK("TCPCP : %s : end.\n", __FUNCTION__);
+	return 0;
+}
+
+/**
+ * tcpcp_del_all_com_entry - delete all common entry.
+ *
+ * [Args]
+ *   (IN/OUT) **entry : (IN) first common entry
+ *                      (OUT) NULL
+ **/
+static void tcpcp_del_all_com_entry(struct tcpcp_com_entry **entry)
+{
+	struct tcpcp_com_entry *next_entry;
+
+	/* plug-in. */
+	plugin_dummy();
+
+	/* start. */
+	DPRINTK("TCPCP : %s : start.\n", __FUNCTION__);
+
+#ifdef CONFIG_TCPCP_DEBUG
+	/* @@@ print Process List without lock. (for DEBUG) @@@ */
+	__print_list();
+#endif
+
+	while ((*entry) != NULL) {
+		/* free common entry. */
+		next_entry = (*entry)->next;
+		kfree(*entry);
+		(*entry) = next_entry;
+		/* @@@ for DEBUG @@@ */
+		DPRINTK("TCPCP : %s : common entry is deleted.\n",
+			__FUNCTION__);
+	}
+
+#ifdef CONFIG_TCPCP_DEBUG
+	/* @@@ print Process List without lock. (for DEBUG) @@@ */
+	__print_list();
+#endif
+
+	/* end. */
+	DPRINTK("TCPCP : %s : end.\n", __FUNCTION__);
+	return;
+}
+
+/* ----- Process Entry ----- */
+
+/**
+ * tcpcp_add_proc_entry - allocate and add Process Entry.
+ *
+ * [Args]
+ *   (IN) *sk  : TCP socket
+ *   (IN) flag : TCPCP operation flag
+ *
+ * [Return]
+ *   normal : new Process Entry
+ *   NULL   : -ENOMEM
+ **/
+static struct tcpcp_proc_entry *tcpcp_add_proc_entry(struct sock *sk,
+						     unsigned char flag)
+{
+	struct tcpcp_proc_entry *p_entry;
+	unsigned int p_entry_size;
+
+	/* plug-in. */
+	plugin_dummy();
+
+	/* start. */
+	DPRINTK("TCPCP : %s : start. sk=0x%p, flag=%u\n",
+		__FUNCTION__, sk, flag);
+
+	/* allocate Process Entry. */
+	p_entry_size = sizeof(struct tcpcp_proc_entry);
+	p_entry = kmalloc(p_entry_size, GFP_ATOMIC);
+	if (p_entry == NULL) {
+		DPRINTK("TCPCP : %s : [Error] can't allocate Process Entry.\n",
+			__FUNCTION__);
+		return NULL;
+	}
+
+	/* initialize Process Entry. */
+	memset(p_entry, 0, p_entry_size);
+	p_entry->tgid = current->tgid;
+	p_entry->flag = flag;
+	INIT_LIST_HEAD(&(p_entry->r_list_head));
+
+	/* link Process Entry to Process List. */
+	list_add_tail(&(p_entry->node), &(proc_list.head));
+
+	/* end. */
+	DPRINTK("TCPCP : %s : end. p_entry=0x%p\n", __FUNCTION__, p_entry);
+	return p_entry;
+}
+
+/**
+ * tcpcp_del_proc_entry
+ *   - delete and free Process Entry, if it doesn't have Request Entry.
+ *
+ * [Args]
+ *   (IN) *p_entry : Process Entry (not have Request Entry)
+ **/
+void tcpcp_del_proc_entry(struct tcpcp_proc_entry *p_entry)
+{
+	/* plug-in. */
+	plugin_dummy();
+
+	/* start. */
+	DPRINTK("TCPCP : %s : start.\n", __FUNCTION__);
+
+	/* check that Process Entry is NULL. */
+	if (p_entry == NULL) {
+		DPRINTK("TCPCP : %s : Process entry is NULL.\n", __FUNCTION__);
+		return;
+	}
+
+	/* check that Process Entry has Request Entry. */
+	if (list_empty(&(p_entry->r_list_head)) == 0) {
+		DPRINTK("TCPCP : %s : Process entry still holds some" \
+			" Request Entries elsewhere.\n", __FUNCTION__);
+		return;
+	}
+
+	/* unlink Process Entry from Process List and free. */
+	list_del_init(&(p_entry->node));
+	kfree(p_entry);
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : Process Entry is deleted.\n", __FUNCTION__);
+
+#ifdef CONFIG_TCPCP_DEBUG
+	/* @@@ print Process List without lock. (for DEBUG) @@@ */
+	__print_list();
+#endif
+
+	/* end. */
+	DPRINTK("TCPCP : %s : end.\n", __FUNCTION__);
+	return;
+}
+
+/* ----- Request Entry ----- */
+
+/**
+ * __tcpcp_add_req_entry - allocate and add Request Entry.
+ *
+ * [Args]
+ *   (IN) *sk      : TCP socket
+ *   (IN) flag     : TCPCP operation flag
+ *   (IN) *p_entry : Process Entry
+ *
+ * [Return]
+ *   normal : new Request Entry
+ *   NULL   : -ENOMEM
+ **/
+static struct tcpcp_req_entry *__tcpcp_add_req_entry(struct sock *sk,
+			unsigned char flag, struct tcpcp_proc_entry *p_entry)
+{
+	struct tcpcp_req_entry *r_entry;
+	unsigned int r_entry_size;
+
+	/* plug-in. */
+	plugin_dummy();
+
+	/* start. */
+	DPRINTK("TCPCP : %s : start. sk=0x%p, flag=%u, p_entry=0x%p\n",
+		__FUNCTION__, sk, flag, p_entry);
+
+	/* allocate Request Entry. */
+	r_entry_size = sizeof(struct tcpcp_req_entry);
+	r_entry = kmalloc(r_entry_size, GFP_ATOMIC);
+	if (r_entry == NULL) {
+		DPRINTK("TCPCP : %s : [Error] can't allocate Request Entry.\n",
+			__FUNCTION__);
+
+		/* delete Process Entry. */
+		tcpcp_del_proc_entry(p_entry);
+		return NULL;
+	}
+
+	/* initialize Request Entry. */
+	memset(r_entry, 0, r_entry_size);
+	r_entry->sk = sk;
+	r_entry->flag = flag;
+	r_entry->pid = current->pid;
+	r_entry->s_entry = NULL;
+	r_entry->f_entry = NULL;
+	INIT_LIST_HEAD(&(r_entry->timer_node));
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : r_entry->sk=0x%p\n",
+		__FUNCTION__, r_entry->sk);
+	DPRINTK("TCPCP : %s : r_entry->flag=%d\n",
+		__FUNCTION__, r_entry->flag);
+	DPRINTK("TCPCP : %s : r_entry->pid=%d\n",
+		__FUNCTION__, r_entry->pid);
+	DPRINTK("TCPCP : %s : r_entry->s_entry=0x%p\n",
+		__FUNCTION__, r_entry->s_entry);
+	DPRINTK("TCPCP : %s : r_entry->f_entry=0x%p\n",
+		__FUNCTION__, r_entry->f_entry);
+
+	/* set parent Process Entry and lint Request Entry to Request List. */
+	r_entry->p_entry = p_entry;
+	list_add_tail(&(r_entry->node), &(p_entry->r_list_head));
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : r_entry->p_entry=0x%p\n",
+		__FUNCTION__, r_entry->p_entry);
+
+	/* end. */
+	DPRINTK("TCPCP : %s : end. r_entry=0x%p\n", __FUNCTION__, r_entry);
+	return r_entry;
+}
+
+/**
+ * __tcpcp_del_req_entry
+ *   - delete and free Request Entry with common entries.
+ *     (and delete and free parent Process Entry, if it doesn't have Request
+ *      Entry.)
+ *
+ * [Args]
+ *   (IN) *r_entry : now Request Entry
+ **/
+static void __tcpcp_del_req_entry(struct tcpcp_req_entry *r_entry)
+{
+	struct tcpcp_proc_entry *p_entry;
+
+	/* plug-in. */
+	plugin_dummy();
+
+	/* start. */
+	DPRINTK("TCPCP : %s : start.\n", __FUNCTION__);
+
+	/* check that Request Entry is NULL. */
+	if (r_entry == NULL) {
+		DPRINTK("TCPCP : %s : Request entry is NULL.\n", __FUNCTION__);
+		return;
+	}
+
+	/* get parent Process Entry. */
+	p_entry = r_entry->p_entry;
+
+	/* delete TCP-SIs Entry and FDR Info. Entry. */
+	tcpcp_del_all_com_entry(&(r_entry->s_entry));
+	tcpcp_del_all_com_entry(&(r_entry->f_entry));
+
+	/* unlink Request Entry from Timeout List. */
+	list_del_init(&(r_entry->timer_node));
+
+	/* unlink Request Entry from Request List and free. */
+	list_del_init(&(r_entry->node));
+	kfree(r_entry);
+
+	/* delete Process Entry. */
+	tcpcp_del_proc_entry(p_entry);
+
+	/* end. */
+	DPRINTK("TCPCP : %s : end.\n", __FUNCTION__);
+	return;
+}
+
+/* ----- check conflict ----- */
+
+/**
+ * tcpcp_check_conflict_one_all
+ *   - search Request List and check conflict. (only "ONE/ALL")
+ *
+ * [Args]
+ *   (IN) *sk     : TCP socket
+ *   (IN) flag    : TCPCP operation flag
+ *   (IN) p_entry : Process Entry
+ *
+ * [Return]
+ *   0     : OK. (not conflict)
+ *  -EBUSY : NG. (conflict)
+ **/
+static int tcpcp_check_conflict_one_all(struct sock *sk, unsigned char flag,
+					struct tcpcp_proc_entry *p_entry)
+{
+	struct tcpcp_req_entry *r_entry;
+	unsigned char cflag;
+
+	/* plug-in. */
+	plugin_dummy();
+
+	/* start. */
+	DPRINTK("TCPCP : %s : start. sk=0x%p, flag=%u, p_entry=0x%p\n",
+		__FUNCTION__, sk, flag, p_entry);
+
+	/* search Request List. */
+	list_for_each_entry(r_entry, &(p_entry->r_list_head), node) {
+		/* lookup Request Entry what has same socket. */
+		if (r_entry->sk == sk) {
+			DPRINTK("TCPCP : %s : [Error] conflict has occurred"
+				" between batch processing and individual"
+				" processing.\n", __FUNCTION__);
+			return -EBUSY;
+		}
+		/* The bit which shows ALL is set as 0. */
+		cflag = r_entry->flag & ~TCPCP_FLAG_ALL;
+
+		/* check conflict. */
+		switch (cflag) {
+		case TCPCP_FLAG_MAKE_SI:
+			if ((flag & TCPCP_FLAG_CLOSE)
+			    || (flag & TCPCP_FLAG_SET_SI)) {
+				DPRINTK("TCPCP : %s : [Error] conflict has"
+				 	" occurred, because TCPCP close"
+					" processing or TCPCP set SI"
+					" processing are under operation.\n",
+					__FUNCTION__);
+				return -EBUSY;
+			}
+			break;
+
+		case TCPCP_FLAG_STOP:
+		case TCPCP_FLAG_START:
+			if (flag & TCPCP_FLAG_MAKE_SI)
+				break;
+			DPRINTK("TCPCP : %s : [Error] conflict has occurred,"
+				" because TCPCP stop processing or TCPCP start"
+				" processing are under operation.\n",
+				__FUNCTION__);
+			return -EBUSY;
+
+		case TCPCP_FLAG_CLOSE:
+		case TCPCP_FLAG_SET_SI:
+		default:
+			DPRINTK("TCPCP : %s : [Error] conflict has occurred,"
+				" because TCPCP close processing or TCPCP"
+				" set-SIs processing are under operation.\n",
+				__FUNCTION__);
+			return -EBUSY;
+		}
+	}
+
+	/* end. */
+	DPRINTK("TCPCP : %s : end.\n", __FUNCTION__);
+	return 0;
+}
+
+/**
+ * tcpcp_check_conflict_one_one
+ *   - search Request List and check conflict (only "ONE/ONE").
+ *
+ * [Args]
+ *   (IN) *sk      : TCP socket
+ *   (IN) *p_entry : Process Entry
+ *
+ * [Return]
+ *   0     : OK. (not conflict)
+ *  -EBUSY : NG. (conflict)
+ **/
+static int tcpcp_check_conflict_one_one(struct sock *sk,
+					struct tcpcp_proc_entry *p_entry)
+{
+	struct tcpcp_req_entry *r_entry;
+
+	/* plug-in. */
+	plugin_dummy();
+
+	/* start. */
+	DPRINTK("TCPCP : %s : start. sk=0x%p, p_entry=0x%p\n",
+		__FUNCTION__, sk, p_entry);
+
+	/* search Request Entry. */
+	list_for_each_entry(r_entry, &(p_entry->r_list_head), node) {
+		/* lookup Request Entry what has same socket. */
+		if (r_entry->sk == sk) {
+			DPRINTK("TCPCP : %s : [Error] conflict has occurred"
+				" in individual processings.\n", __FUNCTION__);
+			return -EBUSY;
+		}
+	}
+
+	/* end. */
+	DPRINTK("TCPCP : %s : end.\n", __FUNCTION__);
+	return 0;
+}
+
+/**
+ * tcpcp_check_conflict - check conflict and add Process Entry.
+ *
+ * [Args]
+ *   (IN) *sk        : TCP socket
+ *   (IN) flag       : TCPCP operation flag
+ *   (OUT) **p_entry : Process Entry
+ *
+ * [Return]
+ *   0               : OK.
+ *  -EBUSY           : NG. (conflict)
+ *  -ENOMEM          : NG. (no memory)
+ **/
+static int tcpcp_check_conflict(struct sock *sk, unsigned char flag,
+				struct tcpcp_proc_entry **p_entry)
+{
+	unsigned char p_flag;
+	int error;
+
+	/* plug-in. */
+	plugin_dummy();
+
+	/* start. */
+	DPRINTK("TCPCP : %s : start. sk=0x%p, flag=%u\n",
+		__FUNCTION__, sk, flag);
+
+	/* search Process List. */
+	list_for_each_entry((*p_entry), &(proc_list.head), node) {
+		/* lookup Process Entry what has same Thread Group ID. */
+		if ((*p_entry)->tgid == current->tgid) {
+			DPRINTK("TCPCP : %s : lookup Process Entry.\n",
+				__FUNCTION__);
+			goto search_req_entry;
+		}
+	}
+	DPRINTK("TCPCP : %s : can't lookup Process Entry.\n", __FUNCTION__);
+
+	/* add Process Entry. */
+	(*p_entry) = tcpcp_add_proc_entry(sk, flag);
+	if ((*p_entry) == NULL) {
+		DPRINTK("TCPCP : %s : [Error] can't add Process Entry.\n",
+			__FUNCTION__);
+		return -ENOMEM;
+	}
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : Process Entry is added.\n", __FUNCTION__);
+
+#ifdef CONFIG_TCPCP_DEBUG
+	/* @@@ print Process List without lock. (for DEBUG) @@@ */
+	__print_list();
+#endif
+
+	/* end. */
+	DPRINTK("TCPCP : %s : end.\n", __FUNCTION__);
+	return 0;
+
+search_req_entry:
+	/* check conflict. */
+	p_flag = (*p_entry)->flag;
+
+	if ((p_flag & TCPCP_FLAG_ALL) && (flag & TCPCP_FLAG_ALL)) {
+		/* conflict each batch processing. */
+		DPRINTK("TCPCP : %s : [Error] conflict has occurred in batch"
+			" processing.\n", __FUNCTION__);
+		error = -EBUSY;
+
+	} else if ((p_flag & TCPCP_FLAG_ALL) || (flag & TCPCP_FLAG_ALL))
+		/* conflict batch processing and individual processing. */
+		error = tcpcp_check_conflict_one_all(sk, flag, (*p_entry));
+
+	else
+		/* conflict each individual processing. */
+		error = tcpcp_check_conflict_one_one(sk, (*p_entry));
+
+	/* end. */
+	DPRINTK("TCPCP : %s : end. error=%d\n", __FUNCTION__, error);
+	return error;
+}
+
+/**
+ * tcpcp_lookup_req_entry - lookup Request Entry.
+ *
+ * [Args]
+ *   (IN) *sk : TCP socket
+ *
+ * [Return]
+ *   normal : Request Entry
+ *   NULL   : not lookup
+ **/
+static struct tcpcp_req_entry *tcpcp_lookup_req_entry(struct sock *sk)
+{
+	struct tcpcp_proc_entry *p_entry = NULL;
+	struct tcpcp_req_entry *r_entry = NULL;
+
+	/* plug-in. */
+	plugin_dummy();
+
+	/* start. */
+	DPRINTK("TCPCP : %s : start. sk=0x%p\n", __FUNCTION__, sk);
+
+	/* search Process List. */
+	list_for_each_entry(p_entry, &(proc_list.head), node) {
+		/* lookup Process Entry what has same Thread Group ID. */
+		if (p_entry->tgid == current->tgid)
+			goto check_sk;
+	}
+
+	DPRINTK("TCPCP : %s : [Error] there is no information to get."
+		" (no Process Entry)\n", __FUNCTION__);
+	return NULL;
+
+check_sk:
+	/* search Request List. */
+	DPRINTK("TCPCP : %s : search Request List.\n", __FUNCTION__);
+	list_for_each_entry(r_entry, &(p_entry->r_list_head), node) {
+		/* lookup Request Entry what has same socket. */
+		if (r_entry->sk == sk)
+			goto check_pid;
+	}
+
+	DPRINTK("TCPCP : %s : [Error] there is no information to get."
+		" (no Request Entry)\n", __FUNCTION__);
+	return NULL;
+
+check_pid:
+	DPRINTK("TCPCP : %s : check process ID.\n", __FUNCTION__);
+	if (r_entry->pid != current->pid) {
+		DPRINTK("TCPCP : %s : [Error] there is no information to get."
+			" (different PID)\n", __FUNCTION__);
+		return NULL;
+	}
+
+	/* end. */
+	DPRINTK("TCPCP : %s : end. r_entry=0x%p\n", __FUNCTION__, r_entry);
+	return r_entry;
+}
+
+/* ----- Timeout-watcher ----- */
+
+/**
+ * tcpcp_watch_timeout - watch whether the time-out generation.
+ **/
+static void tcpcp_watch_timeout(unsigned long arg)
+{
+	struct tcpcp_req_entry *r_entry, *next_r_entry;
+	__u32 cur_time = tcp_time_stamp;
+
+	/* plug-in. */
+	plugin_dummy();
+
+	/* start. */
+	DPRINTK("TCPCP : %s : start.\n", __FUNCTION__);
+
+	/* lock Process List (and Timeout List). */
+	if (!write_trylock(&(proc_list.lock))) {
+		DPRINTK("TCPCP : %s : failed lock for Process List.\n",
+			__FUNCTION__);
+		mod_timer(&tcpcp_timer,
+			  tcp_time_stamp + TCPCP_RETRY_WATCH_INTERVAL);
+		return;
+	}
+	DPRINTK("TCPCP : %s : Process List is locked.\n", __FUNCTION__);
+
+#ifdef CONFIG_TCPCP_DEBUG
+	/* @@@ print Process List without lock. (for DEBUG) @@@ */
+	__print_list();
+#endif
+
+	/* search Timeout Request List. */
+	list_for_each_entry_safe(r_entry, next_r_entry, &(timeout_list.head),
+				 timer_node) {
+		/* @@@ for DEBUG @@@ */
+		DPRINTK("TCPCP : %s : r_entry->timeout=%d\n",
+			__FUNCTION__, r_entry->timeout);
+
+		if (r_entry->timeout > cur_time) {
+			DPRINTK("TCPCP : %s : search is finished.\n",
+				__FUNCTION__);
+			break;
+		}
+
+		/* delete Request Entry with common entries. */
+		__tcpcp_del_req_entry(r_entry);
+		/* @@@ for DEBUG @@@ */
+		DPRINTK("TCPCP : %s : delete Request Entry with common"
+			" entries.\n", __FUNCTION__);
+	}
+
+#ifdef CONFIG_TCPCP_DEBUG
+	/* @@@ print Process List without lock. (for DEBUG) @@@ */
+	__print_list();
+#endif
+
+	if ((list_empty(&(timeout_list.head)) == 0)
+	    && (timer_pending(&tcpcp_timer) == 0)) {
+		/* regist Timeout-watcher. */
+		tcpcp_timer.expires = tcp_time_stamp + TCPCP_WATCH_INTERVAL;
+		add_timer(&tcpcp_timer);
+		DPRINTK("TCPCP : %s : Timeout watcher is registered.\n",
+			__FUNCTION__);
+	}
+
+	/* release Process List (and Timeout List). */
+	write_unlock(&(proc_list.lock));
+	DPRINTK("TCPCP : %s : Process List is unlocked.\n", __FUNCTION__);
+
+	/* end. */
+	DPRINTK("TCPCP : %s : end.\n", __FUNCTION__);
+	return;
+}
+
+/**
+ * tcpcp_regist_timer - regist timer.
+ **/
+static void tcpcp_regist_timer(void)
+{
+	/* plug-in. */
+	plugin_dummy();
+
+	/* start. */
+	DPRINTK("TCPCP : %s : start.\n", __FUNCTION__);
+
+	/* regist Timeout-watcher. */
+	tcpcp_timer.expires = tcp_time_stamp + TCPCP_WATCH_INTERVAL;
+	add_timer(&tcpcp_timer);
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : tcpcp_timer.expires=%lu\n",
+		__FUNCTION__, tcpcp_timer.expires);
+
+	/* end. */
+	DPRINTK("TCPCP : %s : end.\n", __FUNCTION__);
+	return;
+}
+
+
+/* ----- Entry management (API) -------------------------------------------- */
+ 
+/* ----- common entry ----- */
+
+/**
+ * tcpcp_get_w_ptr : get write-point of common entry.
+ *
+ * [Args]
+ *   (IN) flag         : "ONE" / "ALL" (to add common entry)
+ *   (IN) new_data_len : length of new data
+ *   (IN/OUT) **entry  : now common entry
+ *
+ * [Return]
+ *   normal : write-point
+ *   NULL   : -ENOMEM
+ **/
+static char *tcpcp_get_w_ptr(unsigned char flag, unsigned int new_data_len,
+			     struct tcpcp_com_entry **entry)
+{
+	char *w_ptr;
+	int error;
+
+	/* plug-in. */
+	plugin_dummy();
+
+	/* start. */
+	DPRINTK("TCPCP : %s : start. flag=%d, new_data_len=%u\n", 
+		__FUNCTION__, flag, new_data_len);
+
+	/* check 1st entry. */
+	/* check free of common entry. */
+	if (((*entry) == NULL)
+	    || (*entry)->max_data_len - (*entry)->data_len < new_data_len) {
+		/* add and change common entry. */
+		error = tcpcp_add_com_entry(flag, entry);
+		if (error != 0) {
+			DPRINTK("TCPCP : %s : [Error] can't add common entry."
+				" error=%d\n", __FUNCTION__, error);
+			return NULL;
+		}
+		DPRINTK("TCPCP : %s : common entry is added.\n", __FUNCTION__);
+	}
+
+	/* get write-point. */
+	w_ptr = (*entry)->data + (*entry)->data_len;
+	(*entry)->data_len += new_data_len;
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : (*entry)->data_len=%u\n",
+		__FUNCTION__, (*entry)->data_len);
+
+	/* end. */
+	DPRINTK("TCPCP : %s : end. w_ptr=0x%p\n", __FUNCTION__, w_ptr);
+	return w_ptr;
+}
+
+/* ----- Request Entry ----- */
+
+/**
+ * tcpcp_add_req_entry - check conflict and add Request Entry.
+ *
+ * [Args]
+ *   (IN) *sk        : TCP socket
+ *   (IN) flag       : TCPCP operation flag
+ *   (OUT) **r_entry : Request Entry
+ *
+ * [Return]
+ *   0               : OK.
+ *  -EPFNOSUPPORT    : NG. (not support socket family)
+ *  -ESOCKTNOSUPPORT : NG. (not support socket type)
+ *  -EPROTONOSUPPORT : NG. (not support socket protocol)
+ *  -EBADFD          : NG. (bad state of TCP socket)
+ *  -EBUSY           : NG. (conflict)
+ *  -ENOMEM          : NG. (no memory)
+ **/
+static int tcpcp_add_req_entry(struct sock *sk, unsigned char flag,
+			       struct tcpcp_req_entry **r_entry)
+{
+	struct tcpcp_proc_entry *p_entry;
+	int error;
+
+	/* plug-in. */
+	plugin_dummy();
+
+	/* start. */
+	DPRINTK("TCPCP : %s : start. sk=0x%p, flag=%d\n",
+		__FUNCTION__, sk, flag);
+
+	(*r_entry) = NULL;
+
+	/* check type of socket. */
+	error = tcpcp_check_sk_type(sk);
+	if (error != 0) {
+		DPRINTK("TCPCP : %s : end. error=%d\n", __FUNCTION__, error);
+		return error;
+	}
+
+	if (!(flag & TCPCP_FLAG_ALL)) {
+		/* check state of TCP socket. (only "ONE") */
+		error = tcpcp_check_sk_state(sk, flag);
+		if (error != 0) {
+			/* only -EBADFD. */
+			DPRINTK("TCPCP : %s : end. error=%d\n",
+				__FUNCTION__, error);
+			return error;
+		}
+	}
+
+	/* lock Process List. */
+	write_lock(&(proc_list.lock));
+	DPRINTK("TCPCP : %s : Process List is locked.\n", __FUNCTION__);
+
+	/* check conflict and get Process Entry. */
+	error = tcpcp_check_conflict(sk, flag, &p_entry);
+	if (error != 0)
+		goto out;
+
+	/* add Request Entry. */
+	(*r_entry) = __tcpcp_add_req_entry(sk, flag, p_entry);
+	if ((*r_entry) == NULL)
+		error = -ENOMEM;
+
+out:
+	/* release Process List. */
+	write_unlock(&(proc_list.lock));
+	DPRINTK("TCPCP : %s : Process List is unlocked.\n", __FUNCTION__);
+
+	/* end. */
+	DPRINTK("TCPCP : %s : end. error=%d\n", __FUNCTION__, error);
+	return error;
+}
+
+/**
+ * tcpcp_del_req_entry
+ *   - delete and free Request Entry with common entries.
+ *     (and delete and free parent Process Entry, if it doesn't have Request
+ *      Entry.)
+ *
+ * [Args]
+ *   (IN) *r_entry : Request Entry
+ **/
+static void tcpcp_del_req_entry(struct tcpcp_req_entry *r_entry)
+{
+	/* plug-in. */
+	plugin_dummy();
+
+	/* start. */
+	DPRINTK("TCPCP : %s : start. r_entry=0x%p\n", __FUNCTION__, r_entry);
+
+	/* lock Process List. */
+	write_lock(&(proc_list.lock));
+	DPRINTK("TCPCP : %s : Process List is locked.\n", __FUNCTION__);
+
+	/* delete Request Entry. */
+	__tcpcp_del_req_entry(r_entry);
+
+	/* release Process List. */
+	write_unlock(&(proc_list.lock));
+	DPRINTK("TCPCP : %s : Process List is unlocked.\n", __FUNCTION__);
+
+	/* end. */
+	DPRINTK("TCPCP : %s : end.\n", __FUNCTION__);
+	return;
+}
+
+/**
+ * tcpcp_del_all_entry - delete and free all entry.
+ **/
+static void tcpcp_del_all_entry(void)
+{
+	struct tcpcp_proc_entry *p_entry, *next_p_entry;
+	struct tcpcp_req_entry *r_entry, *next_r_entry;
+
+	/* plug-in. */
+	plugin_dummy();
+
+	/* start. */
+	DPRINTK("TCPCP : %s : start.\n", __FUNCTION__);
+
+	/* lock Process List. */
+	write_lock(&(proc_list.lock));
+	DPRINTK("TCPCP : %s : Process List is locked.\n", __FUNCTION__);
+
+#ifdef CONFIG_TCPCP_DEBUG
+	/* @@@ print Process List without lock. (for DEBUG) @@@ */
+	__print_list();
+#endif
+
+	/* search Process List. */
+	list_for_each_entry_safe(p_entry, next_p_entry, &(proc_list.head),
+				 node) {		
+		/* @@@ for DEBUG @@@ */
+		DPRINTK("TCPCP : %s : Process List Loop.\n", __FUNCTION__);
+
+		/* search Reqest List. */
+		list_for_each_entry_safe(r_entry, next_r_entry,
+		    &(p_entry->r_list_head), node) {
+			/* @@@ for DEBUG @@@ */
+			DPRINTK("TCPCP : %s : Request List Loop.\n",
+				__FUNCTION__);
+
+			/* delete Request Entry with common entries. */
+			__tcpcp_del_req_entry(r_entry);
+		}
+	}
+
+#ifdef CONFIG_TCPCP_DEBUG
+	/* @@@ print Process List without lock. (for DEBUG) @@@ */
+	__print_list();
+#endif
+
+	/* release Process List. */
+	write_unlock(&(proc_list.lock));
+	DPRINTK("TCPCP : %s : Process List is unlocked.\n", __FUNCTION__);
+
+	/* end. */
+	DPRINTK("TCPCP : %s : end.\n", __FUNCTION__);
+	return;
+}
+
+/* ----- Timeout-watcher ----- */
+
+/**
+ * tcpcp_quick_timeout
+ *   - unlink Request Entry from Request List, and re-link to Timeout List.
+ *
+ * [Args]
+ *   (IN) *sk : TCP socket
+ **/
+static void tcpcp_quick_timeout(struct sock *sk)
+{
+	struct tcpcp_proc_entry *p_entry;
+	struct tcpcp_req_entry *r_entry;
+
+	/* plug-in. */
+	plugin_dummy();
+
+	/* start. */
+	DPRINTK("TCPCP : %s : start. sk=0x%p\n", __FUNCTION__, sk);
+
+	/* lock Process List (and Timeout List). */
+	write_lock(&(proc_list.lock));
+	DPRINTK("TCPCP : %s : Process List is locked.\n", __FUNCTION__);
+
+#ifdef CONFIG_TCPCP_DEBUG
+	/* @@@ print Process List without lock. (for DEBUG) @@@ */
+	__print_list();
+#endif
+
+	/* search Process List. */
+	list_for_each_entry(p_entry, &(proc_list.head), node) {
+		/* @@@ for DEBUG @@@ */
+		DPRINTK("TCPCP : %s : Process List Loop.\n", __FUNCTION__);
+
+		/* lookup Process Entry what has same Thread Group ID. */
+		if (p_entry->tgid == current->tgid)
+			goto check_sk;
+	}
+
+	/* not lookup ! */
+	DPRINTK("TCPCP : %s : there is no process entry to lookup.\n",
+		__FUNCTION__);
+	goto out;
+
+check_sk:
+	/* search Request List. */
+	DPRINTK("TCPCP : %s : search Request List.\n", __FUNCTION__);
+
+	list_for_each_entry(r_entry, &(p_entry->r_list_head), node) {
+		/* @@@ for DEBUG @@@ */
+		DPRINTK("TCPCP : %s : Request List Loop.\n", __FUNCTION__);
+
+		/* lookup Request Entry what has same socket. */
+		if (r_entry->sk == sk)
+			/* lookup !*/
+			goto quick_timeout;
+	}
+
+	/* not lookup ! */
+	goto out;
+
+quick_timeout:
+	DPRINTK("TCPCP : %s : looked up Request Entry what" \
+		"  has same socket.\n", __FUNCTION__);
+
+	/* unlink Request Entry from Timeout List. */
+	list_del_init(&(r_entry->timer_node));
+
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : r_entry->timeout=%u\n",
+		__FUNCTION__, r_entry->timeout);
+
+	r_entry->timeout = tcp_time_stamp;
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : r_entry->timeout=%u\n",
+		__FUNCTION__, r_entry->timeout);
+
+	/* unlink Request Entry from Request List. */
+	list_del_init(&(r_entry->node));
+
+#ifdef CONFIG_TCPCP_DEBUG
+	/* @@@ print Process List without lock. (for DEBUG) @@@ */
+	__print_list();
+#endif
+
+	/* delete Process Entry. */
+	tcpcp_del_proc_entry(r_entry->p_entry);
+
+	r_entry->p_entry = NULL;
+
+#ifdef CONFIG_TCPCP_DEBUG
+	/* @@@ print Process List without lock. (for DEBUG) @@@ */
+	__print_list();
+#endif
+
+	/* link Request Entry to Timeout List. */
+	list_add(&(r_entry->timer_node), &(timeout_list.head));
+
+out:
+#ifdef CONFIG_TCPCP_DEBUG
+	/* @@@ print Process List without lock. (for DEBUG) @@@ */
+	__print_list();
+#endif
+
+	/* release Process List (and Timeout List). */
+	write_unlock(&(proc_list.lock));
+	DPRINTK("TCPCP : %s : Process List is unlocked.\n", __FUNCTION__);
+
+	/* end. */
+	DPRINTK("TCPCP : %s : end.\n", __FUNCTION__);
+	return;
+}
+
+/**
+ * tcpcp_set_timeout - link Request Entry to Timeout List.
+ *
+ * [Args]
+ *   (IN) *r_entry : Request Entry
+ **/
+static void tcpcp_set_timeout(struct tcpcp_req_entry *r_entry)
+{
+	/* plug-in. */
+	plugin_dummy();
+
+	/* start. */
+	DPRINTK("TCPCP : %s : start. r_entry=0x%p\n", __FUNCTION__, r_entry);
+
+	r_entry->timeout = tcp_time_stamp + TCPCP_REQ_ENTRY_TIMEOUT;
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : tcp_time_stamp  =%u\n",
+		__FUNCTION__, tcp_time_stamp);
+	DPRINTK("TCPCP : %s : r_entry->timeout=%u\n",
+		__FUNCTION__, r_entry->timeout);
+	DPRINTK("TCPCP : %s : r_emtry->timeout-tcp_time_stamp=%u\n",
+		__FUNCTION__, r_entry->timeout - tcp_time_stamp);
+
+	/* lock Process List (and Timeout List). */
+	write_lock(&(proc_list.lock));
+	DPRINTK("TCPCP : %s : Process List is locked.\n", __FUNCTION__);
+
+	if ((list_empty(&(timeout_list.head)) != 0)
+	    && (timer_pending(&tcpcp_timer) == 0)) {
+		/* regist Timeout-watcher. */
+		tcpcp_regist_timer();
+		/* @@@ for DEBUG @@@ */
+		DPRINTK("TCPCP : %s : Wake up Timeout-watcher.\n",
+			__FUNCTION__);
+	}
+
+	/* link Request Entry to Timeout List. */
+	list_add_tail(&(r_entry->timer_node), &(timeout_list.head));
+
+	/* release Process List (and Timeout List). */
+	write_unlock(&(proc_list.lock));
+	DPRINTK("TCPCP : %s : Process List is unlocked.\n", __FUNCTION__);
+
+	/* end. */
+	DPRINTK("TCPCP : %s : end.\n", __FUNCTION__);
+	return;
+}
+
+/**
+ * tcpcp_reset_timeout - lookup Request Entry and unlink from Timeout List.
+ *
+ * [Args]
+ *   (IN) *sk : socket
+ *
+ * [Return]
+ *   normal : Request Entry
+ *   NULL   : not lookup
+ **/
+static struct tcpcp_req_entry *tcpcp_reset_timeout(struct sock *sk)
+{
+	struct tcpcp_req_entry *r_entry;
+
+	/* plug-in. */
+	plugin_dummy();
+
+	/* start. */
+	DPRINTK("TCPCP : %s : start. sk=0x%p\n", __FUNCTION__, sk);
+
+	/* lock Process List (and Timeout List). */
+	write_lock(&(proc_list.lock));
+	DPRINTK("TCPCP : %s : Process List is locked.\n", __FUNCTION__);
+
+	/* lookup Request Entry. */
+	r_entry = tcpcp_lookup_req_entry(sk);
+	if (r_entry == NULL) {
+		DPRINTK("TCPCP : %s : Not lookup request entry.\n",
+			__FUNCTION__);
+
+		goto out;
+	}
+
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : lookup! r_entry=0x%p\n", __FUNCTION__, r_entry);
+
+	/* unlink Request Entry from Timeout List. */
+	list_del_init(&(r_entry->timer_node));
+
+out:	
+	/* release Process List (and Timeout List). */
+	write_unlock(&(proc_list.lock));
+	DPRINTK("TCPCP : %s : Process List is unlocked.\n", __FUNCTION__);
+
+	/* end. */
+	DPRINTK("TCPCP : %s : end. r_entry=0x%p\n", __FUNCTION__, r_entry);
+	return r_entry;
+}
+
+
+/* ----- make FD Result (FDR) Information ---------------------------------- */
+
+/**
+ * tcpcp_make_res - make FDR Info. (only "ALL")
+ *
+ * Caller must be "ALL".
+ * 
+ * [Args]
+ *   (IN) fd                 : FD of TCP socket
+ *   (IN) ret                : result
+ *   (IN/OUT) **fdr_entry    : FDR Info. Entry
+ *
+ * [Return]
+ *   0      : OK.
+ *  -ENOMEM : NG.
+ **/
+static int tcpcp_make_res(unsigned int fd, int ret,
+			  struct tcpcp_com_entry **fdr_entry)
+{
+	struct fdr *fdrs;
+	unsigned int fdr_len;
+	char *w_ptr;
+
+	/* plug-in. */
+	plugin_dummy();
+
+	/* start. */
+	DPRINTK("TCPCP : %s : start. fd=%d, ret=%d\n", __FUNCTION__, fd, ret);
+
+	/* get write-point of FDR Info. Entry. */
+	fdr_len = sizeof(struct fdr);
+	w_ptr = tcpcp_get_w_ptr(TCPCP_FLAG_ALL, fdr_len, fdr_entry);
+	if (w_ptr == NULL)
+		return -ENOMEM;
+
+	/* make FDR Info. */
+	fdrs = (struct fdr *)w_ptr;
+	fdrs->fd = fd;
+	fdrs->result = ret;
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : fdrs->fd=%d\n", __FUNCTION__, fdrs->fd);
+	DPRINTK("TCPCP : %s : fdrs->result=%d\n", __FUNCTION__, fdrs->result);
+
+	/* end. */
+	DPRINTK("TCPCP : %s : end.\n", __FUNCTION__);
+	return 0;
+}
+
+
+/* ----- make TCP Socket Informations (TCP-SIs) ---------------------------- */
+
+/**
+ * tcpcp_make_si_skb - make TCP-SI packet info.
+ *
+ * This function is based on TCPCP-9:put_buffer().
+ * 
+ * [Args]
+ *   (IN) type     : "write_queue" / "receive_queue"
+ *   (IN) *skb     : socket buffer (linerized)
+ *   (IN) data_len : length of packet.
+ *   (IN) *si_skb  : TCP-SIs Entry
+ **/
+static void tcpcp_make_si_skb(uint8_t type, struct sk_buff *skb,
+			      unsigned int data_len,
+			      struct tcpcp_si_skb *si_skb)
+{
+	/* plug-in. */
+	plugin_dummy();
+
+	/* start. */
+	DPRINTK("TCPCP : %s : start. type=%u, skb=0x%p, data_len=%u,"
+		" si_skb=0x%p\n", __FUNCTION__, type, skb, data_len, si_skb);
+
+	/* set packet info. */
+	si_skb->type = type;
+	si_skb->length = htons(data_len);
+	si_skb->flags = TCP_SKB_CB(skb)->flags;
+	si_skb->sacked = TCP_SKB_CB(skb)->sacked;
+	si_skb->tso_segs = htons(skb_shinfo(skb)->tso_segs);
+	si_skb->tso_size = htons(skb_shinfo(skb)->tso_size);
+	si_skb->seq = htonl(TCP_SKB_CB(skb)->seq);
+	memcpy(si_skb->data, skb->tail - data_len, data_len);
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : si_skb->type=%u\n",
+		__FUNCTION__, si_skb->type);
+	DPRINTK("TCPCP : %s : si_skb->length=%u\n",
+		__FUNCTION__, si_skb->length);
+	DPRINTK("TCPCP : %s : si_skb->flags=%u\n",
+		__FUNCTION__, si_skb->flags);
+	DPRINTK("TCPCP : %s : si_skb->sacked=%u\n",
+		__FUNCTION__, si_skb->sacked);
+	DPRINTK("TCPCP : %s : si_skb->tso_segs=%u\n",
+		__FUNCTION__, si_skb->tso_segs);
+	DPRINTK("TCPCP : %s : si_skb->tso_size=%u\n",
+		__FUNCTION__, si_skb->tso_size);
+	DPRINTK("TCPCP : %s : si_skb->seq=%u\n",
+		__FUNCTION__, si_skb->seq);
+	DPRINTK("TCPCP : %s : si_skb->data=0x%p\n",
+		__FUNCTION__, si_skb->data);
+
+	/* end. */
+	DPRINTK("TCPCP : %s : end.\n", __FUNCTION__);
+	return;
+}
+
+/**
+ * tcpcp_copy_queue - copy write_queue / receive_queue.
+ *
+ * This function is based on TCPCP-9:copy_queue()
+ *
+ * [Args]
+ *   (IN) *queue         : write_queue / receive_queue of TCP socket
+ *   (IN) type           : type of queue (to make packet info.)
+ *   (IN) flag           : "ONE" / "ALL" (to add new TCP-SIs Entry) 
+ *   (IN/OUT) **si_entry : TCP-SIs Entry
+ *   (IN/OUT) *si_size   : total size of TCP-SI (include packet info.)
+ *
+ * [Return]
+ *   0      : OK.
+ *  -ENOMEM : NG. (Caller must delete all TCP-SIs Entry.)
+ **/
+static int tcpcp_copy_queue(struct sk_buff_head *queue, uint8_t type,
+		unsigned char flag, struct tcpcp_com_entry **si_entry,
+		unsigned int *si_size)
+{
+	struct tcpcp_si_skb *si_skb;
+	struct sk_buff *skb, *clone;
+	unsigned int data_len;
+	unsigned int si_skb_len;
+	char *w_ptr;
+	int error;
+
+#ifdef CONFIG_TCPCP_DEBUG
+	/* @@@ for printing counter of packets. (for DEBUG) @@@ */
+	int pkt_cnt = 0;
+#endif
+
+	/* plug-in. */
+	plugin_dummy();
+
+	/* start. */
+	DPRINTK("TCPCP : %s : start. queue=0x%p, type=%u, flag=%u\n",
+		__FUNCTION__, queue, type, flag);
+
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : queue->qlen=%u\n", __FUNCTION__, queue->qlen);
+
+	/* search socket buffer. */
+	skb_queue_walk(queue, skb) {
+
+#ifdef CONFIG_TCPCP_DEBUG
+		/* @@@ print counter of packets. (for DEBUG) @@@ */
+		pkt_cnt++;
+		DPRINTK("TCPCP : %s : packet count=%d\n",
+			__FUNCTION__, pkt_cnt);
+#endif
+
+		/* clone socket buffer. */
+		clone = skb_clone(skb, GFP_KERNEL);
+		if (!clone) {
+			DPRINTK("TCPCP : %s : [Error] can't clone skb.\n",
+				__FUNCTION__);
+			return -ENOMEM;
+		}
+
+		/* linearize socket buffer. */
+		error = skb_linearize(clone, GFP_KERNEL);
+		if (error != 0) {
+                        DPRINTK("TCPCP : %s : [Error] can't linearize skb."
+				" error=%d\n", __FUNCTION__, error);
+			kfree_skb(clone);
+			return -ENOMEM;
+		}
+
+		/* calculate data length of packet. */
+		data_len = TCP_SKB_CB(clone)->end_seq - TCP_SKB_CB(clone)->seq
+			- ((TCP_SKB_CB(clone)->flags & TCPCB_FLAG_SYN) ? 1 : 0)
+			- ((TCP_SKB_CB(clone)->flags & TCPCB_FLAG_FIN) ? 1 : 0);
+		/* @@@ for DEBUG @@@ */
+		DPRINTK("TCPCP : %s : data_len=%u\n", __FUNCTION__, data_len);
+		DPRINTK("TCPCP : %s : TCP_SKB_CB(clone)->seq    =%u\n",
+			__FUNCTION__, TCP_SKB_CB(clone)->seq);
+		DPRINTK("TCPCP : %s : TCP_SKB_CB(clone)->end_seq=%u\n",
+			__FUNCTION__, TCP_SKB_CB(clone)->end_seq);
+		DPRINTK("TCPCP : %s : TCP_SKB_CB(clone)->flags=%u\n",
+			__FUNCTION__, TCP_SKB_CB(clone)->flags);
+
+		/* calculate length of packet info. */
+		si_skb_len = sizeof(struct tcpcp_si_skb)
+			     + ((data_len + 3) & ~3);
+		/* @@@ for DEBUG @@@ */
+		DPRINTK("TCPCP : %s : si_skb_len=%u\n",
+			__FUNCTION__, si_skb_len);
+
+		/* get write-point of TCP-SIs Entry. */
+		w_ptr = tcpcp_get_w_ptr(flag, si_skb_len, si_entry);
+		if (w_ptr == NULL) {
+			DPRINTK("TCPCP : %s : [Error] can't get w_ptr.\n",
+				__FUNCTION__);
+			kfree_skb(clone);
+			return -ENOMEM;
+		}
+
+		/* make packet info. */
+		si_skb = (struct tcpcp_si_skb *)w_ptr;
+		(*si_size) += si_skb_len;
+		/* @@@ for DEBUG @@@ */
+		DPRINTK("TCPCP : %s : *si_size=%u\n", __FUNCTION__, *si_size);
+
+		tcpcp_make_si_skb(type, clone, data_len, si_skb);
+		/* @@@ for DEBUG @@@ */
+		DPRINTK("TCPCP : %s : clone->truesize=%u\n",
+			__FUNCTION__, clone->truesize);
+
+		kfree_skb(clone);
+	}
+
+	/* end. */
+	DPRINTK("TCPCP : %s : end.\n", __FUNCTION__);
+	return 0;
+}
+
+/**
+ * tcpcp_make_si_hdr - make TCP-SI header.
+ *
+ * This function is based on TCPCP-9:do_getici().
+ *
+ * [Args]
+ *   (IN) *sk     : TCP socket
+ *   (IN) si_size : total length of TCP-SI (include packet info.)
+ *   (IN) fd      : FD of TCP socket
+ *   (IN) *si_hdr : TCP-SIs Entry
+ **/
+static void tcpcp_make_si_hdr(struct sock *sk, unsigned int si_size,
+			      unsigned int fd, struct tcpcp_si_hdr *si_hdr)
+{
+	struct inet_sock *inet = inet_sk(sk);
+#if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)
+	struct ipv6_pinfo *inet6 = inet6_sk(sk);
+#endif
+	struct tcp_sock *tp = tcp_sk(sk);
+
+	/* plug-in. */
+	plugin_dummy();
+
+	/* start. */
+	DPRINTK("TCPCP : %s : start. sk=0x%p, si_size=%u, fd=%u, si_hdr=0x%p\n",
+		 __FUNCTION__, sk, si_size, fd, si_hdr);
+
+	/* get total length of TCP-SI and FD. */
+	si_hdr->si_length = htonl(si_size / 4);
+	si_hdr->fd = htonl(fd);
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : si_size          =%u\n",
+		__FUNCTION__, si_size);
+	DPRINTK("TCPCP : %s : si_hdr->si_length=%u\n",
+		__FUNCTION__, si_hdr->si_length);
+	DPRINTK("TCPCP : %s : fd        =%u\n", __FUNCTION__, fd);
+	DPRINTK("TCPCP : %s : si_hdr->fd=%u\n", __FUNCTION__, si_hdr->fd);
+
+	/* get globally unique TCP connection ID. */
+#if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)
+	if (sk->sk_family == PF_INET6) {
+		int addr_type = ipv6_addr_type(&inet6->daddr);
+		/* @@@ for DEBUG @@@ */
+		DPRINTK("TCPCP : %s : inet6->daddr=%04x:%04x:%04x:%04x:"
+			"%04x:%04x:%04x:%04x\n", __FUNCTION__,
+			ntohs(inet6->daddr.s6_addr16[0]),
+			ntohs(inet6->daddr.s6_addr16[1]),
+			ntohs(inet6->daddr.s6_addr16[2]),
+			ntohs(inet6->daddr.s6_addr16[3]),
+			ntohs(inet6->daddr.s6_addr16[4]),
+			ntohs(inet6->daddr.s6_addr16[5]),
+			ntohs(inet6->daddr.s6_addr16[6]),
+			ntohs(inet6->daddr.s6_addr16[7]));
+		DPRINTK("TCPCP : %s : addr_type=%u\n", __FUNCTION__, addr_type);
+
+		if (addr_type == IPV6_ADDR_MAPPED)
+			si_hdr->id.ip_version = 4;
+		else
+			si_hdr->id.ip_version = 6;
+	} else
+#endif
+		si_hdr->id.ip_version = 4;
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : si_hdr->id.ip_version=%u\n",
+		__FUNCTION__, si_hdr->id.ip_version);
+
+#if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)
+	if (si_hdr->id.ip_version == 6) {
+		ipv6_addr_copy(&(si_hdr->id.ip.v6.ip_src), &(inet6->saddr));
+		ipv6_addr_copy(&(si_hdr->id.ip.v6.ip_dst), &(inet6->daddr));
+		si_hdr->id.ip.v6.scope_id = htonl(sk->sk_bound_dev_if);
+		/* @@@ for DEBUG @@@ */
+		DPRINTK("TCPCP : %s : si_hdr->id.ip.v6.ip_src=%04x:%04x:%04x:"
+			"%04x:%04x:%04x:%04x:%04x\n", __FUNCTION__,
+			ntohs(si_hdr->id.ip.v6.ip_src.s6_addr16[0]),
+			ntohs(si_hdr->id.ip.v6.ip_src.s6_addr16[1]),
+			ntohs(si_hdr->id.ip.v6.ip_src.s6_addr16[2]),
+			ntohs(si_hdr->id.ip.v6.ip_src.s6_addr16[3]),
+			ntohs(si_hdr->id.ip.v6.ip_src.s6_addr16[4]),
+			ntohs(si_hdr->id.ip.v6.ip_src.s6_addr16[5]),
+			ntohs(si_hdr->id.ip.v6.ip_src.s6_addr16[6]),
+			ntohs(si_hdr->id.ip.v6.ip_src.s6_addr16[7]));
+		DPRINTK("TCPCP : %s : si_hdr->id.ip.v6.ip_dst=%04x:%04x:%04x:"
+			"%04x:%04x:%04x:%04x:%04x\n", __FUNCTION__,
+			ntohs(si_hdr->id.ip.v6.ip_dst.s6_addr16[0]),
+			ntohs(si_hdr->id.ip.v6.ip_dst.s6_addr16[1]),
+			ntohs(si_hdr->id.ip.v6.ip_dst.s6_addr16[2]),
+			ntohs(si_hdr->id.ip.v6.ip_dst.s6_addr16[3]),
+			ntohs(si_hdr->id.ip.v6.ip_dst.s6_addr16[4]),
+			ntohs(si_hdr->id.ip.v6.ip_dst.s6_addr16[5]),
+			ntohs(si_hdr->id.ip.v6.ip_dst.s6_addr16[6]),
+			ntohs(si_hdr->id.ip.v6.ip_dst.s6_addr16[7]));
+		DPRINTK("TCPCP : %s : sk->sk_bound_dev_if      =%u\n",
+			__FUNCTION__, sk->sk_bound_dev_if);
+		DPRINTK("TCPCP : %s : si_hdr->id.ip.v6.scope_id=%u\n",
+			__FUNCTION__, si_hdr->id.ip.v6.scope_id);
+	} else
+#endif
+	{
+		si_hdr->id.ip.v4.ip_src = inet->saddr;
+		si_hdr->id.ip.v4.ip_dst = inet->daddr;
+		/* @@@ for DEBUG @@@ */
+		DPRINTK("TCPCP : %s : si_hdr->id.ip.v4.ip_src=%u.%u.%u.%u\n",
+			__FUNCTION__,
+			((uint8_t*)&(si_hdr->id.ip.v4.ip_src))[0],
+			((uint8_t*)&(si_hdr->id.ip.v4.ip_src))[1],
+			((uint8_t*)&(si_hdr->id.ip.v4.ip_src))[2],
+			((uint8_t*)&(si_hdr->id.ip.v4.ip_src))[3]);
+		DPRINTK("TCPCP : %s : si_hdr->id.ip.v4.ip_dst=%u.%u.%u.%u\n",
+			__FUNCTION__,
+			((uint8_t*)&(si_hdr->id.ip.v4.ip_dst))[0],
+			((uint8_t*)&(si_hdr->id.ip.v4.ip_dst))[1],
+			((uint8_t*)&(si_hdr->id.ip.v4.ip_dst))[2],
+			((uint8_t*)&(si_hdr->id.ip.v4.ip_dst))[3]);
+	}
+	si_hdr->id.tcp_sport = inet->sport;
+	si_hdr->id.tcp_dport = inet->dport;
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : si_hdr->id.tcp_sport=%u\n",
+		__FUNCTION__, si_hdr->id.tcp_sport);
+	DPRINTK("TCPCP : %s : si_hdr->id.tcp_dport=%u\n",
+		__FUNCTION__, si_hdr->id.tcp_dport);
+
+	/* get fixed general data. */
+	if (tp->rx_opt.tstamp_ok)
+		si_hdr->fixgen.tcp_flags |= TCPI_OPT_TIMESTAMPS;
+	if (tp->rx_opt.sack_ok)
+		si_hdr->fixgen.tcp_flags |= TCPI_OPT_SACK;
+	if (tp->rx_opt.wscale_ok) {
+		si_hdr->fixgen.tcp_flags |= TCPI_OPT_WSCALE;
+		si_hdr->fixgen.snd_wscale = tp->rx_opt.snd_wscale;
+		si_hdr->fixgen.rcv_wscale = tp->rx_opt.rcv_wscale;
+	} else {
+		si_hdr->fixgen.snd_wscale = 0;
+		si_hdr->fixgen.rcv_wscale = 0;
+	}
+	if (tp->ecn_flags & TCP_ECN_OK)
+		si_hdr->fixgen.tcp_flags |= TCPI_OPT_ECN;
+	si_hdr->fixgen.snd_mss = htons(tp->advmss);
+	si_hdr->fixgen.rcv_mss = htons(tp->rx_opt.mss_clamp);
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : tp->tstamp_ok=%u\n",
+		__FUNCTION__, tp->tstamp_ok);
+	DPRINTK("TCPCP : %s : tp->sack_ok  =%u\n",
+		__FUNCTION__, tp->sack_ok);
+	DPRINTK("TCPCP : %s : tp->wscale_ok=%u\n",
+		__FUNCTION__, tp->wscale_ok);
+	DPRINTK("TCPCP : %s : tp->ecn_flags=%u\n",
+		__FUNCTION__, tp->ecn_flags);
+	DPRINTK("TCPCP : %s : si_hdr->fixgen.tcp_flags =%u\n",
+		__FUNCTION__, si_hdr->fixgen.tcp_flags);
+	DPRINTK("TCPCP : %s : si_hdr->fixgen.snd_wscale=%u\n",
+		__FUNCTION__, si_hdr->fixgen.snd_wscale);
+	DPRINTK("TCPCP : %s : si_hdr->fixgen.rcv_wscale=%u\n",
+		__FUNCTION__, si_hdr->fixgen.rcv_wscale);
+	DPRINTK("TCPCP : %s : tp->advmss            =%u\n",
+		__FUNCTION__, tp->advmss);
+	DPRINTK("TCPCP : %s : si_hdr->fixgen.snd_mss=%u\n",
+		__FUNCTION__, si_hdr->fixgen.snd_mss);
+	DPRINTK("TCPCP : %s : tp->mss_clamp         =%u\n",
+		__FUNCTION__, tp->mss_clamp);
+	DPRINTK("TCPCP : %s : si_hdr->fixgen.rcv_mss=%u\n",
+		__FUNCTION__, si_hdr->fixgen.rcv_mss);
+
+	/* get variable general data. */
+	si_hdr->vargen.state = sk->sk_state;
+	si_hdr->vargen.snd_nxt = htonl(tp->snd_nxt);
+	si_hdr->vargen.rcv_nxt = htonl(tp->rcv_nxt);
+	si_hdr->vargen.snd_wnd = htonl(tp->snd_wnd);
+	si_hdr->vargen.rcv_wnd = htonl(tcp_receive_window(tp));
+	si_hdr->vargen.ts_gen = htonl(tp_time_stamp(tp));
+	si_hdr->vargen.ts_recent = htonl(tp->rx_opt.saw_tstamp ? tp->rx_opt.ts_recent : 0);
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : si_hdr->vargen.state=%u\n",
+		__FUNCTION__, si_hdr->vargen.state);
+	DPRINTK("TCPCP : %s : si_hdr->vargen.snd_nxt=%u\n",
+		__FUNCTION__, si_hdr->vargen.snd_nxt);
+	DPRINTK("TCPCP : %s : si_hdr->vargen.rcv_nxt=%u\n",
+		__FUNCTION__, si_hdr->vargen.rcv_nxt);
+	DPRINTK("TCPCP : %s : tp->snd_wnd           =%lu\n",
+		__FUNCTION__, (unsigned long) tp->snd_wnd);
+	DPRINTK("TCPCP : %s : si_hdr->vargen.snd_wnd=%u\n",
+		__FUNCTION__, si_hdr->vargen.snd_wnd);
+	DPRINTK("TCPCP : %s : tp->rcv_wnd           =%lu\n",
+		__FUNCTION__, (unsigned long) tcp_receive_window(tp));
+	DPRINTK("TCPCP : %s : si_hdr->vargen.rcv_wnd=%u\n",
+		__FUNCTION__, si_hdr->vargen.rcv_wnd);
+	DPRINTK("TCPCP : %s : si_hdr->vargen.ts_gen   =%u\n",
+		__FUNCTION__, si_hdr->vargen.ts_gen);
+	DPRINTK("TCPCP : %s : si_hdr->vargen.ts_recent=%u\n",
+		__FUNCTION__, si_hdr->vargen.ts_recent);
+
+	/* get socket options. (socket) */
+	si_hdr->sockopt.sk.flags = 0;
+
+	if (sk->sk_reuse)
+		si_hdr->sockopt.sk.flags |= TCPCP_SIE_SOCK_REUSEADDR;
+	if (sock_flag(sk, SOCK_KEEPOPEN))
+		si_hdr->sockopt.sk.flags |= TCPCP_SIE_SOCK_KEEPOPEN;
+	if (sock_flag(sk, SOCK_LINGER)) {
+		si_hdr->sockopt.sk.flags |= TCPCP_SIE_SOCK_LINGER;
+		si_hdr->sockopt.sk.l_linger = htonl(sk->sk_lingertime / HZ);
+	}
+	si_hdr->sockopt.sk.userlocks = sk->sk_userlocks;
+	si_hdr->sockopt.sk.sndbuf = htonl(sk->sk_sndbuf / 2);
+	si_hdr->sockopt.sk.rcvbuf = htonl(sk->sk_rcvbuf / 2);
+	si_hdr->sockopt.sk.priority = htonl(sk->sk_priority);
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : sk->sk_reuse=%u\n", __FUNCTION__, sk->sk_reuse);
+	DPRINTK("TCPCP : %s : sk->sk_flags SOCK_KEEPALIVE=%u\n",
+		__FUNCTION__, !!sock_flag(sk, SOCK_KEEPOPEN));
+	DPRINTK("TCPCP : %s : sk->sk_flags SOCK_LINGER   =%u\n",
+		__FUNCTION__, !!sock_flag(sk, SOCK_LINGER));
+	DPRINTK("TCPCP : %s : sk->sk_priority=%lu\n",
+		__FUNCTION__, (unsigned long) sk->sk_priority);
+	DPRINTK("TCPCP : %s : sk->sk_lingertime/HZ=%lu\n",
+                __FUNCTION__, (unsigned long) sk->sk_lingertime / HZ);
+        DPRINTK("TCPCP : %s : sk->sk_userlocks=%u\n",
+		__FUNCTION__, sk->sk_userlocks);
+        DPRINTK("TCPCP : %s : sk->sk_sndbuf/2=%lu\n",
+		__FUNCTION__, (unsigned long) sk->sk_sndbuf / 2);
+	DPRINTK("TCPCP : %s : sk->sk_rcvbuf/2=%lu\n",
+		__FUNCTION__, (unsigned long) sk->sk_rcvbuf / 2);
+	DPRINTK("TCPCP : %s : sk->sk_priority=%lu\n",
+		__FUNCTION__, (unsigned long) sk->sk_priority);
+
+#if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)
+	if (si_hdr->id.ip_version == 6) {
+		/* get socket options. (IPv6) */
+		si_hdr->sockopt.ip.v6.flags = 0;
+		if (inet6->hop_limit == -1)
+			si_hdr->sockopt.ip.v6.flags
+				|= TCPCP_SIE_IPV6_DEFAULT_HOPLIMIT;
+		else
+			si_hdr->sockopt.ip.v6.hop_limit = inet6->hop_limit;
+		si_hdr->sockopt.ip.v6.pmtudisc = inet6->pmtudisc;
+		/* @@@ for DEBUG @@@ */
+		DPRINTK("TCPCP : %s : inet6->ttl=%d\n",
+			__FUNCTION__, inet6->hop_limit);
+                DPRINTK("TCPCP : %s : inet6->pmtudisc=%u\n",
+			__FUNCTION__, inet6->pmtudisc);
+	} else
+#endif
+	{
+		unsigned char optbuf[sizeof(struct ip_options) + 40];
+		struct ip_options *opt = (struct ip_options *)optbuf;
+
+		/* get socket options. (IPv4) */
+		si_hdr->sockopt.ip.v4.flags = 0;
+		if (inet->uc_ttl == -1)
+			si_hdr->sockopt.ip.v4.flags |= TCPCP_SIE_IP_DEFAULT_TTL;
+		else
+			si_hdr->sockopt.ip.v4.uc_ttl = inet->uc_ttl;
+		si_hdr->sockopt.ip.v4.pmtudisc = inet->pmtudisc;
+		si_hdr->sockopt.ip.v4.tos = inet->tos;
+		/* @@@ for DEBUG @@@ */
+		DPRINTK("TCPCP : %s : inet->ttl %d\n",
+			__FUNCTION__, inet->uc_ttl);
+		DPRINTK("TCPCP : %s : inet->pmtudisc %u\n",
+			__FUNCTION__, inet->pmtudisc);
+		DPRINTK("TCPCP : %s : inet->tos %d\n",
+			__FUNCTION__, inet->tos);
+
+		/* get socket options. (IPv4: IPv4 options) */
+		opt->optlen = 0;
+		if (inet->opt) {
+			memcpy(optbuf, inet->opt,
+			       sizeof(struct ip_options) + inet->opt->optlen);
+			/* @@@ for DEBUG @@@ */
+			DPRINTK("TCPCP : %s : inet->opt->optlen=%u\n",
+				__FUNCTION__, inet->opt->optlen);
+		}
+		/* @@@ for DEBUG @@@ */
+		DPRINTK("TCPCP : %s : opt->optlen=%u\n",
+			__FUNCTION__, opt->optlen);
+
+		si_hdr->sockopt.ip.v4.opt_len = opt->optlen;
+		if (opt->optlen) {
+			ip_options_undo(opt);
+			memcpy(&si_hdr->sockopt.ip.v4.opt_data, opt->__data,
+				opt->optlen);
+		}
+	}
+
+	/* get socket options. (TCP) */
+	si_hdr->sockopt.tcp.nonagle = tp->nonagle;
+	si_hdr->sockopt.tcp.keepcnt = tp->keepalive_probes;
+	si_hdr->sockopt.tcp.keepidle = htons(tp->keepalive_time / HZ);
+	si_hdr->sockopt.tcp.keepintvl = htons(tp->keepalive_intvl / HZ);
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : tp->nonagle=%u\n", __FUNCTION__, tp->nonagle);
+	DPRINTK("TCPCP : %s : tp->keepalive_probes=%u\n",
+		__FUNCTION__, tp->keepalive_probes);
+	DPRINTK("TCPCP : %s : tp->keepalive_time/HZ=%d\n",
+		__FUNCTION__, tp->keepalive_time / HZ);
+	DPRINTK("TCPCP : %s : tp->keepalive_intvl/HZ=%d\n",
+		__FUNCTION__, tp->keepalive_intvl / HZ);
+
+	/* end. */
+	DPRINTK("TCPCP : %s : end.\n", __FUNCTION__);
+	return;
+}
+
+/**
+ * do_make_si - make TCP-SI.
+ *
+ * This function is based on TCPCP-9:do_getici().
+ * Caller must lock socket.
+ * 
+ * [Args]
+ *   (IN) *sk            : TCP socket
+ *   (IN) fd             : FD of TCP socket (to make TCP-SI header)
+ *   (IN) flag           : "ONE" / "ALL" (to add new TCP-SIs Entry)
+ *   (IN/OUT) **si_entry : TCP-SIs Entry
+ *   (OUT) *si_size      : total length of TCP-SI (include pack.)
+ *
+ * [Return]
+ *   0      : OK.
+ *  -EBADFD : NG.
+ *  -ENOMEM : NG.
+ **/
+static int do_make_si(struct sock *sk, unsigned int fd, unsigned char flag,
+		      struct tcpcp_com_entry **si_entry,
+		      unsigned int *si_size)
+{
+	struct tcpcp_si_hdr *si_hdr;
+	unsigned int si_hdr_len; 
+	char *w_ptr;
+	int error;
+
+	/* plug-in. */
+	plugin_dummy();
+
+	/* start. */
+	DPRINTK("TCPCP : %s : start. sk=0x%p, fd=%u, flag=%u\n",
+		__FUNCTION__, sk, fd, flag);
+
+	/* check socket error. */
+	error = sock_error(sk);
+	if (error != 0) {
+		DPRINTK("TCPCP : %s : [Error] sock_error failure. error=%d\n",
+			__FUNCTION__, error);
+		return -EBADFD;
+	}
+	/* @@@ for DEBUG @@@ */
+        DPRINTK("TCPCP : %s : check socket error.\n", __FUNCTION__);
+
+	/* get write-point of TCP-SIs Entry. */
+	si_hdr_len = sizeof(struct tcpcp_si_hdr);
+	w_ptr = tcpcp_get_w_ptr(flag, si_hdr_len, si_entry);
+	if (w_ptr == NULL) {
+		DPRINTK("TCPCP : %s : [Error] can't get w_ptr.\n",
+			__FUNCTION__);
+		return -ENOMEM;
+	}
+
+	/* reserve TCP-SI header. */
+	si_hdr = (struct tcpcp_si_hdr *)w_ptr;
+	(*si_size) = si_hdr_len;
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : *si_size=%u\n", __FUNCTION__, *si_size);
+
+	/* copy write_queue. */
+	error = tcpcp_copy_queue(&sk->sk_write_queue, TCPCP_SIE_BUF_SND, flag,
+				 si_entry, si_size);
+	if (error != 0) {
+		DPRINTK("TCPCP : %s : [Error] can't copy write_queue."
+			" error=%d\n", __FUNCTION__, error);
+		return -ENOMEM;
+	}
+	/* @@@ for DEBUG @@@ */
+        DPRINTK("TCPCP : %s : copy write_queue.\n", __FUNCTION__);
+	DPRINTK("TCPCP : %s : sk->sk_sndbuf     =%u\n",
+		__FUNCTION__, sk->sk_sndbuf);
+	DPRINTK("TCPCP : %s : sk->sk_wmem_queued=%u\n",
+		__FUNCTION__, sk->sk_wmem_queued);
+
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : *si_size=%u\n", __FUNCTION__, *si_size);
+
+	/* copy receive_queue. */
+	error = tcpcp_copy_queue(&sk->sk_receive_queue, TCPCP_SIE_BUF_RCV, flag,
+				 si_entry, si_size);
+	if (error != 0) {
+		DPRINTK("TCPCP : %s : [Error] can't copy receive_queue."
+			" error=%d\n", __FUNCTION__, error);
+		return -ENOMEM;
+	}
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : copy receive_queue.\n", __FUNCTION__);
+
+	/* make TCP-SI header. */
+	tcpcp_make_si_hdr(sk, (*si_size), fd, si_hdr);	
+
+	/* end. */
+	DPRINTK("TCPCP : %s : end.\n", __FUNCTION__);
+	return 0;
+}
+
+/**
+ * do_tcpcp_make_si - make TCP-SIs.
+ *
+ * [Args]
+ *   (IN) *sk       : TCP socket
+ *   (IN) *r_entry  : Request Entry
+ *   (IN) *user_res : Processing Result Info.
+ *
+ * [Return]
+ *   0      : OK.
+ *  -ENOMEM : NG.
+ **/
+static int do_tcpcp_make_si(struct sock *sk,
+			    struct tcpcp_req_entry *r_entry,
+			    struct result *user_res)
+{
+	struct task_struct *tsk = current;
+	struct files_struct *files = tsk->files;
+	struct tcpcp_com_entry *si_entry = NULL;
+	struct tcpcp_com_entry *fdr_entry = NULL;
+	struct tcpcp_total_si_hdr *total_si_hdr;
+	unsigned int total_si_hdr_len;
+	unsigned int total_si_size;
+	unsigned int fd;
+	char *w_ptr;
+	unsigned int fd_all = 0;
+	unsigned int fd_ng = 0;
+	int error;
+	struct fdtable *fdt;
+	/* plug-in. */
+	plugin_dummy();
+
+	/* start. */
+	DPRINTK("TCPCP : %s : start. sk=0x%p, r_entry=0x%p, user_res=0x%p\n",
+		__FUNCTION__, sk, r_entry, user_res);
+
+	/* get write-point of TCP-SIs Entry. */
+	total_si_hdr_len = sizeof(struct tcpcp_total_si_hdr);
+	w_ptr = tcpcp_get_w_ptr(r_entry->flag, total_si_hdr_len,
+				&(r_entry->s_entry));
+	if (w_ptr == NULL) {
+		DPRINTK("TCPCP : %s : [Error] can't get w_ptr.\n",
+			__FUNCTION__);
+		return -ENOMEM;
+	}
+
+	if (r_entry->flag & TCPCP_FLAG_ALL) {
+		/* add FDR Info. Entry. (only "ALL")*/
+		error = tcpcp_add_com_entry(r_entry->flag, &(r_entry->f_entry));
+		if (error != 0)
+			return -ENOMEM;
+	}
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : r_entry->f_entry=0x%p\n",
+		__FUNCTION__, r_entry->f_entry);
+
+	/* initalize now TCP-SIs and FDR Info. Entry. */
+	si_entry = r_entry->s_entry;
+	fdr_entry = r_entry->f_entry;
+
+	/* reserve TCP-SIs total header. */
+	total_si_hdr = (struct tcpcp_total_si_hdr *)w_ptr;
+	total_si_size = total_si_hdr_len;
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : total_si_size=%d\n", __FUNCTION__, total_si_size);
+	fdt = files_fdtable(files);
+	/* search FD. */
+	for (fd = 0; fd < fdt->max_fds; fd++) {
+		unsigned int si_size = 0;
+ 		struct sock *sk_i;
+ 		int ret;
+ 
+		/* @@@ for DEBUG @@@ */
+		DPRINTK("TCPCP : %s : fd=%d\n", __FUNCTION__, fd);
+
+		/* check FD and get SOCKET_I(). */
+		sk_i = tcpcp_get_sk_i(sk, fd, r_entry);
+		if (sk_i == NULL)
+			continue;
+		/* @@@ for DEBUG @@@ */
+		DPRINTK("TCPCP : %s : nothing continue after tcpcp_get_sk_i.\n",
+			__FUNCTION__);
+
+		/* make TCP-SI. */
+		lock_sock(sk_i);
+		ret = do_make_si(sk_i, fd, r_entry->flag, &si_entry, &si_size);
+		release_sock(sk_i);
+		if (ret == -ENOMEM) {
+			DPRINTK("TCPCP : %s : [Error] can't make TCP-SI."
+				" ret=%d\n", __FUNCTION__, ret);
+			return ret;
+		}
+		/* @@@ for DEBUG @@@ */
+		DPRINTK("TCPCP : %s : si_size=%d\n", __FUNCTION__, si_size);
+
+		total_si_size += si_size;
+		/* @@@ for DEBUG @@@ */
+		DPRINTK("TCPCP : %s : total_si_size=%d\n",
+			__FUNCTION__, total_si_size);
+
+		fd_all++;
+		/* @@@ for DEBUG @@@ */
+		DPRINTK("TCPCP : %s : fd_all=%u\n", __FUNCTION__, fd_all);
+
+		if (!(r_entry->flag & TCPCP_FLAG_ALL)) {
+			/* @@@ for DEBUG @@@ */
+			DPRINTK("TCPCP : %s : Break for loop.\n", __FUNCTION__);
+
+			if (ret != 0)
+				return ret;
+			break;
+		}
+
+		/* Only ALL, the following processings are performed. */
+		if (ret != 0)
+			fd_ng++;
+		/* @@@ for DEBUG @@@ */
+		DPRINTK("TCPCP : %s : fd_ng=%u\n", __FUNCTION__, fd_ng);
+
+		/* make FDR Info. (only "ALL") */
+		error = tcpcp_make_res(fd, ret, &fdr_entry);
+		if (error != 0) {
+			/* only -ENOMEM. */
+			DPRINTK("TCPCP : %s : [Error] can't make FDR Info."
+				" error=%d\n", __FUNCTION__, error);
+			/* Caller delete Request Entry with common entries. */
+			return error;
+		}
+	}
+
+	/* make TCP-SIs header. */
+	total_si_hdr->total_si_length = htonl(total_si_size / 4);
+	total_si_hdr->major = TCPCP_CURRENT_SI_MAJOR;
+	total_si_hdr->minor = TCPCP_CURRENT_SI_MINOR;
+	total_si_hdr->si_cnt = htons(fd_all);
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : total_si_hdr->total_si_length=%u\n",
+		__FUNCTION__, total_si_hdr->total_si_length);
+	DPRINTK("TCPCP : %s : total_si_hdr->major=%u\n",
+		__FUNCTION__, total_si_hdr->major);
+	DPRINTK("TCPCP : %s : total_si_hdr->minor=%u\n",
+		__FUNCTION__, total_si_hdr->minor);
+	DPRINTK("TCPCP : %s : total_si_hdr->si_cnt=%u\n",
+		__FUNCTION__, total_si_hdr->si_cnt);
+
+	/* set Processing Result Info. */
+	user_res->fd_all = fd_all;
+	user_res->fd_ng = fd_ng;
+	user_res->buf_size = total_si_size;
+	user_res->fdrs_size = sizeof(struct fdr) * fd_all;
+	memcpy(&(r_entry->res), user_res, sizeof(struct result));
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : user_res->fd_all=%u\n",
+		__FUNCTION__, user_res->fd_all);
+	DPRINTK("TCPCP : %s : user_res->fd_ng =%u\n",
+		__FUNCTION__, user_res->fd_ng);
+	DPRINTK("TCPCP : %s : user_res->buf_size =%u\n",
+		__FUNCTION__, user_res->buf_size);
+	DPRINTK("TCPCP : %s : user_res->fdrs_size=%u\n",
+		__FUNCTION__, user_res->fdrs_size);
+	DPRINTK("TCPCP : %s : r_entry->res.fd_all=%u\n",
+		__FUNCTION__, r_entry->res.fd_all);
+	DPRINTK("TCPCP : %s : r_entry->res.fd_ng =%u\n",
+		__FUNCTION__, r_entry->res.fd_ng);
+	DPRINTK("TCPCP : %s : r_entry->res.buf_size =%u\n",
+		__FUNCTION__, r_entry->res.buf_size);
+	DPRINTK("TCPCP : %s : r_entry->res.fdrs_size=%u\n",
+		__FUNCTION__, r_entry->res.fdrs_size);
+
+	/* end. */
+	DPRINTK("TCPCP : %s : end.\n", __FUNCTION__);
+	return 0;
+}
+
+
+/* ----- stop TCP sockets -------------------------------------------------- */
+
+/**
+ * tcpcp_change_xmit - cue packet transmission function change.
+ *
+ * [Args]
+ *   (IN) *sk  : TCP socket
+ *   (IN) flag : "TCPCP_FLAG_STOP" / "TCPCP_FLAG_START"
+ **/
+static void tcpcp_change_xmit(struct sock *sk, unsigned char flag)
+{
+	struct tcp_sock *tp = tcp_sk(sk);
+
+	/* plug-in. */
+	plugin_dummy();
+
+	/* start. */
+	DPRINTK("TCPCP : %s : start. sk=0x%p, flag=%d\n",
+		__FUNCTION__, sk, flag);
+
+	/* @@@ for DEBUG @@@ */
+#if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)
+	DPRINTK("TCPCP : %s : &tcpcp_ipv6_af_mapped=0x%p\n",
+		__FUNCTION__, &tcpcp_ipv6_af_mapped);
+	DPRINTK("TCPCP : %s : &ipv6_mapped         =0x%p\n",
+		__FUNCTION__, &ipv6_mapped);
+	DPRINTK("TCPCP : %s : &tcpcp_ipv6_af_specific=0x%p\n",
+		__FUNCTION__, &tcpcp_ipv6_af_specific);
+	DPRINTK("TCPCP : %s : &ipv6_specific         =0x%p\n",
+		__FUNCTION__, &ipv6_specific);
+#endif
+	DPRINTK("TCPCP : %s : &tcpcp_ipv4_af_specific=0x%p\n",
+		__FUNCTION__, &tcpcp_ipv4_af_specific);
+	DPRINTK("TCPCP : %s : &ipv4_specific         =0x%p\n",
+		__FUNCTION__, &ipv4_specific);
+
+	if (flag == TCPCP_FLAG_STOP) {
+		/* stop. */
+#if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)
+		if (sk->sk_family == PF_INET6) {
+			struct ipv6_pinfo *inet6 = inet6_sk(sk);
+			int addr_type = ipv6_addr_type(&inet6->daddr);
+			if (addr_type == IPV6_ADDR_MAPPED)
+				tp->af_specific = &tcpcp_ipv6_af_mapped;
+			else
+				tp->af_specific = &tcpcp_ipv6_af_specific;
+		} else
+#endif
+			tp->af_specific = &tcpcp_ipv4_af_specific;
+	} else {
+		/* start. */
+#if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)
+		if (sk->sk_family == PF_INET6) {
+			struct ipv6_pinfo *inet6 = inet6_sk(sk);
+			int addr_type = ipv6_addr_type(&inet6->daddr);
+			if (addr_type == IPV6_ADDR_MAPPED)
+				tp->af_specific = &ipv6_mapped;
+			else
+				tp->af_specific = &ipv6_specific;
+		} else
+#endif
+			tp->af_specific = &ipv4_specific;
+	}
+
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : tp->af_specific=0x%p\n",
+		__FUNCTION__, tp->af_specific);
+
+	/* end. */
+	DPRINTK("TCPCP : %s : end.\n", __FUNCTION__);
+	return;
+}
+
+/**
+ * do_stop - stop TCP socket.
+ *
+ * Caller must lock socket.
+ *
+ * [Args]
+ *   (IN) *sk : TCP socket
+ **/
+static void do_stop(struct sock *sk)
+{
+	/* plug-in. */
+	plugin_dummy();
+
+	/* start. */
+	DPRINTK("TCPCP : %s : start. sk=0x%p\n", __FUNCTION__, sk);
+
+	/* set up dummy socket filter that just drops all inbound packets. */
+	if (sk->sk_filter != NULL) {
+		sk_filter_release(sk, sk->sk_filter);
+		/* @@@ for DEBUG @@@ */
+		DPRINTK("TCPCP : %s : socket filter is released.\n",
+			__FUNCTION__);
+		DPRINTK("TCPCP : %s : drop_all.refcnt=%d\n",
+			__FUNCTION__, atomic_read(&(drop_all.refcnt)));
+	}
+	sk->sk_filter = &drop_all;
+	sk_filter_charge(sk, sk->sk_filter);
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : &drop_all    =0x%p\n", __FUNCTION__, &drop_all);
+	DPRINTK("TCPCP : %s : sk->sk_filter=0x%p\n",
+		__FUNCTION__, sk->sk_filter);
+	DPRINTK("TCPCP : %s : drop_all.refcnt=%d\n",
+		__FUNCTION__, atomic_read(&(drop_all.refcnt)));
+
+	/* prevent socket from sending by inserting a fake set of
+	 * AF-specific functions. Very ugly, of course. */
+	tcpcp_change_xmit(sk, TCPCP_FLAG_STOP);
+
+	/* since our socket is now deaf and mute,
+	 * there's no point in lingering */
+	sock_set_flag(sk, SOCK_LINGER);
+	sk->sk_lingertime = 0;
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : sk->sk_flags=%lu (if value is 16, OK.)\n",
+		__FUNCTION__, sk->sk_flags);
+	DPRINTK("TCPCP : %s : sk->sk_lingertime=%lu\n",
+		__FUNCTION__, sk->sk_lingertime);
+
+	/* end. */
+	DPRINTK("TCPCP : %s : end.\n", __FUNCTION__);
+	return;
+}
+
+/**
+ * do_tcpcp_stop - stop TCP sockets.
+ *
+ * [Args]
+ *   (IN) *sk       : TCP socket
+ *   (IN) *r_entry  : Request Entry
+ *   (IN) *user_res : Processing Result Info.
+ *
+ * [Return]
+ *   0      : OK.
+ *  -ENOMEM : NG.
+ **/
+static int do_tcpcp_stop(struct sock *sk, struct tcpcp_req_entry *r_entry,
+			 struct result *user_res)
+{
+	struct task_struct *tsk = current;
+	struct files_struct *files = tsk->files;
+	struct tcpcp_com_entry *fdr_entry;
+	unsigned int fd;
+	unsigned int fd_all = 0;
+	int error;
+	struct fdtable *fdt;
+	/* plug-in. */
+	plugin_dummy();
+
+	/* start. */
+	DPRINTK("TCPCP : %s : start. sk=0x%p, r_entry=0x%p, user_res=0x%p\n",
+		__FUNCTION__, sk, r_entry, user_res);
+
+	if (r_entry->flag & TCPCP_FLAG_ALL) {
+		/* add FDR Info. Entry. (only "ALL") */
+		error = tcpcp_add_com_entry(r_entry->flag, &(r_entry->f_entry));
+		if (error != 0)
+			return -ENOMEM;
+	}
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : r_entry->f_entry=0x%p\n",
+		__FUNCTION__, r_entry->f_entry);
+
+	/* initialize now FDR Info. Entry. */
+	fdr_entry = r_entry->f_entry;
+	fdt = files_fdtable(files);
+	/* search FD. */
+	for (fd = 0; fd < fdt->max_fds; fd++) {
+		struct sock *sk_i;
+
+		/* check FD and get SOCKET_I(). */
+		sk_i = tcpcp_get_sk_i(sk, fd, r_entry);
+		if (sk_i == NULL) {
+			/* @@@ for DEBUG @@@ */
+			DPRINTK("TCPCP : %s : sk_i is NULL.\n", __FUNCTION__);
+
+			continue;
+		}
+		/* stop TCP socket. */
+		lock_sock(sk_i);
+		do_stop(sk_i);
+		release_sock(sk_i);
+
+		fd_all++;
+
+		if (!(r_entry->flag & TCPCP_FLAG_ALL)) {
+			/* @@@ for DEBUG @@@ */
+			DPRINTK("TCPCP : %s : Break for loop.\n", __FUNCTION__);
+
+			break;
+		}
+
+		/* make FDR Info. (only "ALL") */
+		error = tcpcp_make_res(fd, 0, &fdr_entry);
+		if (error != 0) {
+			/* only -ENOMEM. */
+			DPRINTK("TCPCP : %s : [Error] can't make FDR Info."
+				" error=%d\n", __FUNCTION__, error);
+			/* Caller delete Request Entry with common entries. */
+			return error;
+		}
+	}
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : Loop count=%d\n", __FUNCTION__, fd);
+
+	/* set Processing Result Info. */
+	user_res->fd_all = fd_all;
+	user_res->fd_ng = 0;
+	user_res->buf_size = 0;
+	user_res->fdrs_size = sizeof(struct fdr) * fd_all;
+	memcpy(&(r_entry->res), user_res, sizeof(struct result));
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : r_entry->res->fd_all=%u\n",
+		__FUNCTION__, r_entry->res.fd_all);
+	DPRINTK("TCPCP : %s : r_entry->res->fd_ng =%u\n",
+		__FUNCTION__, r_entry->res.fd_ng);
+	DPRINTK("TCPCP : %s : r_entry->res->buf_size =%u\n",
+		__FUNCTION__, r_entry->res.buf_size);
+	DPRINTK("TCPCP : %s : r_entry->res->fdrs_size=%u\n",
+		__FUNCTION__, r_entry->res.fdrs_size);
+
+	/* end. */
+	DPRINTK("TCPCP : %s : end.\n", __FUNCTION__);
+	return 0;
+}
+
+
+/* ----- close TCP sockets ------------------------------------------------- */
+
+/**
+ * do_close - close TCP socket.
+ *
+ * [Args]
+ *   (IN) fd : FD of TCP socket
+ *
+ * [Return]
+ *   0     : OK.
+ *   other : NG.
+ **/
+static int do_close(unsigned int fd)
+{
+	struct files_struct *files = current->files;
+	struct file *filp;
+	int error;
+	struct fdtable *fdt;
+	/* plug-in. */
+	plugin_dummy();
+
+	/* start. */
+	DPRINTK("TCPCP : %s : start. fd=%u\n", __FUNCTION__, fd);
+
+	spin_lock(&files->file_lock);
+	fdt = files_fdtable(files);
+	/* get file pointer. */
+	filp = fdt->fd[fd];
+	rcu_assign_pointer(fdt->fd[fd], NULL);
+	FD_CLR(fd, fdt->close_on_exec);
+	__FD_CLR(fd, fdt->open_fds);
+	if (fd < fdt->next_fd) {
+		/* @@@ for DEBUG @@@ */
+		DPRINTK("TCPCP : %s : files->next_fd=%d\n",
+			__FUNCTION__, files->next_fd);
+
+		fdt->next_fd = fd;
+		/* @@@ for DEBUG @@@ */
+		DPRINTK("TCPCP : %s : fd            =%d\n", __FUNCTION__, fd);
+		DPRINTK("TCPCP : %s : files->next_fd=%d\n",
+			__FUNCTION__, files->next_fd);
+	}
+
+	spin_unlock(&files->file_lock);
+
+	/* close file. */
+	error = filp_close(filp, files);
+
+	/* end. */
+	DPRINTK("TCPCP : %s : end. error=%d\n", __FUNCTION__, error);
+	return error;
+}
+
+/**
+ * do_tcpcp_close - close TCP sockets.
+ *
+ * [Args]
+ *   (IN) *sk       : TCP socket
+ *   (IN) *r_entry  : Request Entry
+ *   (IN) *user_res : Processing Result Info.
+ *
+ * [Return]
+ *   0      : OK.
+ *  -ENOMEM : NG.
+ **/
+static int do_tcpcp_close(struct sock *sk, struct tcpcp_req_entry *r_entry,
+			  struct result *user_res)
+{
+	struct task_struct *tsk = current;
+	struct files_struct *files = tsk->files;
+	struct tcpcp_com_entry *fdr_entry;
+	unsigned int fd;
+	unsigned int fd_all = 0;
+	unsigned int fd_ng = 0;
+	int error;
+	struct fdtable *fdt;
+	/* plug-in. */
+	plugin_dummy();
+
+	/* start. */
+	DPRINTK("TCPCP : %s : start. sk=0x%p, r_entry=0x%p, user_res=0x%p\n",
+		__FUNCTION__, sk, r_entry, user_res);
+
+	/* add FDR Info. Entry. (only "ALL")*/
+	error = tcpcp_add_com_entry(r_entry->flag, &(r_entry->f_entry));
+	if (error != 0)
+		return -ENOMEM;
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : r_entry->f_entry=0x%p\n",
+		__FUNCTION__, r_entry->f_entry);
+
+	/* initialize now FDR Info. Entry. */
+	fdr_entry = r_entry->f_entry;
+	fdt = files_fdtable(files);
+	/* search FD. */
+	for (fd = 0; fd < fdt->max_fds; fd++) {
+ 		struct sock *sk_i;
+ 		int ret;
+ 
+		/* check FD and get SOCKET_I(). */
+		sk_i = tcpcp_get_sk_i(sk, fd, r_entry);
+		if (sk_i == NULL) {
+			/* @@@ for DEBUG @@@ */
+			DPRINTK("TCPCP : %s : sk_i is NULL.\n", __FUNCTION__);
+
+			continue;
+		}
+		/* close TCP socket. */
+		/* 
+		 * lock_sock and release_sock are unnecessary.
+		 * because spin_lock to files is in do_close.
+		 */
+		ret = do_close(fd);
+
+		fd_all++;
+		if (ret != 0)
+			fd_ng++;
+
+		/* make FDR Info. (only "ALL") */
+		error = tcpcp_make_res(fd, ret, &fdr_entry);
+		if (error != 0) {
+			/* only -ENOMEM. */
+                        DPRINTK("TCPCP : %s : [Error] can't make FDR Info."
+				" error=%d\n", __FUNCTION__, error);
+			/* Caller delete Request Entry with common entries. */
+			return error;
+		}
+	}
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : Loop count=%d\n", __FUNCTION__, fd);
+
+#ifdef CONFIG_TCPCP_DEBUG
+	/* @@@ print Process List with lock. (for DEBUG) @@@ */
+	print_list();
+#endif
+
+	/* set Processing Result Info. */
+	user_res->fd_all = fd_all;
+	user_res->fd_ng = fd_ng;
+	user_res->buf_size = 0;
+	user_res->fdrs_size = sizeof(struct fdr) * fd_all;
+	memcpy(&(r_entry->res), user_res, sizeof(struct result));
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : r_entry->res->fd_all=%u\n",
+		__FUNCTION__, r_entry->res.fd_all);
+	DPRINTK("TCPCP : %s : r_entry->res->fd_ng =%u\n",
+		__FUNCTION__, r_entry->res.fd_ng);
+	DPRINTK("TCPCP : %s : r_entry->res->buf_size =%u\n",
+		__FUNCTION__, r_entry->res.buf_size);
+	DPRINTK("TCPCP : %s : r_entry->res->fdrs_size=%u\n",
+		__FUNCTION__, r_entry->res.fdrs_size);
+
+	/* end. */
+	DPRINTK("TCPCP : %s : end.\n", __FUNCTION__);
+	return 0;
+}
+
+
+/* ----- set TCP Socket Informations (TCP-SIs) ----------------------------- */
+
+/* ----- TCP-SI buffer management ----- */
+
+/**
+ * tcpcp_clear_si_buf - clear TCP-SI buffer.
+ *
+ * [Args]
+ *   (IN) *si_buf : TCP-SI buffer
+ **/
+static void tcpcp_clear_si_buf(struct tcpcp_si_buf *si_buf)
+{
+	/* plug-in. */
+	plugin_dummy();
+
+	/* start. */
+	DPRINTK("TCPCP : %s : start. si_buf=0x%p\n", __FUNCTION__, si_buf);
+
+	/* clear TCP-SI header buffer and packet info. buffer. */
+	memset(&(si_buf->si_hdr), 0, sizeof(struct tcpcp_si_hdr));
+	memset(si_buf->snd_buf.si_skb, 0, TCPCP_SI_SKB_BUF_SIZE);
+	memset(si_buf->rcv_buf.si_skb, 0, TCPCP_SI_SKB_BUF_SIZE);
+
+	/* clear length and count of snd/rcv buffer. */
+	si_buf->snd_buf.buf_len = 0;
+	si_buf->snd_buf.skb_cnt = 0;
+	si_buf->rcv_buf.buf_len = 0;
+	si_buf->rcv_buf.skb_cnt = 0;
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : si_buf->snd_buf.buf_len=%u\n",
+		__FUNCTION__, si_buf->snd_buf.buf_len);
+	DPRINTK("TCPCP : %s : si_buf->snd_buf.skb_cnt=%u\n",
+		__FUNCTION__, si_buf->snd_buf.skb_cnt);
+	DPRINTK("TCPCP : %s : si_buf->rcv_buf.buf_len=%u\n",
+		__FUNCTION__, si_buf->rcv_buf.buf_len);
+	DPRINTK("TCPCP : %s : si_buf->rcv_buf.skb_cnt=%u\n",
+		__FUNCTION__, si_buf->rcv_buf.skb_cnt);
+
+	/* end. */
+	DPRINTK("TCPCP : %s : end.\n", __FUNCTION__);
+	return;
+}
+
+/**
+ * tcpcp_alloc_si_buf - allocate TCP-SI buffer.
+ *
+ * [Args]
+ *   (IN) *si_buf : TCP-SI buffer
+ *
+ * [Return]
+ *   0      : OK.
+ *  -ENOMEM : NG.
+ **/
+static int tcpcp_alloc_si_buf(struct tcpcp_si_buf *si_buf)
+{
+	/* plug-in. */
+	plugin_dummy();
+
+	/* start. */
+	DPRINTK("TCPCP : %s : start. si_buf=0x%p\n", __FUNCTION__, si_buf);
+
+	/* allocate TCP-SI buffer for send-packet info. */
+	si_buf->snd_buf.si_skb = kmalloc(TCPCP_SI_SKB_BUF_SIZE, GFP_KERNEL);
+	if (si_buf->snd_buf.si_skb == NULL) {
+		DPRINTK("TCPCP : %s : [Error] can't allocate TCP-SI buffer"
+			" (1).\n", __FUNCTION__);
+		return -ENOMEM;
+	}
+	si_buf->snd_buf.max_buf_len = TCPCP_SI_SKB_BUF_SIZE;
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : TCPCP_SI_SKB_BUF_SIZE      =%lu\n",
+		__FUNCTION__, TCPCP_SI_SKB_BUF_SIZE);
+	DPRINTK("TCPCP : %s : si_buf->snd_buf.max_buf_len=%u\n",
+		__FUNCTION__, si_buf->snd_buf.max_buf_len);
+
+	/* allocate TCP-SI buffer for receive-packet info. */
+	si_buf->rcv_buf.si_skb = kmalloc(TCPCP_SI_SKB_BUF_SIZE, GFP_KERNEL);
+	if (si_buf->rcv_buf.si_skb == NULL) {
+		DPRINTK("TCPCP : %s : [Error] can't allocate TCP-SI buffer"
+			" (2).\n", __FUNCTION__);
+
+		kfree(si_buf->snd_buf.si_skb);
+		si_buf->snd_buf.si_skb = NULL;
+		/* @@@ for DEBUG @@@ */
+		DPRINTK("TCPCP : %s : si_buf->snd_buf.si_skb is NULL.\n",
+			__FUNCTION__);
+
+		return -ENOMEM;
+	}
+	si_buf->rcv_buf.max_buf_len = TCPCP_SI_SKB_BUF_SIZE;
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : si_buf->rcv_buf.max_buf_len=%u\n",
+		__FUNCTION__, si_buf->rcv_buf.max_buf_len);
+
+	/* clear TCP-SI buffer. */
+	tcpcp_clear_si_buf(si_buf);
+
+	/* end. */
+	DPRINTK("TCPCP : %s : end.\n", __FUNCTION__);
+	return 0;
+}
+
+/**
+ * tcpcp_free_si_buf - free TCP-SI buffer.
+ *
+ * [Args]
+ *   (IN) *si_buf : TCP-SI buffer
+ **/
+static void tcpcp_free_si_buf(struct tcpcp_si_buf *si_buf)
+{
+	/* plug-in. */
+	plugin_dummy();
+
+	/* start. */
+	DPRINTK("TCPCP : %s : start. si_buf=0x%p\n", __FUNCTION__, si_buf);
+
+	/* clear TCP-SI buffer. */
+	tcpcp_clear_si_buf(si_buf);
+
+	/* free TCP-SI buffer for packet info. */
+	kfree(si_buf->snd_buf.si_skb);
+	kfree(si_buf->rcv_buf.si_skb);
+	si_buf->snd_buf.max_buf_len = 0;
+	si_buf->rcv_buf.max_buf_len = 0;
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : si_buf->snd_buf.max_buf_len=%u\n",
+		__FUNCTION__, si_buf->snd_buf.max_buf_len);
+	DPRINTK("TCPCP : %s : si_buf->rcv_buf.max_buf_len=%u\n",
+		__FUNCTION__, si_buf->rcv_buf.max_buf_len);
+
+	/* end. */
+	DPRINTK("TCPCP : %s : end.\n", __FUNCTION__);
+	return;
+}
+
+/**
+ * tcpcp_copy_si_from_user - copy TCP-SI from userland to Kernel.
+ *
+ * This function is based on TCPCP-9:tcpcp_buffers().
+ *
+ * [Args]
+ *   (IN) *user_si    : user TCP-SI
+ *   (IN) *si_buf     : TCP-SI buffer
+ *   (IN) total_ucopy : un-copied TCP-SIs
+ *
+ * [Return]
+ *   0      : OK.
+ *  -EFAULT : NG.
+ *  -ENOMEM : NG.
+ *  -EINVAL : NG.
+ **/
+static int tcpcp_copy_si_from_user(const struct tcpcp_si_hdr *user_si,
+				   struct tcpcp_si_buf *si_buf,
+				   unsigned int total_ucopy)
+{
+	struct tcpcp_si_skb *si_skb;
+	unsigned int si_hdr_len;
+	unsigned int si_len;
+	unsigned int ucopy;
+	int error = 0;
+	char *r_ptr;
+
+	/* plug-in. */
+	plugin_dummy();
+
+	/* start. */
+	DPRINTK("TCPCP : %s : start. user_si=0x%p, si_buf=0x%p"
+		" total_ucopy=%u\n",
+		__FUNCTION__, user_si, si_buf, total_ucopy);
+
+	/* set read-point. */
+	r_ptr = (char *)user_si;
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : r_ptr=0x%p\n", __FUNCTION__, r_ptr);
+
+	si_hdr_len = sizeof(struct tcpcp_si_hdr);
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : total_ucopy=%u\n", __FUNCTION__, total_ucopy);
+	DPRINTK("TCPCP : %s : si_hdr_len =%u\n", __FUNCTION__, si_hdr_len);
+
+	/* check length of TCP-SI header. */
+	if (total_ucopy < si_hdr_len)
+		return -EINVAL;
+
+	/* get length of TCP-SI. (include TCP-SI header) */
+	si_len = ntohl(user_si->si_length) * 4;
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : si_len=%u\n", __FUNCTION__, si_len);
+
+	/* check length of TCP-SI. */
+	if (si_len < si_hdr_len)
+		return -EINVAL;
+	if (total_ucopy < si_len)
+		return -EINVAL;
+
+	/* copy TCP-SI header from userland to Kernel. */
+	error = copy_from_user(&(si_buf->si_hdr), user_si, si_hdr_len);
+	if (error != 0) {
+		DPRINTK("TCPCP : %s : [Error] can't copy TCP-SI header from"
+			"userland. error=%d\n", __FUNCTION__, error);
+		return -EFAULT;
+	}
+
+	/* move read-point. */
+	r_ptr += si_hdr_len;
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : r_ptr=0x%p\n", __FUNCTION__, r_ptr);
+
+	/* set un-copied TCP-SI. */
+	ucopy = si_len - si_hdr_len;
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : ucopy=%u\n", __FUNCTION__, ucopy);
+
+	while (ucopy != 0) {
+		struct tcpcp_si_skb_buf *si_skb_buf;
+		unsigned int si_skb_len;
+
+		/* check length of packet info. */
+		if (ucopy < sizeof(struct tcpcp_si_skb))
+			return -EINVAL;
+
+		si_skb = (struct tcpcp_si_skb *)r_ptr;
+
+		/* calculate length of packet info. */
+		si_skb_len = sizeof(struct tcpcp_si_skb)
+			     + ((ntohs(si_skb->length) + 3) & ~3);
+		/* @@@ for DEBUG @@@ */
+		DPRINTK("TCPCP : %s : si_skb_len=%u\n",
+			__FUNCTION__, si_skb_len);
+
+		/* check length of packet info. */
+		if (ucopy < si_skb_len)
+			return -EINVAL;
+
+		/* @@@ for DEBUG @@@ */
+		DPRINTK("TCPCP : %s : si_skb->type=%u\n",
+			__FUNCTION__, si_skb->type);
+
+		switch (si_skb->type) {
+		case TCPCP_SIE_BUF_SND:
+			si_skb_buf = &(si_buf->snd_buf);
+			break;
+		case TCPCP_SIE_BUF_RCV: 
+			si_skb_buf = &(si_buf->rcv_buf);
+			break;
+		default:
+			return -EINVAL;
+		}
+		/* @@@ for DEBUG @@@ */
+		DPRINTK("TCPCP : %s : &(si_buf->snd_buf)=0x%p\n",
+			__FUNCTION__, &(si_buf->snd_buf));
+		DPRINTK("TCPCP : %s : &(si_buf->rcv_buf)=0x%p\n",
+			__FUNCTION__, &(si_buf->rcv_buf));
+		DPRINTK("TCPCP : %s : si_skb_buf        =0x%p\n",
+			__FUNCTION__, si_skb_buf);
+
+		/* @@@ for DEBUG @@@ */
+		DPRINTK("TCPCP : %s : si_skb_buf->max_buf_len=%u\n",
+			__FUNCTION__, si_skb_buf->max_buf_len);
+		DPRINTK("TCPCP : %s : si_skb_buf->buf_len    =%u\n",
+			__FUNCTION__, si_skb_buf->buf_len);
+
+		/* check free of packet info. buffer. */
+		if (si_skb_buf->max_buf_len - si_skb_buf->buf_len < si_skb_len)
+			return -EINVAL;
+
+		/* copy packet info. from userland. */
+		error = copy_from_user(si_skb_buf->si_skb + si_skb_buf->buf_len,
+				       r_ptr, si_skb_len);
+		if (error != 0) {
+			DPRINTK("TCPCP : %s : [Error] can't copy packet info."
+				" from userland. error=%d\n",
+				__FUNCTION__, error);
+			return -EFAULT;
+		}
+
+		si_skb_buf->buf_len += si_skb_len;
+		si_skb_buf->skb_cnt++;
+		/* @@@ for DEBUG @@@ */
+		DPRINTK("TCPCP : %s : si_skb_len         =%u\n",
+			__FUNCTION__, si_skb_len);
+		DPRINTK("TCPCP : %s : si_skb_buf->buf_len=%u\n",
+			__FUNCTION__, si_skb_buf->buf_len);
+		DPRINTK("TCPCP : %s : si_skb_buf->skb_cnt=%u\n",
+			__FUNCTION__, si_skb_buf->skb_cnt);
+
+		/* move read-point. */
+		r_ptr += si_skb_len;
+		ucopy -= si_skb_len;
+		/* @@@ for DEBUG @@@ */
+		DPRINTK("TCPCP : %s : r_ptr=0x%p\n", __FUNCTION__, r_ptr);
+		DPRINTK("TCPCP : %s : ucopy=%u\n", __FUNCTION__, ucopy);
+	}
+
+	/*  end. */
+	DPRINTK("TCPCP : %s : end.\n", __FUNCTION__);
+	return 0;
+}
+
+/* ----- set TCP-SI ----- */
+
+/**
+ * tcpcp_check_compatibility - Step 1 : check compatibility.
+ *
+ * This function is based on TCPCP-9:tcpcp_compatibility().
+ * It's checks that a connection with the characteristics described in TCP-SI
+ * header is compatible with the functionality available on the local system.
+ * If not, the operation fails.
+ * (E.g. if SACK is disabled here, we cannot negotiate out of using it.)
+ * 
+ * [Args]
+ *   (IN) *si_hdr : TCP-SI header
+ *
+ * [Return]
+ *   0           : OK.
+ *  -ENOPROTOOPT : NG.
+ **/
+static int tcpcp_check_compatibility(const struct tcpcp_si_hdr *si_hdr)
+{
+	/* plug-in. */
+	plugin_dummy();
+
+	/* start. */
+	DPRINTK("TCPCP : %s : start. si_hdr=0x%p\n", __FUNCTION__, si_hdr);
+
+	if ((si_hdr->fixgen.tcp_flags & TCPI_OPT_TIMESTAMPS)
+	    && (sysctl_tcp_timestamps == 0))
+		return -ENOPROTOOPT;
+	if ((si_hdr->fixgen.tcp_flags & TCPI_OPT_SACK)
+	    && (sysctl_tcp_sack == 0))
+		return -ENOPROTOOPT;
+	if ((si_hdr->fixgen.tcp_flags & TCPI_OPT_WSCALE)
+	    && (sysctl_tcp_window_scaling == 0))
+		return -ENOPROTOOPT;
+	if ((si_hdr->fixgen.tcp_flags & TCPI_OPT_ECN) && (sysctl_tcp_ecn == 0))
+		return -ENOPROTOOPT;
+
+	/* end. */
+	DPRINTK("TCPCP : %s : end.\n", __FUNCTION__);
+	return 0;
+}
+
+/**
+ * tcpcp_setopt_before_bind - Step 2 : set socket options. (before pre-bind)
+ *
+ * This function is based on sock.c:sock_setsockopt(),
+ *                           ip_sockglue.c:ip_setsockopt(),
+ *                           ipv6_sockglue.c:ipv6_setsockopt(),
+ *                           tcp.c:tcp_setsockopt().
+ * Caller must lock socket.
+ *
+ * [Args]
+ *   (IN) *sk     : TCP socket
+ *   (IN) *si_hdr : TCP-SI header
+ **/
+static void tcpcp_setopt_before_bind(struct sock *sk,
+				     const struct tcpcp_si_hdr *si_hdr)
+{
+	struct inet_sock *inet = inet_sk(sk);
+#if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)
+	struct ipv6_pinfo *inet6 = inet6_sk(sk);
+#endif
+	int valbool;
+	uint8_t val8 = 0;
+	uint32_t val32 = 0;
+
+	/* plug-in. */
+	plugin_dummy();
+
+	/* start. */
+	DPRINTK("TCPCP : %s : start. sk=0x%p, si_hdr=0x%p\n",
+		__FUNCTION__, sk, si_hdr);
+
+	/*
+	 * set socket options. (socket)
+	 */
+
+	/* set SO_REUSEADDR flag. */
+	if (si_hdr->sockopt.sk.flags & TCPCP_SIE_SOCK_REUSEADDR)
+		sk->sk_reuse = 1;
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : si_hdr->sockopt.sk.flags=%d\n",
+		__FUNCTION__, si_hdr->sockopt.sk.flags);
+	DPRINTK("TCPCP : %s : sk->sk_reuse=%d\n", __FUNCTION__, sk->sk_reuse);
+
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : sk->sk_flags=%lu\n", __FUNCTION__, sk->sk_flags);
+
+	/* set SO_KEEPOPEN flag. */
+	valbool = (si_hdr->sockopt.sk.flags & TCPCP_SIE_SOCK_KEEPOPEN);
+	tcpcp_set_keepalive(sk, valbool);
+	sock_valbool_flag(sk, SOCK_KEEPOPEN, valbool);
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : sk->sk_flags=%lu\n", __FUNCTION__, sk->sk_flags);
+
+	/* set SOCK_LINGER flag and time. */
+	if (!(si_hdr->sockopt.sk.flags & TCPCP_SIE_SOCK_LINGER))
+		sock_reset_flag(sk, SOCK_LINGER);
+	else {
+		val32 = ntohl(si_hdr->sockopt.sk.l_linger);
+		sk->sk_lingertime = val32 * HZ;
+		sock_set_flag(sk, SOCK_LINGER);
+	}
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : si_hdr->sockopt.sk.flags=%u\n",
+		__FUNCTION__, si_hdr->sockopt.sk.flags);
+	DPRINTK("TCPCP : %s : sk->sk_flags=%lu\n",
+		__FUNCTION__, sk->sk_flags);
+	DPRINTK("TCPCP : %s : si_hdr->sockopt.sk.l_linger=%u\n",
+		__FUNCTION__, si_hdr->sockopt.sk.l_linger);
+	DPRINTK("TCPCP : %s : val32                      =%u\n",
+		__FUNCTION__, val32);
+	DPRINTK("TCPCP : %s : sk->sk_lingertime          =%lu\n",
+		__FUNCTION__, sk->sk_lingertime);
+
+	/* set size of buffer. */
+	sk->sk_userlocks = si_hdr->sockopt.sk.userlocks;
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : si_hdr->sockopt.sk.userlocks=%u\n",
+		__FUNCTION__, si_hdr->sockopt.sk.userlocks);
+	DPRINTK("TCPCP : %s : sk->sk_userlocks            =%u\n",
+		__FUNCTION__, sk->sk_userlocks);
+
+	/* set size of send buffer in bytes. */
+	val32 = ntohl(si_hdr->sockopt.sk.sndbuf);
+	if (val32 > sysctl_wmem_max)
+		val32 = sysctl_wmem_max;
+	if (val32 * 2 < SOCK_MIN_SNDBUF)
+		sk->sk_sndbuf = SOCK_MIN_SNDBUF;
+	else
+		sk->sk_sndbuf = val32 * 2;
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : si_hdr->sockopt.sk.sndbuf=%u\n",
+		__FUNCTION__, si_hdr->sockopt.sk.sndbuf);
+	DPRINTK("TCPCP : %s : val32                    =%u\n",
+		__FUNCTION__, val32);
+	DPRINTK("TCPCP : %s : sysctl_wmem_max          =%u\n",
+		__FUNCTION__, sysctl_wmem_max);
+	DPRINTK("TCPCP : %s : sk->sk_sndbuf            =%u\n",
+		__FUNCTION__, sk->sk_sndbuf);
+
+	/* set size of receive buffer in bytes. */
+	val32 = ntohl(si_hdr->sockopt.sk.rcvbuf);
+	if (val32 > sysctl_rmem_max)
+		val32 = sysctl_rmem_max;
+	if (val32 * 2 < SOCK_MIN_RCVBUF)
+		sk->sk_rcvbuf = SOCK_MIN_RCVBUF;
+	else
+		sk->sk_rcvbuf = val32 * 2;
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : si_hdr->sockopt.sk.rcvbuf=%u\n",
+		__FUNCTION__, si_hdr->sockopt.sk.rcvbuf);
+	DPRINTK("TCPCP : %s : val32                    =%u\n",
+		__FUNCTION__, val32);
+	DPRINTK("TCPCP : %s : sysctl_rmem_max          =%u\n",
+		__FUNCTION__, sysctl_rmem_max);
+	DPRINTK("TCPCP : %s : sk->sk_rcvbuf            =%u\n",
+		__FUNCTION__, sk->sk_rcvbuf);
+
+	/* set SO_PRIORITY. */
+	sk->sk_priority = ntohl(si_hdr->sockopt.sk.priority);
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : si_hdr->sockopt.sk.priority=%u\n",
+		__FUNCTION__, si_hdr->sockopt.sk.priority);
+	DPRINTK("TCPCP : %s : sk->sk_priorityi           =%u\n",
+		__FUNCTION__, sk->sk_priority);
+
+#if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)
+	if (si_hdr->id.ip_version == 6) {
+		/*
+		 * set socket options. (IPv6)
+		 */
+
+		/* @@@ for DEBUG @@@ */
+		DPRINTK("TCPCP : %s : si_hdr->sockopt.ip.v6.flags=%u\n",
+			__FUNCTION__, si_hdr->sockopt.ip.v6.flags);
+
+		/* set unicast hop limit. */
+		if (si_hdr->sockopt.ip.v6.flags
+		    & TCPCP_SIE_IPV6_DEFAULT_HOPLIMIT)
+			inet6->hop_limit = -1;
+		else {
+			val8 = si_hdr->sockopt.ip.v6.hop_limit;
+			inet6->hop_limit = val8;
+		}
+		/* @@@ for DEBUG @@@ */
+		DPRINTK("TCPCP : %s : si_hdr->sockopt.ip.v6.hop_limit=%u\n",
+			__FUNCTION__, si_hdr->sockopt.ip.v6.hop_limit);
+		DPRINTK("TCPCP : %s : val8                           =%u\n",
+			__FUNCTION__, val8);
+		DPRINTK("TCPCP : %s : inet6->hop_limit               =%u\n",
+			__FUNCTION__, inet6->hop_limit);
+
+		/* set IP_MTU_DISCOVER state. */
+		val8 = si_hdr->sockopt.ip.v6.pmtudisc;
+		if (val8 <= 2)
+			inet6->pmtudisc = val8;
+		/* @@@ for DEBUG @@@ */
+		DPRINTK("TCPCP : %s : si_hdr->sockopt.ip.v6.pmtudisc=%u\n",
+			__FUNCTION__, si_hdr->sockopt.ip.v6.pmtudisc);
+		DPRINTK("TCPCP : %s : val8                          =%u\n",
+			__FUNCTION__, val8);
+		DPRINTK("TCPCP : %s : inet6->pmtudisc               =%u\n",
+			__FUNCTION__, inet6->pmtudisc);
+
+	} else
+#endif
+	{
+		/*
+		 * set socket options. (IPv4)
+		 */
+
+		/* set unicast TTL. */
+		if (si_hdr->sockopt.ip.v4.flags & TCPCP_SIE_IP_DEFAULT_TTL)
+			inet->uc_ttl = -1;
+		else {
+			val8 = si_hdr->sockopt.ip.v4.uc_ttl;
+			if (val8 != 0)
+				inet->uc_ttl = val8;
+		}
+		/* @@@ for DEBUG @@@ */
+		DPRINTK("TCPCP : %s : si_hdr->sockopt.ip.v4.flags =%u\n",
+			__FUNCTION__, si_hdr->sockopt.ip.v4.flags);
+		DPRINTK("TCPCP : %s : si_hdr->sockopt.ip.v4.uc_ttl=%u\n",
+			__FUNCTION__, si_hdr->sockopt.ip.v4.uc_ttl);
+		DPRINTK("TCPCP : %s : val8                        =%u\n",
+			__FUNCTION__, val8);
+		DPRINTK("TCPCP : %s : inet->uc_ttl                =%d\n",
+			__FUNCTION__, inet->uc_ttl);
+
+		/* set IP_MTU_DISCOVER state. */
+		val8 = si_hdr->sockopt.ip.v4.pmtudisc;
+		if (val8 <= 2)
+			inet->pmtudisc = val8;
+		/* @@@ for DEBUG @@@ */
+		DPRINTK("TCPCP : %s : si_hdr->sockopt.ip.v4.pmtudisc=%u\n",
+			__FUNCTION__, si_hdr->sockopt.ip.v4.pmtudisc);
+		DPRINTK("TCPCP : %s : val8                          =%u\n",
+			__FUNCTION__, val8);
+		DPRINTK("TCPCP : %s : inet->pmtudisc                =%u\n",
+			__FUNCTION__, inet->pmtudisc);
+
+		/* set TOS. */
+		val8 = si_hdr->sockopt.ip.v4.tos;
+		val8 &= ~3;
+		val8 |= inet->tos & 3;
+		inet->tos = val8;
+		/* @@@ for DEBUG @@@ */
+		DPRINTK("TCPCP : %s : si_hdr->sockopt.ip.v4.tos=%u\n",
+			__FUNCTION__, si_hdr->sockopt.ip.v4.tos);
+		DPRINTK("TCPCP : %s : val8                     =%u\n",
+			__FUNCTION__, val8);
+		DPRINTK("TCPCP : %s : inet->tos                =%d\n",
+			__FUNCTION__, inet->tos);
+	}
+
+	/* end. */
+	DPRINTK("TCPCP : %s : end.\n", __FUNCTION__);
+	return;
+}
+
+/**
+ * tcpcp_inet_addr_type - get type of IPv4 address.
+ * 
+ * This function is based on fib_frontend.c:inet_addr_type().
+ * 
+ * [Args]
+ *   (IN) addr : IPv4 address
+ * 
+ * [Return]
+ *   RTN_LOCAL
+ *   RTN_BROADCAST
+ *   RTN_MULTICAST
+ **/
+static unsigned tcpcp_inet_addr_type(u32 addr)
+{
+	unsigned ret = RTN_LOCAL;
+
+	/* plug-in. */
+	plugin_dummy();
+
+	/* start. */
+	DPRINTK("TCPCP : %s : start. addr=0x%x\n", __FUNCTION__, addr);
+
+	if (ZERONET(addr) || BADCLASS(addr))
+		return RTN_BROADCAST;
+	if (MULTICAST(addr))
+		return RTN_MULTICAST;
+
+	/* end. */
+	DPRINTK("TCPCP : %s : end.\n", __FUNCTION__);
+	return ret;
+}
+
+#if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)
+/**
+ * tcpcp_pre_v6bind - Step 3 : pre-processing of TCP/IPv6 bind.
+ *
+ * This function is based on af_inet6.c:inet6_bind().
+ * Caller must lock socket.
+ * 
+ * [Args]
+ *   (IN) *sk     : TCP socket
+ *   (IN) *si_hdr : TCP-SI header
+ * 
+ * [Return]
+ *   0             : OK.
+ *  -EINVAL        : NG.
+ *  -EADDRNOTAVAIL : NG.
+ *  -EACCES        : NG.
+ **/
+static int tcpcp_pre_v6bind(struct sock *sk, const struct tcpcp_si_hdr *si_hdr)
+{
+	struct inet_sock *inet = inet_sk(sk);
+	struct ipv6_pinfo *inet6 = inet6_sk(sk);
+
+	struct in6_addr ip_src;
+	unsigned short snum;
+	__u32 scope_id;
+	__u32 v4addr = 0;
+	int addr_type = 0;
+
+	/* plug-in. */
+	plugin_dummy();
+
+	/* start. */
+	DPRINTK("TCPCP : %s : start. sk=0x%p, si_hdr=0x%p\n",
+		__FUNCTION__, sk, si_hdr);
+
+	/* check Bind hash. */
+	if (inet_csk(sk)->icsk_bind_hash != NULL)
+		return -EBADFD;
+
+	/* get IPv6 source address and TCP source port. */
+	ipv6_addr_copy(&ip_src, &(si_hdr->id.ip.v6.ip_src));
+	snum = ntohs(si_hdr->id.tcp_sport);
+	scope_id = ntohl(si_hdr->id.ip.v6.scope_id); 
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : si_hdr->id.ip.v6.ip_src=%04x:%04x:%04x:%04x:"
+		"%04x:%04x:%04x:%04x\n", __FUNCTION__,
+		ntohs(si_hdr->id.ip.v6.ip_src.s6_addr16[0]),
+		ntohs(si_hdr->id.ip.v6.ip_src.s6_addr16[1]),
+		ntohs(si_hdr->id.ip.v6.ip_src.s6_addr16[2]),
+		ntohs(si_hdr->id.ip.v6.ip_src.s6_addr16[3]),
+		ntohs(si_hdr->id.ip.v6.ip_src.s6_addr16[4]),
+		ntohs(si_hdr->id.ip.v6.ip_src.s6_addr16[5]),
+		ntohs(si_hdr->id.ip.v6.ip_src.s6_addr16[6]),
+		ntohs(si_hdr->id.ip.v6.ip_src.s6_addr16[7]));
+	DPRINTK("TCPCP : %s : ip_src                 =%04x:%04x:%04x:%04x:"
+		"%04x:%04x:%04x:%04x\n", __FUNCTION__,
+		ntohs(ip_src.s6_addr16[0]),
+		ntohs(ip_src.s6_addr16[1]),
+		ntohs(ip_src.s6_addr16[2]),
+		ntohs(ip_src.s6_addr16[3]),
+		ntohs(ip_src.s6_addr16[4]),
+		ntohs(ip_src.s6_addr16[5]),
+		ntohs(ip_src.s6_addr16[6]),
+		ntohs(ip_src.s6_addr16[7]));
+	DPRINTK("TCPCP : %s : si_hdr->id.tcp_sport=%u\n",
+		__FUNCTION__, si_hdr->id.tcp_sport);
+	DPRINTK("TCPCP : %s : snum                =%u\n",
+		__FUNCTION__, snum);
+	DPRINTK("TCPCP : %s : si_hdr->id.ip.v6.scope_id=%u\n",
+		__FUNCTION__, si_hdr->id.ip.v6.scope_id);
+	DPRINTK("TCPCP : %s : scope_id                 =%u\n",
+		__FUNCTION__, scope_id);
+
+	/* get type of IPv6 source address. */
+	addr_type = ipv6_addr_type(&ip_src);
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : addr_type=%u\n", __FUNCTION__, addr_type);
+
+	/* check type of IPv6 source address. */
+	if ((addr_type == IPV6_ADDR_ANY) || (addr_type & IPV6_ADDR_MULTICAST)) {
+		/* TCPCP not support IPV6_ADDR_ANY and multicast. */
+		DPRINTK("TCPCP : %s : [Error] type of ip_src is ANY or"
+			" multicast.\n", __FUNCTION__);
+		return -EADDRNOTAVAIL;
+	}
+
+	/* check TCP source port. */
+	if (snum == 0) {
+		DPRINTK("TCPCP : %s : [Error] tcp_sport is 0.\n", __FUNCTION__);
+		return -EINVAL;
+	}
+	if ((snum < PROT_SOCK) && (!capable(CAP_NET_BIND_SERVICE)))
+		return -EACCES;
+
+	/* check if the address belongs to the host. */
+	if (addr_type == IPV6_ADDR_MAPPED) {
+		/* mapped address. */
+		v4addr = ip_src.s6_addr32[3];
+		/* @@@ for DEBUG @@@ */
+		DPRINTK("TCPCP : %s : ip_src=%04x:%04x:%04x:%04x:"
+			"%04x:%04x:%04x:%04x\n", __FUNCTION__,
+			ntohs(ip_src.s6_addr16[0]),
+			ntohs(ip_src.s6_addr16[1]),
+			ntohs(ip_src.s6_addr16[2]),
+			ntohs(ip_src.s6_addr16[3]),
+			ntohs(ip_src.s6_addr16[4]),
+			ntohs(ip_src.s6_addr16[5]),
+			ntohs(ip_src.s6_addr16[6]),
+			ntohs(ip_src.s6_addr16[7]));
+		DPRINTK("TCPCP : %s : v4addr=0x%x\n", __FUNCTION__, v4addr);
+
+		if (tcpcp_inet_addr_type(v4addr) != RTN_LOCAL)
+			return -EADDRNOTAVAIL;
+
+	} else if (addr_type & IPV6_ADDR_LINKLOCAL) {
+		/* link local address. */
+		if (scope_id != 0)
+			/* override any existing binding,
+			 * if another one is supplied by user. */
+			sk->sk_bound_dev_if = scope_id;
+		/* @@@ for DEBUG @@@ */
+		DPRINTK("TCPCP : %s : sk->sk_bound_dev_if=%u\n",
+			__FUNCTION__, sk->sk_bound_dev_if);
+
+		/* binding to link-local address requires an interface. */
+		if (sk->sk_bound_dev_if == 0)
+			return -EINVAL;
+
+		/* IPv4 address of the socket is invalid.
+		 * only the unspecified and mapped address have a IPv4
+		 * equivalent. */
+		v4addr = LOOPBACK4_IPV6;
+		/* @@@ for DEBUG @@@ */
+		DPRINTK("TCPCP : %s : v4addr=0x%x\n", __FUNCTION__, v4addr);
+	}
+
+	/* set IPv4 source address. */
+	inet->rcv_saddr = v4addr;
+	inet->saddr = v4addr;
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : v4addr         =0x%x\n",
+		__FUNCTION__, v4addr);
+	DPRINTK("TCPCP : %s : inet->rcv_saddr=0x%x\n",
+		__FUNCTION__, inet->rcv_saddr);
+	DPRINTK("TCPCP : %s : inet->saddr    =0x%x\n",
+		__FUNCTION__, inet->saddr);
+
+	/* set IPv6 source address. */
+	ipv6_addr_copy(&(inet6->rcv_saddr), &ip_src);
+	ipv6_addr_copy(&(inet6->saddr), &ip_src);
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : inet6->rcv_saddr=%04x:%04x:%04x:%04x:"
+		"%04x:%04x:%04x:%04x\n", __FUNCTION__,
+		ntohs(inet6->rcv_saddr.s6_addr16[0]),
+		ntohs(inet6->rcv_saddr.s6_addr16[1]),
+		ntohs(inet6->rcv_saddr.s6_addr16[2]),
+		ntohs(inet6->rcv_saddr.s6_addr16[3]),
+		ntohs(inet6->rcv_saddr.s6_addr16[4]),
+		ntohs(inet6->rcv_saddr.s6_addr16[5]),
+		ntohs(inet6->rcv_saddr.s6_addr16[6]),
+		ntohs(inet6->rcv_saddr.s6_addr16[7]));
+	DPRINTK("TCPCP : %s : inet6->saddr    =%04x:%04x:%04x:%04x:"
+		"%04x:%04x:%04x:%04x\n", __FUNCTION__,
+		ntohs(inet6->saddr.s6_addr16[0]),
+		ntohs(inet6->saddr.s6_addr16[1]),
+		ntohs(inet6->saddr.s6_addr16[2]),
+		ntohs(inet6->saddr.s6_addr16[3]),
+		ntohs(inet6->saddr.s6_addr16[4]),
+		ntohs(inet6->saddr.s6_addr16[5]),
+		ntohs(inet6->saddr.s6_addr16[6]),
+		ntohs(inet6->saddr.s6_addr16[7]));
+
+	/* set TCP source port. */
+	inet->sport = htons(snum);
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : inet->sport=%u\n", __FUNCTION__, inet->sport);
+
+	/* initialize IPv4 destination address and TCP destination port. */
+	inet->daddr = 0;
+	inet->dport = 0;
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : inet->daddr=0x%x\n", __FUNCTION__, inet->daddr);
+	DPRINTK("TCPCP : %s : inet->dport=%u\n", __FUNCTION__, inet->dport);
+
+	/* end. */
+	DPRINTK("TCPCP : %s : end.\n", __FUNCTION__);
+	return 0;
+}
+#endif /* defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE) */
+
+/**
+ * tcpcp_pre_v4bind - Step 3 : pre-processing of TCP/IPv4 bind.
+ * 
+ * This function is based on af_inet.c:inet_bind().
+ * Caller must lock socket.
+ * 
+ * [Args]
+ *   (IN) *sk     : TCP socket
+ *   (IN) *si_hdr : TCP-SI header
+ * 
+ * [Return]
+ *   0             : OK.
+ *  -EINVAL        : NG.
+ *  -EACCES        : NG.
+ *  -EADDRNOTAVAIL : NG.
+ **/
+static int tcpcp_pre_v4bind(struct sock *sk, const struct tcpcp_si_hdr *si_hdr)
+{
+	struct inet_sock *inet = inet_sk(sk);
+
+	u32 s_addr;
+	unsigned short snum;
+	int chk_addr_ret;
+
+	/* plug-in. */
+	plugin_dummy();
+
+	/* start. */
+	DPRINTK("TCPCP : %s : start. si_hdr=0x%p\n", __FUNCTION__, si_hdr);
+
+	/* check Bind hash. */
+	if (inet_csk(sk)->icsk_bind_hash != NULL)
+		return -EBADFD;
+
+	/* get IPv4 source address and TCP source port. */
+	s_addr = si_hdr->id.ip.v4.ip_src;
+	snum = ntohs(si_hdr->id.tcp_sport);
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : si_hdr->id.ip.v4.ip_src=0x%x\n",
+		__FUNCTION__, si_hdr->id.ip.v4.ip_src);
+	DPRINTK("TCPCP : %s : s_addr                 =0x%x\n",
+		__FUNCTION__, s_addr);
+	DPRINTK("TCPCP : %s : si_hdr->id.tcp_sport=%u\n",
+		__FUNCTION__, si_hdr->id.tcp_sport);
+	DPRINTK("TCPCP : %s : snum                =%u\n",
+		__FUNCTION__, snum);
+
+	/* check IPv4 source address. */
+	if (s_addr == 0) {
+		DPRINTK("TCPCP : %s : [Error] ip_src is 0.0.0.0.\n",
+			__FUNCTION__);
+		return -EINVAL;
+	}
+
+	/* get type of IPv4 source address. */
+	chk_addr_ret = tcpcp_inet_addr_type(s_addr);
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : addr_type=%d\n", __FUNCTION__, chk_addr_ret);
+
+	/* check type of IPv4 source address. */
+	if ((chk_addr_ret == RTN_MULTICAST)
+	    || (chk_addr_ret == RTN_BROADCAST)) {
+		/* TCPCP not support multicast and broadcast. */
+		DPRINTK("TCPCP : %s : [Error] type of ip_src is"
+			" multi/broadcast.\n", __FUNCTION__);
+		return -EADDRNOTAVAIL;
+	}
+
+	/* check TCP source port. */
+	if (snum == 0) {
+		DPRINTK("TCPCP : %s : [Error] tcp_sport is 0.\n", __FUNCTION__);
+		return -EINVAL;
+	}
+	if ((snum < PROT_SOCK) && (!capable(CAP_NET_BIND_SERVICE)))
+		return -EACCES;
+
+	/* set IPv4 source address. */
+	inet->rcv_saddr = inet->saddr = s_addr;
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : inet->saddr    =0x%x\n",
+		__FUNCTION__, inet->saddr);
+	DPRINTK("TCPCP : %s : inet->rcv_saddr=0x%x\n",
+		__FUNCTION__, inet->rcv_saddr);
+
+	/* set TCP source port. */
+	inet->sport = htons(snum);
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : inet->sport=%u\n", __FUNCTION__, inet->sport);
+
+	/* initialize IPv4 destination address and TCP destination port. */
+	inet->daddr = 0;
+	inet->dport = 0;
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : inet->daddr=0x%x\n", __FUNCTION__, inet->daddr);
+	DPRINTK("TCPCP : %s : inet->dport=%u\n", __FUNCTION__, inet->dport);
+
+	/* reset destination. */
+	sk_dst_reset(sk);
+	/* @@@ for DEBUG @@@ */
+	if (sk->sk_dst_cache == NULL)
+		DPRINTK("TCPCP : %s : sk->sk_dst_cache is NULL.\n",
+			__FUNCTION__);
+
+	/* end. */
+	DPRINTK("TCPCP : %s : end.\n", __FUNCTION__);
+	return 0;
+}
+
+/**
+ * tcpcp_setopt_after_bind - Step 4 : set socket options. (after pre-bind)
+ *
+ * This function is based on sock.c:sock_setsockopt(),
+ *                           ip_sockglue.c:ip_setsockopt(),
+ *                           tcp.c:tcp_setsockopt().
+ * Caller must lock socket.
+ *
+ * [Args]
+ *   (IN) *sk     : TCP socket
+ *   (IN) *si_hdr : TCP-SI header
+ **/
+static void tcpcp_setopt_after_bind(struct sock *sk,
+				    const struct tcpcp_si_hdr *si_hdr)
+{
+	struct inet_sock *inet = inet_sk(sk);
+	struct tcp_sock *tp = tcp_sk(sk);
+	struct ip_options *opt = NULL;
+	int valbool;
+	uint8_t val8;
+	uint16_t val16;
+	int error;
+
+	/* plug-in. */
+	plugin_dummy();
+
+	/* start. */
+	DPRINTK("TCPCP : %s : start. sk=0x%p, si_hdr=0x%p\n",
+		__FUNCTION__, sk, si_hdr);
+
+	/*
+	 * set socket options. (socket)
+	 */
+
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : sk->sk_flags=%lu\n",
+		__FUNCTION__, sk->sk_flags);
+
+	/* set SO_KEEPOPEN flag. */
+	valbool = (si_hdr->sockopt.sk.flags & TCPCP_SIE_SOCK_KEEPOPEN);
+	tcpcp_set_keepalive(sk, valbool);
+	sock_valbool_flag(sk, SOCK_KEEPOPEN, valbool);
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : sk->sk_flags=%lu\n",
+		__FUNCTION__, sk->sk_flags);
+
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : si_hdr->id.ip_version=%u\n",
+		__FUNCTION__, si_hdr->id.ip_version);
+
+	if (si_hdr->id.ip_version == 4) {
+		/*
+		 * set socket options (IPv4)
+		 */
+
+		/* set IP options. */
+		val8 = si_hdr->sockopt.ip.v4.opt_len;
+		/* @@@ for DEBUG @@@ */
+		DPRINTK("TCPCP : %s : si_hdr->sockopt.ip.v4.opt_len=%u\n",
+			  __FUNCTION__, si_hdr->sockopt.ip.v4.opt_len);
+
+		if (val8 <= 40) {
+			/* copy IP options. */
+			error = tcpcp_ip_options_get(&opt,
+				(unsigned char *)si_hdr->sockopt.ip.v4.opt_data,
+				val8);
+			/* @@@ for DEBUG @@@ */ 
+			DPRINTK("TCPCP : %s : after tcpcp_ip_options_get."
+				" error=%d\n", __FUNCTION__, error);
+
+			if (error == 0) {
+				if (inet->opt) {
+					tp->ext_header_len -= inet->opt->optlen;
+					/* @@@ for DEBUG @@@ */
+					DPRINTK("TCPCP : %s : inet->opt->"
+						"optlen=%u\n",
+						__FUNCTION__,
+						inet->opt->optlen);
+
+				}
+				if (opt) {
+					tp->ext_header_len += opt->optlen;
+					/* @@@ for DEBUG @@@ */
+					DPRINTK("TCPCP : %s : opt->optlen=%u\n",
+						__FUNCTION__, opt->optlen);
+				}
+				/* @@@ for DEBUG @@@ */
+				DPRINTK("TCPCP : %s : inet->opt=0x%p\n",
+					__FUNCTION__, inet->opt);
+				DPRINTK("TCPCP : %s : opt      =0x%p\n",
+					__FUNCTION__, opt);
+				DPRINTK("TCPCP : %s : tp->ext_header_len=%u\n",
+					__FUNCTION__, tp->ext_header_len);
+
+				/* change IP options. */ 
+				opt = xchg(&inet->opt, opt); 
+				/* @@@ for DEBUG @@@ */
+				DPRINTK("TCPCP : %s : inet->opt=0x%p\n",
+					__FUNCTION__, inet->opt);
+				DPRINTK("TCPCP : %s : opt      =0x%p\n",
+					__FUNCTION__, opt);
+
+				if (opt) 
+					kfree(opt); 
+			}
+		}
+	}
+
+	/*
+	 * set socket options. (TCP)
+	 */
+
+	/* disable Nagle algorithm ? */
+	tp->nonagle = si_hdr->sockopt.tcp.nonagle;
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : si_hdr->sockopt.tcp.nonagle=%u\n",
+		__FUNCTION__, si_hdr->sockopt.tcp.nonagle);
+	DPRINTK("TCPCP : %s : tp->nonagle                =%u\n",
+		__FUNCTION__, tp->nonagle);
+
+	/* set num of allowed keep alive probes. */
+	val8 = si_hdr->sockopt.tcp.keepcnt;
+	if (val8 <= MAX_TCP_KEEPCNT)
+		tp->keepalive_probes = val8;
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : si_hdr->sockopt.tcp.keepcnt=%u\n",
+		__FUNCTION__, si_hdr->sockopt.tcp.keepcnt);
+	DPRINTK("TCPCP : %s : val8                       =%u\n",
+		__FUNCTION__, val8);
+	DPRINTK("TCPCP : %s : tp->keepalive_probes       =%u\n",
+		__FUNCTION__, tp->keepalive_probes);
+
+	/* set time before keep alive takes place. */
+	val16 = ntohs(si_hdr->sockopt.tcp.keepidle);
+	if (val16 <= MAX_TCP_KEEPIDLE)
+		tp->keepalive_time = val16 * HZ;
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : si_hdr->sockopt.tcp.keepidle=%u\n",
+		__FUNCTION__, si_hdr->sockopt.tcp.keepidle);
+	DPRINTK("TCPCP : %s : val16                       =%u\n",
+		__FUNCTION__, val16);
+	DPRINTK("TCPCP : %s : tp->keepalive_time/HZ       =%u\n",
+		__FUNCTION__, tp->keepalive_time / HZ);
+
+	/* set time interval between keep alive probes. */
+	val16 = ntohs(si_hdr->sockopt.tcp.keepintvl);
+	if (val16 <= MAX_TCP_KEEPINTVL)
+		tp->keepalive_intvl = val16 * HZ;
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : si_hdr->sockopt.tcp.keepintvl=%u\n",
+		__FUNCTION__, si_hdr->sockopt.tcp.keepintvl);
+	DPRINTK("TCPCP : %s : val16                        =%u\n",
+		__FUNCTION__, val16);
+	DPRINTK("TCPCP : %s : tp->keepalive_intvl/HZ       =%u\n",
+		__FUNCTION__, tp->keepalive_intvl / HZ);
+
+	/* end. */
+	DPRINTK("TCPCP : %s : end.\n", __FUNCTION__);
+	return;
+}
+
+/**
+ * tcpcp_init_connect - initialize TCP.
+ *
+ * This function is based on tcp_output.c:tcp_connect_init(),
+ *                           tcp_output.c:tcp_connect().
+ * 
+ * [Args]
+ *   (IN) *sk     : TCP socket
+ *   (IN) *si_hdr : TCP-SI header
+ **/
+static void tcpcp_init_connect(struct sock *sk,
+			       const struct tcpcp_si_hdr *si_hdr)
+{
+	struct tcp_sock *tp = tcp_sk(sk);
+	__u8 rcv_wscale;
+	/* plug-in. */
+	plugin_dummy();
+
+	/* start. */
+	DPRINTK("TCPCP : %s : start. si_hdr=0x%p\n", __FUNCTION__, si_hdr);
+
+	/*
+	 * it's based on tcp_output.c:tcp_connect_init().
+	 */
+
+	/* initialize tcp_header_len. */
+	tp->tcp_header_len = sizeof(struct tcphdr) +
+		(sysctl_tcp_timestamps ? TCPOLEN_TSTAMP_ALIGNED : 0);
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : sysctl_tcp_timestamps=%u\n",
+		__FUNCTION__, sysctl_tcp_timestamps);
+	DPRINTK("TCPCP : %s : tp->tcp_header_len=%u\n",
+		__FUNCTION__, tp->tcp_header_len);
+
+	/* initialize max_window. */
+	tp->max_window = 0;
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : tp->max_window=%u\n",
+		__FUNCTION__, tp->max_window);
+
+	/* set advmss. */
+	tp->advmss = ntohs(si_hdr->fixgen.snd_mss); 
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : si_hdr->fixgen.snd_mss=%u\n",
+		__FUNCTION__, si_hdr->fixgen.snd_mss);
+	DPRINTK("TCPCP : %s : tp->advmss            =%u\n",
+		__FUNCTION__, tp->advmss);
+
+	/* .... */
+	tcp_initialize_rcv_mss(sk);
+	tcpcp_ca_init(tp);
+
+	/* initialize window. */
+	tcpcp_select_initial_window(tcp_full_space(sk),
+				  tp->advmss - (tp->rx_opt.ts_recent_stamp ?
+					tp->tcp_header_len
+					- sizeof(struct tcphdr) : 0),
+				  &(tp->rcv_wnd),
+				  &(tp->window_clamp),
+				  sysctl_tcp_window_scaling,
+				  &rcv_wscale);
+	tp->rx_opt.rcv_wscale = rcv_wscale;
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : tp->ack.rcv_mss =%u\n",
+		__FUNCTION__, tp->ack.rcv_mss);
+	DPRINTK("TCPCP : %s : tp->adv_cong    =%u\n",
+		__FUNCTION__, tp->adv_cong);
+	DPRINTK("TCPCP : %s : tp->rcv_wnd     =%u\n",
+		__FUNCTION__, tp->rcv_wnd);
+	DPRINTK("TCPCP : %s : tp->window_clamp=%u\n",
+		__FUNCTION__, tp->window_clamp);
+	DPRINTK("TCPCP : %s : tp->rcv_wscale=%u\n",
+		__FUNCTION__, tp->rcv_wscale);
+	/* overwrite rcv_wnd and set rcv_ssthresh. */
+	tp->rcv_wnd = ntohl(si_hdr->vargen.rcv_wnd);
+	tp->rcv_ssthresh = tp->rcv_wnd;
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : si_hdr->vargen.rcv_wnd=%u\n",
+		__FUNCTION__, si_hdr->vargen.rcv_wnd);
+	DPRINTK("TCPCP : %s : tp->rcv_wnd           =%u\n",
+		__FUNCTION__, tp->rcv_wnd);
+	DPRINTK("TCPCP : %s : tp->rcv_ssthresh      =%u\n",
+		__FUNCTION__, tp->rcv_ssthresh);
+
+	/* overwrite rcv_wscale. */
+	tp->rx_opt.rcv_wscale = si_hdr->fixgen.rcv_wscale;
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : si_hdr->fixgen.rcv_wscale=%d\n",
+		__FUNCTION__, si_hdr->fixgen.rcv_wscale);
+	DPRINTK("TCPCP : %s : tp->rcv_wscale           =%d\n",
+		__FUNCTION__, tp->rcv_wscale);
+
+
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : sk->sk_flags=%lu\n",
+		__FUNCTION__, sk->sk_flags);
+
+	/* initialize sk_err. */
+	sk->sk_err = 0;
+	sock_reset_flag(sk, SOCK_DONE);
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : sk->sk_err=%d\n",
+		__FUNCTION__, sk->sk_err);
+	DPRINTK("TCPCP : %s : sk->sk_flags=%lu\n",
+		__FUNCTION__, sk->sk_flags);
+
+	/* initialize snd_wnd, snd_wl1, snd_una, snd_sml, rcv_nxt, rcv_wup and
+	 * copied_seq. */
+	tp->snd_wnd = 0;
+	tp->snd_wl1 = tp->write_seq;
+	tp->snd_una = tp->write_seq;
+	tp->snd_sml = tp->write_seq;
+	tp->rcv_nxt = 0;
+	tp->rcv_wup = 0;
+	tp->copied_seq = 0;
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : tp->snd_wnd   =%u\n",
+		__FUNCTION__, tp->snd_wnd);
+	DPRINTK("TCPCP : %s : tp->write_seq =%u\n",
+		__FUNCTION__, tp->write_seq);
+	DPRINTK("TCPCP : %s : tp->snd_wl1   =%u\n",
+		__FUNCTION__, tp->snd_wl1);
+	DPRINTK("TCPCP : %s : tp->snd_una   =%u\n",
+		__FUNCTION__, tp->snd_una);
+	DPRINTK("TCPCP : %s : tp->snd_sml   =%u\n",
+		__FUNCTION__, tp->snd_sml);
+	DPRINTK("TCPCP : %s : tp->rcv_nxt   =%u\n",
+		__FUNCTION__, tp->rcv_nxt);
+	DPRINTK("TCPCP : %s : tp->rcv_wup   =%u\n",
+		__FUNCTION__, tp->rcv_wup);
+	DPRINTK("TCPCP : %s : tp->copied_seq=%u\n",
+		__FUNCTION__, tp->copied_seq);
+
+	/* initialize rto, retransmits. */
+	inet_csk(sk)->icsk_rto = TCP_TIMEOUT_INIT;
+	inet_csk(sk)->icsk_retransmits = 0;
+	tcpcp_clear_retrans(tp);
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : tp->rto=%u\n",
+		__FUNCTION__, tp->rto);
+	DPRINTK("TCPCP : %s : tp->retransmits=%d\n",
+		__FUNCTION__, tp->retransmits);
+	DPRINTK("TCPCP : %s : tp->undo_marker=%u\n",
+		__FUNCTION__, tp->undo_marker);
+	DPRINTK("TCPCP : %s : tp->undo_retrans=%d\n",
+		__FUNCTION__, tp->undo_retrans);
+	DPRINTK("TCPCP : %s : tp->left_out.val   =%u\n",
+		__FUNCTION__, tp->left_out.val);
+	DPRINTK("TCPCP : %s : tp->retrans_out.val=%u\n",
+		__FUNCTION__, tp->retrans_out.val);
+	DPRINTK("TCPCP : %s : tp->fackets_out.val=%u\n",
+		__FUNCTION__, tp->fackets_out.val);
+	DPRINTK("TCPCP : %s : tp->sacked_out.val =%u\n",
+		__FUNCTION__, tp->sacked_out.val);
+	DPRINTK("TCPCP : %s : tp->lost_out.val   =%u\n",
+		__FUNCTION__, tp->lost_out.val);
+
+	/*
+	 * it's based on tcp_input.c:tcp_connect().
+	 */
+
+	/* initialize snd_nxt, pushed_seq. */
+	tp->snd_nxt = tp->write_seq;
+	tp->pushed_seq = tp->write_seq;
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : tp->write_seq =%u\n",
+		__FUNCTION__, tp->write_seq);
+	DPRINTK("TCPCP : %s : tp->snd_nxt   =%u\n",
+		__FUNCTION__, tp->snd_nxt);
+	DPRINTK("TCPCP : %s : tp->pushed_seq=%u\n",
+		__FUNCTION__, tp->pushed_seq);
+
+	/* end. */
+	DPRINTK("TCPCP : %s : end.\n", __FUNCTION__);
+	return;
+}
+
+#if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)
+/**
+ * tcpcp_pre_v6connect - Step 5 : pre-processing of TCP/IPv6 connect.
+ *
+ * This function is based on tcp_ipv6.c:tcp_v6_connect().
+ * Caller must lock socket.
+ *
+ * [Args]
+ *   (IN) *sk     : TCP socket
+ *   (IN) *si_hdr : TCP-SI header
+ * 
+ * [Return]
+ *   0            : OK.
+ *  -EINVAL       : NG.
+ *  -EAFNOSUPPORT :
+ *  -ENETUNREACH  :
+ **/
+static int tcpcp_pre_v6connect(struct sock *sk,
+			       const struct tcpcp_si_hdr *si_hdr)
+{
+	struct inet_sock *inet = inet_sk(sk);
+	struct ipv6_pinfo *inet6 = inet6_sk(sk);
+	struct tcp_sock *tp = tcp_sk(sk);
+	struct in6_addr ip_dst;
+	__u32 scope_id;
+	int addr_type;
+
+	/* plug-in. */
+	plugin_dummy();
+
+	/* start. */
+	DPRINTK("TCPCP : %s : start. sk=0x%p, si_hdr=0x%p\n",
+		__FUNCTION__, sk, si_hdr);
+
+	/* get IPv6 destination address. */
+	ipv6_addr_copy(&ip_dst, &(si_hdr->id.ip.v6.ip_dst));
+	scope_id = ntohl(si_hdr->id.ip.v6.scope_id);
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : ip_dst=%04x:%04x:%04x:%04x:%04x:%04x:%04x:%04x\n",
+		__FUNCTION__,
+		ntohs(ip_dst.s6_addr16[0]),
+		ntohs(ip_dst.s6_addr16[1]),
+		ntohs(ip_dst.s6_addr16[2]),
+		ntohs(ip_dst.s6_addr16[3]),
+		ntohs(ip_dst.s6_addr16[4]),
+		ntohs(ip_dst.s6_addr16[5]),
+		ntohs(ip_dst.s6_addr16[6]),
+		ntohs(ip_dst.s6_addr16[7]));
+	DPRINTK("TCPCP : %s : si_hdr->id.ip.v6.scope_id=%u\n",
+		__FUNCTION__,si_hdr->id.ip.v6.scope_id);
+	DPRINTK("TCPCP : %s : scope_id                 =%u\n",
+		__FUNCTION__, scope_id);
+
+	/* check IPv6 destination address. */
+	if (ipv6_addr_any(&ip_dst) != 0)
+		ip_dst.s6_addr[15] = 0x1;
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : ip_dst=%04x:%04x:%04x:%04x:%04x:%04x:%04x:%04x\n",
+		__FUNCTION__,
+		ntohs(ip_dst.s6_addr16[0]),
+		ntohs(ip_dst.s6_addr16[1]),
+		ntohs(ip_dst.s6_addr16[2]),
+		ntohs(ip_dst.s6_addr16[3]),
+		ntohs(ip_dst.s6_addr16[4]),
+		ntohs(ip_dst.s6_addr16[5]),
+		ntohs(ip_dst.s6_addr16[6]),
+		ntohs(ip_dst.s6_addr16[7]));
+
+	/* get type of IPv6 destination address. */
+	addr_type = ipv6_addr_type(&ip_dst);
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : addr_type=%u\n", __FUNCTION__, addr_type);
+
+	/* check tupe of IPv6 destination address. */
+	if (addr_type & IPV6_ADDR_MULTICAST)
+		return -ENETUNREACH;
+
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : sk->sk_bound_dev_if=%u\n",
+		__FUNCTION__, sk->sk_bound_dev_if);
+
+	if (addr_type & IPV6_ADDR_LINKLOCAL) {
+		if (scope_id) {
+			/* if interface is set while binding,
+			 * indices must coincide. */
+			if ((sk->sk_bound_dev_if != 0) &&
+			    (sk->sk_bound_dev_if != scope_id))
+				return -EINVAL;
+
+			sk->sk_bound_dev_if = scope_id;
+		}
+		/* @@@ for DEBUG @@@ */
+		DPRINTK("TCPCP : %s : sk->sk_bound_dev_if=%u\n",
+			__FUNCTION__, sk->sk_bound_dev_if);
+
+		/* connect to link-local address requires an interface. */
+		if (sk->sk_bound_dev_if == 0)
+			return -EINVAL;
+	}
+
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : tp->ts_recent_stamp=%lu\n",
+		__FUNCTION__, tp->ts_recent_stamp);
+	DPRINTK("TCPCP : %s : inet6->daddr=%04x:%04x:%04x:%04x:"
+		"%04x:%04x:%04x:%04x\n", __FUNCTION__,
+		ntohs(inet6->daddr.s6_addr16[0]),
+		ntohs(inet6->daddr.s6_addr16[1]),
+		ntohs(inet6->daddr.s6_addr16[2]),
+		ntohs(inet6->daddr.s6_addr16[3]),
+		ntohs(inet6->daddr.s6_addr16[4]),
+		ntohs(inet6->daddr.s6_addr16[5]),
+		ntohs(inet6->daddr.s6_addr16[6]),
+		ntohs(inet6->daddr.s6_addr16[7]));
+
+	if ((tp->rx_opt.ts_recent_stamp != 0) &&
+	    (ipv6_addr_cmp(&(inet6->daddr), &ip_dst) != 0)) {
+		/* reset inherited state. */
+		tp->rx_opt.ts_recent = 0;
+		tp->rx_opt.ts_recent_stamp = 0;
+		tp->write_seq = 0;
+	}
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : tp->ts_recent=%u\n",
+		__FUNCTION__, tp->ts_recent);
+	DPRINTK("TCPCP : %s : tp->ts_recent_stamp=%lu\n",
+		__FUNCTION__, tp->ts_recent_stamp);
+	DPRINTK("TCPCP : %s : tp->write_seq=%u\n",
+		__FUNCTION__, tp->write_seq);
+
+	/* set IPv6 destination address and TCP destination port. */
+	ipv6_addr_copy(&(inet6->daddr), &ip_dst);
+	inet->dport = si_hdr->id.tcp_dport;
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : inet6->daddr=%04x:%04x:%04x:%04x:"
+		"%04x:%04x:%04x:%04x\n", __FUNCTION__,
+		ntohs(inet6->daddr.s6_addr16[0]),
+		ntohs(inet6->daddr.s6_addr16[1]),
+		ntohs(inet6->daddr.s6_addr16[2]),
+		ntohs(inet6->daddr.s6_addr16[3]),
+		ntohs(inet6->daddr.s6_addr16[4]),
+		ntohs(inet6->daddr.s6_addr16[5]),
+		ntohs(inet6->daddr.s6_addr16[6]),
+		ntohs(inet6->daddr.s6_addr16[7]));
+	DPRINTK("TCPCP : %s : si_hdr->id.tcp_dport=%u\n",
+		__FUNCTION__, si_hdr->id.tcp_dport);
+	DPRINTK("TCPCP : %s : inet->dport         =%u\n",
+		__FUNCTION__, inet->dport);
+
+	/* set ext_header_len. */
+	tp->ext_header_len = 0;
+	if (inet6->opt != 0) {
+		tp->ext_header_len
+		    = inet6->opt->opt_flen + inet6->opt->opt_nflen;
+		/* @@@ for DEBUG @@@ */
+		DPRINTK("TCPCP : %s : inet6->opt->opt_flen =%u\n",
+			__FUNCTION__, inet6->opt->opt_flen);
+		DPRINTK("TCPCP : %s : inet6->opt->opt_nflen=%u\n",
+			__FUNCTION__, inet6->opt->opt_nflen);
+	}
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : tp->ext_header_len=%u\n",
+		__FUNCTION__, tp->ext_header_len);
+
+	/* initialize mss_clamp. */
+	tp->rx_opt.mss_clamp = IPV6_MIN_MTU - sizeof(struct tcphdr)
+				     - sizeof(struct ipv6hdr);
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : tp->mss_clamp=%u\n", __FUNCTION__, tp->mss_clamp);
+
+	/* set write_seq. */
+	tp->write_seq = ntohl(si_hdr->vargen.snd_nxt);
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : si_hdr->vargen.snd_nxt=%u\n",
+		__FUNCTION__, si_hdr->vargen.snd_nxt);
+	DPRINTK("TCPCP : %s : tp->write_seq         =%u\n",
+		__FUNCTION__, tp->write_seq);
+
+	/* initialize TCP. */
+	tcpcp_init_connect(sk, si_hdr);
+
+	/* end. */
+	DPRINTK("TCPCP : %s : end.\n", __FUNCTION__);
+	return 0;
+}
+#endif /* defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE) */
+
+/**
+ * tcpcp_pre_v4connect - Step 5 : pre-processing of TCP/IPv4 connect.
+ *
+ * This function is based on tcp_ipv4.c:tcp_v4_connect().
+ * Caller must lock socket.
+ *
+ * [Args]
+ *   (IN) *sk     : TCP socket
+ *   (IN) *si_hdr : TCP-SI header
+ * 
+ * [Return]
+ *   0 : OK.
+ **/
+static int tcpcp_pre_v4connect(struct sock *sk,
+			       const struct tcpcp_si_hdr *si_hdr)
+{
+	struct inet_sock *inet = inet_sk(sk);
+	struct tcp_sock *tp = tcp_sk(sk);
+	u32 daddr;
+
+	/* plug-in. */
+	plugin_dummy();
+
+	/* start. */
+	DPRINTK("TCPCP : %s : start. sk=0x%p, si_hdr=0x%p\n",
+		__FUNCTION__, sk, si_hdr);
+
+	/* get IPv4 destination address. */
+	daddr = si_hdr->id.ip.v4.ip_dst;
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : si_hdr->id.ip.v4.ip_dst=0x%x\n",
+		__FUNCTION__, si_hdr->id.ip.v4.ip_dst);
+	DPRINTK("TCPCP : %s : daddr                  =0x%x\n",
+		__FUNCTION__, daddr);
+
+	inet->rcv_saddr = inet->saddr;
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : inet->saddr    =0x%x\n",
+		__FUNCTION__, inet->saddr);
+	DPRINTK("TCPCP : %s : inet->rcv_saddr=0x%x\n",
+		__FUNCTION__, inet->rcv_saddr);
+
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : tp->ts_recent_stamp=%lu\n",
+		__FUNCTION__, tp->ts_recent_stamp);
+	DPRINTK("TCPCP : %s : inet->daddr=0x%x\n",
+		__FUNCTION__, inet->daddr);
+
+	if ((tp->rx_opt.ts_recent_stamp != 0) && (inet->daddr != daddr)) {
+		/* reset inherited state. */
+		tp->rx_opt.ts_recent       = 0;
+		tp->rx_opt.ts_recent_stamp = 0;
+		tp->write_seq       = 0;
+	}
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : tp->ts_recent=%u\n",
+		__FUNCTION__, tp->ts_recent);
+	DPRINTK("TCPCP : %s : tp->ts_recent_stamp=%lu\n",
+		__FUNCTION__, tp->ts_recent_stamp);
+	DPRINTK("TCPCP : %s : tp->write_seq=%u\n",
+		__FUNCTION__, tp->write_seq);
+
+	/* set IPv4 destination address and TCP destination port. */
+	inet->daddr = daddr;
+	inet->dport = si_hdr->id.tcp_dport;
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : inet->daddr=0x%x\n",
+		__FUNCTION__, inet->daddr);
+	DPRINTK("TCPCP : %s : si_hdr->id.tcp_dport=%u\n",
+		__FUNCTION__, si_hdr->id.tcp_dport);
+	DPRINTK("TCPCP : %s : inet->dport         =%u\n",
+		__FUNCTION__, inet->dport);
+
+	/* initialize ext_header_len. */
+	tp->ext_header_len = 0;
+	if (inet->opt != 0) {
+		tp->ext_header_len = inet->opt->optlen;
+		/* @@@ for DEBUG @@@ */
+		DPRINTK("TCPCP : %s : inet->opt->optlen=%u\n",
+			__FUNCTION__, inet->opt->optlen);
+	}
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : tp->ext_header_len=%u\n",
+		__FUNCTION__, tp->ext_header_len);
+
+	/* initialize mss_clamp. */
+	tp->rx_opt.mss_clamp = 536;
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : tp->mss_clamp=%u\n", __FUNCTION__, tp->mss_clamp);
+
+	/* set write_seq. */
+	tp->write_seq = ntohl(si_hdr->vargen.snd_nxt);
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : si_hdr->vargen.snd_nxt=%u\n",
+		__FUNCTION__, si_hdr->vargen.snd_nxt);
+	DPRINTK("TCPCP : %s : tp->write_seq         =%u\n",
+		__FUNCTION__, tp->write_seq);
+
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : jiffies (1)=%lu\n", __FUNCTION__, jiffies);
+
+	/* set IPv4 socket ID. */
+	inet->id = tp->write_seq ^ jiffies;
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : jiffies (2)=%lu\n", __FUNCTION__, jiffies);
+	DPRINTK("TCPCP : %s : tp->write_seq=%u\n",
+		__FUNCTION__, tp->write_seq);
+	DPRINTK("TCPCP : %s : inet->id=%u\n", __FUNCTION__, inet->id);
+
+	/* initialize TCP. */
+	tcpcp_init_connect(sk, si_hdr);
+
+	/* end. */
+	DPRINTK("TCPCP : %s : end.\n", __FUNCTION__);
+	return 0;
+}
+
+/**
+ * tcpcp_recover_si_hdr - Step 6 : recover TCP-SI header.
+ *
+ * This function is based on tcp_input.c:tcp_rcv_synsent_state_process(),
+ *                           tcp_input.c:tcp_parse_options().
+ * Caller must lock socket.
+ *
+ * [Args]
+ *   (IN) *sk     : TCP socket
+ *   (IN) *si_hdr : TCP-SI header
+ **/
+static void tcpcp_recover_si_hdr(struct sock *sk,
+				 const struct tcpcp_si_hdr *si_hdr)
+{
+	struct tcp_sock *tp = tcp_sk(sk);
+
+	/* plug-in. */
+	plugin_dummy();
+
+	/* start. */
+	DPRINTK("TCPCP : %s : start. sk=0x%p, si_hdr=0x%p\n",
+		__FUNCTION__, sk, si_hdr);
+
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : sk->sk_sndbuf=%u\n",
+		__FUNCTION__, sk->sk_sndbuf);
+	DPRINTK("TCPCP : %s : sk->sk_rcvbuf=%u\n",
+		__FUNCTION__, sk->sk_rcvbuf);
+
+	/*
+	 * it's based on tcp_input.c:tcp_parse_options().
+	 */
+
+	/* case TCPOPT_MSS. */
+	tp->rx_opt.mss_clamp = ntohs(si_hdr->fixgen.rcv_mss);
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : si_hdr->fixgen.rcv_mss=%d\n",
+		__FUNCTION__, si_hdr->fixgen.rcv_mss);
+	DPRINTK("TCPCP : %s : tp->mss_clamp         =%d\n",
+		__FUNCTION__, tp->mss_clamp);
+
+	/* case TCPOPT_WINDOW. */
+	tp->rx_opt.wscale_ok = !!(si_hdr->fixgen.tcp_flags & TCPI_OPT_WSCALE);
+	tp->rx_opt.snd_wscale = si_hdr->fixgen.snd_wscale;
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : si_hdr->fixgen.tcp_flags=%u\n",
+		__FUNCTION__, si_hdr->fixgen.tcp_flags);
+	DPRINTK("TCPCP : %s : tp->wscale_ok=%d\n",
+		__FUNCTION__, tp->wscale_ok);
+	DPRINTK("TCPCP : %s : si_hdr->fixgen.snd_wscale=%u\n",
+		__FUNCTION__,si_hdr->fixgen.snd_wscale);
+	DPRINTK("TCPCP : %s : tp->snd_wscale           =%d\n",
+		__FUNCTION__, tp->snd_wscale);
+
+	if (tp->rx_opt.snd_wscale > 14)
+		tp->rx_opt.snd_wscale = 14;
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : tp->snd_wscale=%d\n",
+		__FUNCTION__, tp->snd_wscale);
+
+	/* case TCPOPT_TIMESTAMP. */
+	tp->rx_opt.tstamp_ok = !!(si_hdr->fixgen.tcp_flags & TCPI_OPT_TIMESTAMPS);
+
+	/* case TCPOPT_SACK_PERM. */
+	tp->rx_opt.sack_ok = !!(si_hdr->fixgen.tcp_flags & TCPI_OPT_SACK);
+
+	/*
+	 * it's based on tcp_input.c:tcp_rcv_synsent_state_process().
+	 */
+
+	/* set ECN flags. */
+	tp->ecn_flags
+	    = si_hdr->fixgen.tcp_flags & TCPI_OPT_ECN ? TCP_ECN_OK : 0;
+	if (tp->ecn_flags & TCP_ECN_OK)
+		sock_set_flag(sk, SOCK_NO_LARGESEND);
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : si_hdr->fixgen.tcp_flags=%u\n",
+		__FUNCTION__, si_hdr->fixgen.tcp_flags);
+	DPRINTK("TCPCP : %s : tp->tstamp_ok           =%u\n",
+		__FUNCTION__, tp->tstamp_ok);
+	DPRINTK("TCPCP : %s : tp->sack_ok             =%u\n",
+		__FUNCTION__, tp->sack_ok);
+	DPRINTK("TCPCP : %s : tp->ecn_flags           =%u\n",
+		__FUNCTION__, tp->ecn_flags);
+	DPRINTK("TCPCP : %s : sk->sk_no_largesend=%u\n",
+		__FUNCTION__, sk->sk_no_largesend);
+
+	/* set rcv_nxt and initialize rcv_wup, snd_wl1. */
+	tp->rcv_nxt = ntohl(si_hdr->vargen.rcv_nxt);
+	tp->rcv_wup = tp->rcv_nxt;
+	tp->snd_wl1 = tp->rcv_nxt;
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : si_hdr->vargen.rcv_nxt=%u\n",
+		__FUNCTION__, si_hdr->vargen.rcv_nxt);
+	DPRINTK("TCPCP : %s : tp->rcv_nxt           =%u\n",
+		__FUNCTION__, tp->rcv_nxt);
+	DPRINTK("TCPCP : %s : tp->rcv_wup           =%u\n",
+		__FUNCTION__, tp->rcv_wup);
+	DPRINTK("TCPCP : %s : tp->snd_wl1           =%u\n",
+		__FUNCTION__, tp->snd_wl1);
+
+	/* set snd_wnd max_window. */
+	tp->snd_wnd = ntohl(si_hdr->vargen.snd_wnd);
+	tp->max_window = tp->snd_wnd;
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : si_hdr->vargen.snd_wnd=%u\n",
+		__FUNCTION__, si_hdr->vargen.snd_wnd);
+	DPRINTK("TCPCP : %s : tp->snd_wnd           =%u\n",
+		__FUNCTION__, tp->snd_wnd);
+	DPRINTK("TCPCP : %s : tp->max_window        =%u\n",
+		__FUNCTION__, tp->max_window);
+
+	tp->tcp_header_len = sizeof(struct tcphdr);
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : tp->tcp_header_len=%d\n",
+		__FUNCTION__, tp->tcp_header_len);
+
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : tp->tstamp_ok=%u\n", __FUNCTION__, tp->tstamp_ok);
+
+	if (tp->rx_opt.tstamp_ok) {
+		tp->tcp_header_len += TCPOLEN_TSTAMP_ALIGNED;
+		/* @@@ for DEBUG @@@ */
+		DPRINTK("TCPCP : %s : tp->tcp_header_len    =%d\n",
+			__FUNCTION__, tp->tcp_header_len);
+
+		/* @@@ for DEBUG @@@ */
+		DPRINTK("TCPCP : %s : si_hdr->vargen.ts_recent=%u\n",
+			__FUNCTION__, si_hdr->vargen.ts_recent);
+
+		/* it's based on tcp_input.c:tcp_store_ts_recent(). */
+		if (si_hdr->vargen.ts_recent) {
+			tp->rx_opt.ts_recent= ntohl(si_hdr->vargen.ts_recent);
+			tp->rx_opt.ts_recent_stamp = xtime.tv_sec;
+		}
+		/* @@@ for DEBUG @@@ */
+		DPRINTK("TCPCP : %s : tp->ts_recent=%u\n",
+			__FUNCTION__, tp->ts_recent);
+		DPRINTK("TCPCP : %s : tp->ts_recent_stamp=%lu\n",
+			__FUNCTION__, tp->ts_recent_stamp);
+		DPRINTK("TCPCP : %s : xtime.tv_sec       =%lu\n",
+			__FUNCTION__, xtime.tv_sec);
+	}
+
+	/* initialize copied_seq. */
+	tp->copied_seq = tp->rcv_nxt;
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : tp->copied_seq=%u\n",
+		__FUNCTION__, tp->copied_seq);
+	DPRINTK("TCPCP : %s : tp->rcv_nxt   =%u\n",
+		__FUNCTION__, tp->rcv_nxt);
+
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : tcp_time_stamp (1)   =%u\n",
+		__FUNCTION__, tcp_time_stamp);
+
+	/* prevent spurious tcp_cwnd_restart() on first data packet. */
+	tp->lsndtime = tcp_time_stamp;
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : tcp_time_stamp (2)   =%u\n",
+		__FUNCTION__, tcp_time_stamp);
+	DPRINTK("TCPCP : %s : tp->lsndtime         =%u\n",
+		__FUNCTION__, tp->lsndtime);
+
+	/* .... */
+	tcpcp_init_buffer_space(sk);
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : tcp_time_stamp (3)   =%u\n",
+		__FUNCTION__, tcp_time_stamp);
+	DPRINTK("TCPCP : %s : si_hdr->vargen.ts_gen=%u\n",
+		__FUNCTION__, si_hdr->vargen.ts_gen);
+
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : sk->sk_sndbuf=%u\n",
+		__FUNCTION__, sk->sk_sndbuf);
+	DPRINTK("TCPCP : %s : sk->sk_rcvbuf=%u\n",
+		__FUNCTION__, sk->sk_rcvbuf);
+
+	/* end. */
+	DPRINTK("TCPCP : %s : end.\n", __FUNCTION__);
+	return;
+}
+
+/**
+ * tcpcp_recover_sndbuf - Step 7 : recover write_queue.
+ *
+ * This function is based on tcp.c:tcp_sendmsg(),
+ *                           tcp.c:skb_entail(),
+ *                           TCPCP-9:tcpcp_buffers(),
+ *                           TCPCP-9:tcpcp_send_buf().
+ * Caller must lock socket.
+ *
+ * [Args]
+ *   (IN) *sk      : TCP socket
+ *   (IN) *snd_buf : ....
+ *
+ * [Return]
+ *   0      : OK.
+ *  -ENOMEM : NG.
+ *  -EINVAL : NG.
+ **/
+static int tcpcp_recover_sndbuf(struct sock *sk,
+				const struct tcpcp_si_skb_buf *snd_buf)
+{
+	struct tcp_sock *tp = tcp_sk(sk);
+	struct tcpcp_si_skb *si_skb;
+	unsigned int cnt;
+
+#ifdef CONFIG_TCPCP_DEBUG
+	/* @@@ for printing payload. (for DEBUG) @@@ */
+	unsigned int cnt1, cnt2 = 0;
+	char *pload_data;
+#endif
+
+	/* plug-in. */
+	plugin_dummy();
+
+	/* start. */
+	DPRINTK("TCPCP : %s : start. sk=0x%p, snd_buf=0x%p\n",
+		__FUNCTION__, sk, snd_buf);
+
+	/* purge write_queue. */
+	sk_stream_writequeue_purge(sk);
+
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : snd_buf->buf_len=%u\n",
+		__FUNCTION__, snd_buf->buf_len);
+	DPRINTK("TCPCP : %s : snd_buf->skb_cnt=%u\n",
+		__FUNCTION__, snd_buf->skb_cnt);
+
+	/* check send buffer. */
+	if ((snd_buf->buf_len == 0) || (snd_buf->skb_cnt == 0)) {
+		DPRINTK("TCPCP : %s : end.\n", __FUNCTION__);
+		return 0;
+	}
+
+	si_skb = (struct tcpcp_si_skb *)snd_buf->si_skb;
+
+	for (cnt = 0; cnt < snd_buf->skb_cnt; cnt++) {
+		struct sk_buff *skb;
+		unsigned int data_len;
+		uint32_t seq;
+
+		/* @@@ for DEBUG @@@ */
+		DPRINTK("TCPCP : %s : cnt=%u\n", __FUNCTION__, cnt);
+
+		/*
+		 * it's based on tcp.c:tcp_sendmsg().
+		 */
+
+		/* @@@ for DEBUG @@@ */
+		DPRINTK("TCPCP : %s : before sk_stream_memory_free.\n",
+			__FUNCTION__);
+
+		/* check free of write_queue. */
+		if (!sk_stream_memory_free(sk)) {
+			DPRINTK("TCPCP : %s : [Error] write_queue is not"
+				" free.\n", __FUNCTION__);
+			return -ENOMEM;
+		}
+
+		/* get data_len. */
+		data_len = ntohs(si_skb->length);
+		/* @@@ for DEBUG @@@ */
+		DPRINTK("TCPCP : %s : si_skb->length=%u\n",
+			__FUNCTION__, si_skb->length);
+		DPRINTK("TCPCP : %s : data_len      =%u\n",
+			__FUNCTION__, data_len);
+
+		/* allocate socket buffer. (TCP header and data of packet) */
+		skb = sk_stream_alloc_pskb(sk, data_len, 0, sk->sk_allocation);
+		if (!skb) {
+			DPRINTK("TCPCP : %s : [Error] can't allocate skb.\n",
+				__FUNCTION__);
+			return -ENOMEM;
+		}
+		/* @@@ for DEBUG @@@ */
+		DPRINTK("TCPCP : %s : after sk_stream_alloc_pskb.\n",
+			__FUNCTION__);
+ 		DPRINTK("TCPCP : %s : skb->head=0x%p\n",
+			__FUNCTION__, skb->head);
+ 		DPRINTK("TCPCP : %s : skb->data=0x%p\n",
+			__FUNCTION__, skb->data);
+ 		DPRINTK("TCPCP : %s : skb->tail=0x%p\n",
+			__FUNCTION__, skb->tail);
+		DPRINTK("TCPCP : %s : skb->len=%u\n", __FUNCTION__, skb->len);
+
+		/*
+		 * it's based on tcp.c:skb_entail().
+		 */
+
+		skb->csum = 0;
+		seq = ntohl(si_skb->seq);
+		TCP_SKB_CB(skb)->seq = seq;
+		TCP_SKB_CB(skb)->end_seq = seq + data_len
+			+ ((si_skb->flags & TCPCB_FLAG_SYN) ? 1 : 0)
+			+ ((si_skb->flags & TCPCB_FLAG_FIN) ? 1 : 0);
+		TCP_SKB_CB(skb)->flags = si_skb->flags;
+		TCP_SKB_CB(skb)->sacked = si_skb->sacked;
+		skb_shinfo(skb)->tso_segs = ntohs(si_skb->tso_segs);
+		skb_shinfo(skb)->tso_size = ntohs(si_skb->tso_size);
+		/* @@@ for DEBUG @@@ */
+		DPRINTK("TCPCP : %s : skb->csum=%u\n", __FUNCTION__, skb->csum);
+		DPRINTK("TCPCP : %s : si_skb->seq             =%u\n",
+                        __FUNCTION__, si_skb->seq);
+		DPRINTK("TCPCP : %s : TCP_SKB_CB(skb)->seq    =%u\n",
+			__FUNCTION__, TCP_SKB_CB(skb)->seq);
+		DPRINTK("TCPCP : %s : TCP_SKB_CB(skb)->end_seq=%u\n",
+			__FUNCTION__, TCP_SKB_CB(skb)->end_seq);
+		DPRINTK("TCPCP : %s : si_skb->flags         =%u\n",
+			__FUNCTION__, si_skb->flags);
+		DPRINTK("TCPCP : %s : TCP_SKB_CB(skb)->flags=%u\n",
+			__FUNCTION__, TCP_SKB_CB(skb)->flags);
+		DPRINTK("TCPCP : %s : si_skb->sacked         =%u\n",
+			__FUNCTION__, si_skb->sacked);
+		DPRINTK("TCPCP : %s : TCP_SKB_CB(skb)->sacked=%u\n",
+			__FUNCTION__, TCP_SKB_CB(skb)->sacked);
+		DPRINTK("TCPCP : %s : si_skb->tso_segs         =%u\n",
+			__FUNCTION__, si_skb->tso_segs);
+		DPRINTK("TCPCP : %s : skb_shinfo(skb)->tso_segs=%u\n",
+			__FUNCTION__,skb_shinfo(skb)->tso_segs);
+		DPRINTK("TCPCP : %s : si_skb->tso_size         =%u\n",
+			__FUNCTION__, si_skb->tso_size);
+		DPRINTK("TCPCP : %s : skb_shinfo(skb)->tso_size=%u\n",
+			__FUNCTION__,skb_shinfo(skb)->tso_size);
+
+#ifdef CONFIG_TCPCP_DEBUG
+		/* @@@ print queue. (for DEBUG) @@@ */
+		skb_queue_check(&sk->sk_write_queue);
+#endif
+		__skb_queue_tail(&sk->sk_write_queue, skb);
+		sk_charge_skb(sk, skb);
+		/* @@@ for DEBUG @@@ */
+		DPRINTK("TCPCP : %s : sk->sk_wmem_queued=%d\n",
+			__FUNCTION__, sk->sk_wmem_queued);
+
+#ifdef CONFIG_TCPCP_DEBUG
+		/* @@@ print queue. (for DEBUG) @@@ */
+		skb_queue_check(&sk->sk_write_queue);
+#endif
+
+		/*
+		 * it's based on tcp.c:skb_add_data().
+		 */
+
+#ifdef CONFIG_TCPCP_DEBUG
+		/* @@@ for printing payload. (for DEBUG) @@@ */
+		pload_data = skb->tail;
+#endif
+
+		/* copy data of packet. */
+		skb->csum = csum_partial_copy_nocheck(si_skb->data,
+						      skb_put(skb, data_len),
+						      data_len, 0);
+		/* @@@ for DEBUG @@@ */
+		DPRINTK("TCPCP : %s : after skb_put.\n", __FUNCTION__);
+		DPRINTK("TCPCP : %s : skb->head=0x%p\n",
+			__FUNCTION__, skb->head);
+		DPRINTK("TCPCP : %s : skb->data=0x%p\n",
+			__FUNCTION__, skb->data);
+		DPRINTK("TCPCP : %s : skb->tail=0x%p\n",
+			__FUNCTION__, skb->tail);
+		DPRINTK("TCPCP : %s : skb->len=%u\n", __FUNCTION__, skb->len);
+		DPRINTK("TCPCP : %s : skb->csum=%u\n", __FUNCTION__, skb->csum);
+
+#ifdef CONFIG_TCPCP_DEBUG
+		/* @@@ print payload. (for DEBUG) @@@ */
+		DPRINTK("TCPCP : %s : si_skb->data=\n", __FUNCTION__);
+		for (cnt1 = 0; cnt1 < data_len; cnt1 += 4) {
+			cnt2++;
+			DPRINTK("  %02d: %02X%02X%02X%02X\n", cnt2,
+				si_skb->data[cnt1],
+				si_skb->data[cnt1 + 1],
+				si_skb->data[cnt1 + 2],
+				si_skb->data[cnt1 + 3]);
+		}
+		cnt2 = 0;
+
+		DPRINTK("TCPCP : %s : pload_data=\n", __FUNCTION__);
+		for (cnt1 = 0; cnt1 < data_len; cnt1 += 4) {
+			cnt2++;
+			DPRINTK("  %02d: %02X%02X%02X%02X\n", cnt2,
+				pload_data[cnt1],
+				pload_data[cnt1 + 1],
+				pload_data[cnt1 + 2],
+				pload_data[cnt1 + 3]);
+		}
+		cnt2 = 0;
+#endif
+
+		/* @@@ for DEBUG @@@ */
+		DPRINTK("TCPCP : %s : tp->snd_nxt   =%u\n",
+			__FUNCTION__, tp->snd_nxt);
+		DPRINTK("TCPCP : %s : seq           =%u\n",
+			__FUNCTION__, seq);
+		DPRINTK("TCPCP : %s : seq+data_len-1=%u\n",
+			__FUNCTION__, seq + data_len - 1);
+
+		/* .... */
+		if (between(tp->snd_nxt, seq, seq + data_len - 1)) {
+			sk->sk_send_head = skb;
+
+			/* @@@ for DEBUG @@@ */
+			DPRINTK("TCPCP : %s : skb             =0x%p\n",
+				__FUNCTION__, skb);
+			DPRINTK("TCPCP : %s : sk->sk_send_head=0x%p\n",
+				__FUNCTION__, sk->sk_send_head);
+		}
+
+		/* @@@ for DEBUG @@@ */
+		DPRINTK("TCPCP : %s : skb_shinfo(skb)->tso_segs=%u\n",
+			__FUNCTION__, skb_shinfo(skb)->tso_segs);
+		DPRINTK("TCPCP : %s : tp->packets_out.val=%u\n",
+			__FUNCTION__, tp->packets_out.val);
+
+		if (!sk->sk_send_head) {
+			/* @@@ for DEBUG @@@ */
+			DPRINTK("TCPCP : %s : sk->sk_send_head=0x%p\n",
+				__FUNCTION__, sk->sk_send_head);
+
+			tp->packets_out += tcp_skb_pcount(skb);
+		}
+		/* @@@ for DEBUG @@@ */
+		DPRINTK("TCPCP : %s : tp->packets_out.val=%u\n",
+			__FUNCTION__, tp->packets_out.val);
+
+		/* move write_seq and snd_una. */
+		tp->write_seq = TCP_SKB_CB(skb)->end_seq;
+		/* @@@ for DEBUG @@@ */
+		DPRINTK("TCPCP : %s : tp->write_seq=%u\n",
+			__FUNCTION__, tp->write_seq);
+
+		if (cnt == 0)
+			tp->snd_una = seq;
+		/* @@@ for DEBUG  @@@ */
+		DPRINTK("TCPCP : %s : cnt=%u\n",
+			__FUNCTION__, cnt);
+		DPRINTK("TCPCP : %s : seq        =%u\n",
+			__FUNCTION__, seq);
+		DPRINTK("TCPCP : %s : tp->snd_una=%u\n",
+			__FUNCTION__, tp->snd_una);
+
+		/* @@@ for DEBUG @@@ */
+		DPRINTK("TCPCP : %s : skb->truesize     =%u\n",
+			__FUNCTION__, skb->truesize);
+		DPRINTK("TCPCP : %s : sk->sk_sndbuf     =%u\n",
+			__FUNCTION__, sk->sk_sndbuf);
+		DPRINTK("TCPCP : %s : sk->sk_wmem_queued=%u\n",
+			__FUNCTION__, sk->sk_wmem_queued);
+
+		si_skb = (struct tcpcp_si_skb *)
+			 (si_skb->data + ((data_len + 3) & ~3));
+	}
+
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : tp->snd_nxt  =%u\n",
+		__FUNCTION__, tp->snd_nxt);
+	DPRINTK("TCPCP : %s : tp->snd_una  =%u\n",
+		__FUNCTION__, tp->snd_una);
+	DPRINTK("TCPCP : %s : tp->write_seq=%u\n",
+		__FUNCTION__, tp->write_seq);
+
+	/* check snd_nxt, snd_una, write_seq. */
+	if (!between(tp->snd_nxt, tp->snd_una, tp->write_seq))
+		return -EINVAL;
+
+	/* end. */
+	DPRINTK("TCPCP : %s : end.\n", __FUNCTION__);
+	return 0;
+}
+
+/**
+ * tcpcp_recover_rcvbuf - Step 8 : recover receive_queue.
+ *
+ * Caller must lock socket.
+ *
+ * [Args]
+ *   (IN) *sk      : TCP socket
+ *   (IN) *rcv_buf : ...
+ *
+ * [Return]
+ *   0      : OK.
+ *  -ENOMEM : NG.
+ **/
+static int tcpcp_recover_rcvbuf(struct sock *sk,
+				const struct tcpcp_si_skb_buf *rcv_buf)
+{
+	struct tcp_sock *tp = tcp_sk(sk);
+	struct tcpcp_si_skb *si_skb;
+	unsigned int cnt;
+	int tcp_header_size = tp->tcp_header_len;
+
+#ifdef CONFIG_TCPCP_DEBUG
+	/* @@@ for printing payload. (for DEBUG) @@@ */
+	unsigned int cnt1, cnt2 = 0;
+	char *pload_data;
+#endif
+
+	/* plug-in. */
+	plugin_dummy();
+
+	/* start. */
+	DPRINTK("TCPCP : %s : start. sk=0x%p, rcv_buf=0x%p\n",
+		__FUNCTION__, sk, rcv_buf);
+
+	/* purge receive_queue. */
+	__skb_queue_purge(&sk->sk_receive_queue);
+
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : rcv_buf->buf_len=%u\n",
+		__FUNCTION__, rcv_buf->buf_len);
+	DPRINTK("TCPCP : %s : rcv_buf->skb_cnt=%u\n",
+		__FUNCTION__, rcv_buf->skb_cnt);
+
+	/* check receive buffer. */
+	if ((rcv_buf->buf_len == 0) || (rcv_buf->skb_cnt == 0)) {
+		DPRINTK("TCPCP : %s : end.\n", __FUNCTION__);
+		return 0;
+	}
+
+	si_skb = (struct tcpcp_si_skb *)rcv_buf->si_skb;
+
+	for (cnt = 0; cnt < rcv_buf->skb_cnt; cnt++) {
+		struct sk_buff *skb;
+		struct tcphdr *th;
+		unsigned int data_len;
+		uint32_t seq;
+
+		/* @@@ for DEBUG @@@ */
+		DPRINTK("TCPCP : %s : cnt=%u\n", __FUNCTION__, cnt);
+
+		/* get data_len. */
+		data_len = ntohs(si_skb->length);
+		/* @@@ for DEBUG @@@ */
+		DPRINTK("TCPCP : %s : si_skb->length=%u\n",
+			__FUNCTION__, si_skb->length);
+		DPRINTK("TCPCP : %s : data_len      =%u\n",
+			__FUNCTION__, data_len);
+
+		/* allocate socket buffer. (only data of packet) */
+		skb = alloc_skb(data_len + tcp_header_size, GFP_KERNEL);
+		if (!skb) {
+			DPRINTK("TCPCP : %s : [Error] can't allocate skb.\n",
+				__FUNCTION__);
+			return -ENOMEM;
+		}
+		/* @@@ for DEBUG @@@ */
+		DPRINTK("TCPCP : %s : after alloc_skb.\n", __FUNCTION__);
+		DPRINTK("TCPCP : %s : skb->head=0x%p\n",
+			__FUNCTION__, skb->head);
+		DPRINTK("TCPCP : %s : skb->data=0x%p\n",
+			__FUNCTION__, skb->data);
+		DPRINTK("TCPCP : %s : skb->tail=0x%p\n",
+			__FUNCTION__, skb->tail);
+		DPRINTK("TCPCP : %s : skb->len=%u\n", __FUNCTION__, skb->len);
+
+		seq = ntohl(si_skb->seq);
+		TCP_SKB_CB(skb)->seq = seq;
+		TCP_SKB_CB(skb)->end_seq = seq + data_len
+			+ ((si_skb->flags & TCPCB_FLAG_SYN) ? 1 : 0)
+			+ ((si_skb->flags & TCPCB_FLAG_FIN) ? 1 : 0);
+		TCP_SKB_CB(skb)->flags = si_skb->flags;
+		/* @@@ for DEBUG @@@ */
+		DPRINTK("TCPCP : %s : si_skb->seq             =%u\n",
+			__FUNCTION__, si_skb->seq);
+		DPRINTK("TCPCP : %s : seq                     =%u\n",
+			__FUNCTION__, seq);
+		DPRINTK("TCPCP : %s : TCP_SKB_CB(skb)->seq    =%u\n",
+			__FUNCTION__, TCP_SKB_CB(skb)->seq);
+		DPRINTK("TCPCP : %s : TCP_SKB_CB(skb)->end_seq=%u\n",
+			__FUNCTION__, TCP_SKB_CB(skb)->end_seq);
+		DPRINTK("TCPCP : %s : si_skb->flags=%u\n",
+			__FUNCTION__, si_skb->flags);
+
+		/* reserve TCP header. */
+		skb_reserve(skb, tcp_header_size);
+		/* @@@ for DEBUG @@@ */
+		DPRINTK("TCPCP : %s : after skb_reserve.\n", __FUNCTION__);
+		DPRINTK("TCPCP : %s : skb->head=0x%p\n",
+			__FUNCTION__, skb->head);
+		DPRINTK("TCPCP : %s : skb->data=0x%p\n",
+			__FUNCTION__, skb->data);
+		DPRINTK("TCPCP : %s : skb->tail=0x%p\n",
+			__FUNCTION__, skb->tail);
+		DPRINTK("TCPCP : %s : skb->len=%u\n", __FUNCTION__, skb->len);
+
+		/* copy TCP header. */
+		th = (struct tcphdr *) skb->head;
+		skb->h.th = th;
+		*(((__u16 *)th) + 6) = htons(((tcp_header_size >> 2) << 12)
+					     | TCP_SKB_CB(skb)->flags);
+
+#ifdef CONFIG_TCPCP_DEBUG
+		/* @@@ for printing payload. (for DEBUG) @@@ */
+		pload_data = skb->tail;
+#endif
+
+		/* copy data of packet. */ 
+		memcpy(skb_put(skb, data_len), si_skb->data, data_len);
+		/* @@@ for DEBUG @@@ */
+		DPRINTK("TCPCP : %s : after skb_put.\n", __FUNCTION__);
+		DPRINTK("TCPCP : %s : skb->head=0x%p\n",
+			__FUNCTION__, skb->head);
+		DPRINTK("TCPCP : %s : skb->data=0x%p\n",
+			__FUNCTION__, skb->data);
+		DPRINTK("TCPCP : %s : skb->tail=0x%p\n",
+			__FUNCTION__, skb->tail);
+		DPRINTK("TCPCP : %s : skb->len=%u\n", __FUNCTION__, skb->len);
+
+#ifdef CONFIG_TCPCP_DEBUG
+		/* @@@ print payload. (for DEBUG) @@@ */
+		DPRINTK("TCPCP : %s : si_skb->data=\n", __FUNCTION__);
+		for (cnt1 = 0; cnt1 < data_len; cnt1 += 4) {
+			cnt2++;
+			DPRINTK("  %02d: %02X%02X%02X%02X\n", cnt2,
+				si_skb->data[cnt1],
+				si_skb->data[cnt1 + 1],
+				si_skb->data[cnt1 + 2],
+				si_skb->data[cnt1 + 3]);
+		}
+		cnt2 = 0;
+
+		DPRINTK("TCPCP : %s : pload_data=\n", __FUNCTION__);
+		for (cnt1 = 0; cnt1 < data_len; cnt1 += 4) {
+			cnt2++;
+			DPRINTK("  %02d: %02X%02X%02X%02X\n", cnt2,
+				pload_data[cnt1],
+				pload_data[cnt1 + 1],
+			 	pload_data[cnt1 + 2],
+				pload_data[cnt1 + 3]);
+		}
+		cnt2 = 0;
+#endif
+
+		/*
+		 * it's based on tcp_input.c:tcp_data_queue().
+		 */
+
+		if (atomic_read(&sk->sk_rmem_alloc) > sk->sk_rcvbuf
+		    || !sk_stream_rmem_schedule(sk, skb)) {
+			DPRINTK("TCPCP : %s : [Error] receive_queue is not"
+				" free.\n", __FUNCTION__);
+			kfree_skb(skb);
+			return -ENOMEM;
+		}
+
+#ifdef CONFIG_TCPCP_DEBUG
+		/* @@@ print queue. (for DEBUG) @@@ */
+		skb_queue_check(&sk->sk_receive_queue);
+#endif
+		sk_stream_set_owner_r(skb, sk);
+		__skb_queue_tail(&sk->sk_receive_queue, skb);
+
+#ifdef CONFIG_TCPCP_DEBUG
+		/* @@@ print queue. (for DEBUG) @@@ */
+		skb_queue_check(&sk->sk_receive_queue);
+#endif
+
+		/* move copied_seq and snd_una. */
+		if (cnt == 0)
+			tp->copied_seq = seq;
+		/* @@@ for DEBUG @@@ */
+		DPRINTK("TCPCP : %s : cnt=%u\n",
+			__FUNCTION__, cnt);
+		DPRINTK("TCPCP : %s : seq           =%u\n",
+			__FUNCTION__, seq);
+		DPRINTK("TCPCP : %s : tp->copied_seq=%u\n",
+			__FUNCTION__, tp->copied_seq);
+
+		si_skb = (struct tcpcp_si_skb *)
+			 (si_skb->data + ((data_len + 3) & ~3));
+	}
+
+	/* end. */
+	DPRINTK("TCPCP : %s : end.\n", __FUNCTION__);
+	return 0;
+}
+
+/**
+ * do_set_si - set TCP-SI for TCP socket.
+ *
+ * This function is based on TCPCP-9:do_setici().
+ * Caller must lock socket.
+ *
+ * [Args]
+ *   (IN) *sk     : TCP socket
+ *   (IN) *si_buf : TCP-SI buffer
+ *
+ * [Return]
+ *   0             : OK.
+ *  -ENOPROTOOPT   : NG. (tcpcp_check_compatibility)
+ *  -EINVAL        : NG. (pre_v6bind/pre_v4bind/pre_v6connect/pre_v4connect)
+ *  -EACCES        : NG. (pre_v6bind/pre_v4bind)
+ *  -EADDRNOTAVAIL : NG. (pre_v6bind/pre_v4bind)
+ *  -ENETUNREACH   : NG. (pre_v6connect)
+ *  -EBADFD        : NG.
+ **/
+static int do_set_si(struct sock *sk, struct tcpcp_si_buf *si_buf)
+{
+	struct tcpcp_si_hdr *si_hdr = &(si_buf->si_hdr);
+	struct tcpcp_si_skb_buf *snd_buf = &(si_buf->snd_buf);
+	struct tcpcp_si_skb_buf *rcv_buf = &(si_buf->rcv_buf);
+	struct tcp_sock *tp = tcp_sk(sk);
+	int error;
+
+	/* plug-in. */
+	plugin_dummy();
+
+	/* start. */
+	DPRINTK("TCPCP : %s : start. si_buf=0x%p\n", __FUNCTION__, si_buf);
+
+	/* Step 1 : check compatibility. */
+	error = tcpcp_check_compatibility(si_hdr);
+	if (error != 0) {
+		/* only -ENOPROTOOPT. */
+		DPRINTK("TCPCP : %s : [Error] TCP-SI is not compatible on this"
+			" system. error=%d\n", __FUNCTION__, error);
+		return error;
+	}
+
+	/* Step 1.5 : check socket family. */
+	switch (si_hdr->id.ip_version) {
+	case 4:
+		if (sk->sk_family != PF_INET) {
+			DPRINTK("TCPCP : %s : [Error] ip_version is IPv4, but"
+				" sk_family is not PF_INET.\n", __FUNCTION__);
+			return -EBADFD;
+		}
+		break;
+	case 6:
+		if (sk->sk_family != PF_INET6) {
+			DPRINTK("TCPCP : %s : [Error] ip_version is IPv6, but"
+				" sk_family is not PF_IENT6.\n", __FUNCTION__);
+			return -EBADFD;
+		}
+		break;
+	default:
+		DPRINTK("TCPCP : %s : [Error] ip_version is invalid.\n",
+			__FUNCTION__);
+		return -EINVAL;
+	}
+
+	/* Step 2 : set socket options. (before bind) */
+ 	tcpcp_setopt_before_bind(sk, si_hdr);
+
+	/* Step 3 : pre-bind. */
+#if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)
+	if (sk->sk_family == PF_INET6)
+		error = tcpcp_pre_v6bind(sk, si_hdr);
+	else
+#endif
+		error = tcpcp_pre_v4bind(sk, si_hdr);
+	if (error != 0) {
+		DPRINTK("TCPCP : %s : [Error] can't pre_bind. error=%d\n",
+			__FUNCTION__, error);
+		return error;
+	}
+
+	/* Step 4 : set socket options. (after bind) */
+ 	tcpcp_setopt_after_bind(sk, si_hdr);
+
+	/* Step 5 : pre-connect. */
+#if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)
+	if (sk->sk_family == PF_INET6)
+		error = tcpcp_pre_v6connect(sk, si_hdr);
+	else
+#endif
+		error = tcpcp_pre_v4connect(sk, si_hdr);
+	if (error != 0) {
+		DPRINTK("TCPCP : %s : [Error] can't pre_connect. error=%d\n",
+			__FUNCTION__, error);
+		goto err;
+	}
+
+	/* Step 6 : recover TCP-SI header. */
+	tcpcp_recover_si_hdr(sk, si_hdr);
+
+	/* Step 7 : recover write_queue. */
+	error = tcpcp_recover_sndbuf(sk, snd_buf);
+	if (error != 0) {
+		DPRINTK("TCPCP : %s : [Error] can't recover write_queue."
+			" error=%d\n", __FUNCTION__, error);
+		goto err;
+	}
+
+	/* Step 8 : recover receive_queue. */
+	error = tcpcp_recover_rcvbuf(sk, rcv_buf);
+	if (error != 0) {
+		DPRINTK("TCPCP : %s : [Error] can't recover receive_queue."
+			" error=%d\n", __FUNCTION__, error);
+		goto err;
+	}
+
+	/* Step 9 : check socket error. */
+	error = sock_error(sk);
+	if (error != 0) {
+		DPRINTK("TCPCP : %s : [Error] sock_error failure. error=%d\n",
+			__FUNCTION__, error);
+		error = -EBADFD;
+		goto err;
+	}
+
+	/* Step 10 */
+	tp->set_flag = TCPCP_SET_FLAG_ON;
+	tcpcp_change_xmit(sk, TCPCP_FLAG_STOP);
+	/* @@@ for DEBUG @@@*/
+	DPRINTK("TCPCP : %s : tp->set_flag=%d\n", __FUNCTION__, tp->set_flag);
+
+	/* end. */
+	DPRINTK("TCPCP : %s : end.\n", __FUNCTION__);
+	return 0;
+
+err:
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : sk->sk_flags=%lu\n", __FUNCTION__, sk->sk_flags);
+
+	/* in case of an error, don't make the poor socket linger ... */
+	sock_set_flag(sk, SOCK_LINGER);
+	sk->sk_lingertime = 0;
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : sk->sk_flags=%lu\n", __FUNCTION__, sk->sk_flags);
+	DPRINTK("TCPCP : %s : sk->sk_lingertime=%lu\n",
+		__FUNCTION__, sk->sk_lingertime);
+
+	/* end. */
+	DPRINTK("TCPCP : %s : end. error=%d\n", __FUNCTION__, error);
+	return error;
+}
+
+/**
+ * tcpcp_close_socket
+ *   - close TCP sockets. (for error operation of do_tcpcp_set_si)
+ *
+ * [Args]
+ *   (IN) *f_entry : first FDR Info. Entry
+ **/
+static void tcpcp_close_socket(struct tcpcp_com_entry *f_entry)
+{
+	struct fdr *fdrs = NULL;
+	unsigned int fdr_cnt;
+	unsigned int cnt;
+	int fd;
+
+	/* plug-in. */
+	plugin_dummy();
+
+	/* start. */
+	DPRINTK("TCPCP : %s : start. f_entry=0x%p\n", __FUNCTION__, f_entry);
+
+#ifdef CONFIG_TCPCP_DEBUG
+	/* @@@ .... (for DEBUG) @@@ */
+	check_fd();
+#endif
+
+	while (f_entry != NULL) {
+		/* @@@ for DEBUG @@@ */
+		DPRINTK("TCPCP : %s : f_entry=0x%p\n", __FUNCTION__, f_entry);
+
+		/* calculate number of FDR Info. */
+		fdr_cnt = f_entry->data_len / sizeof(struct fdr);
+		/* @@@ for DEBUG @@@ */
+		DPRINTK("TCPCP : %s : f_entry->data_len =%u\n",
+			__FUNCTION__, f_entry->data_len);
+		DPRINTK("TCPCP : %s : fdr_cnt           =%u\n",
+			__FUNCTION__, fdr_cnt);
+
+		fdrs = (struct fdr *)(f_entry->data);
+		/* @@@ for DEBUG @@@ */
+		DPRINTK("TCPCP : %s : fdrs=0x%p\n", __FUNCTION__, fdrs);
+
+		for (cnt = 0; cnt < fdr_cnt; cnt++) {
+			/* get new FD. */
+			fd = fdrs->result;
+			if (fd >= 0) {
+				/* @@@ for DEBUG @@@ */
+				DPRINTK("TCPCP : %s : fd=%d\n",
+					__FUNCTION__, fd);
+
+				/* close TCP socket. */
+				do_close(fd);
+			}
+			fdrs++;
+			/* @@@ for DEBUG @@@ */
+			DPRINTK("TCPCP : %s : fdrs=0x%p\n",
+				__FUNCTION__, fdrs);
+		}
+
+		f_entry = f_entry->next;
+		/* @@@ for DEBUG @@@ */
+		DPRINTK("TCPCP : %s : f_entry=0x%p\n",
+			__FUNCTION__, f_entry);
+	}
+
+#ifdef CONFIG_TCPCP_DEBUG
+	/* @@@ .... (for DEBUG) @@@ */
+	check_fd();
+#endif
+
+	/* end. */
+	DPRINTK("TCPCP : %s : end.\n", __FUNCTION__);
+	return;
+}
+
+/**
+ * do_tcpcp_set_si - set TCP-SIs for TCP sockets.
+ *
+ * [Args]
+ *   (IN) *sk      : TCP socket
+ *   (IN) *r_entry : Request Entry
+ *   (IN) *user_si : TCP-SI data from user (const)
+ *
+ * [Return]
+ *   0            : OK.
+ *  -EINVAL       : NG. (sys_socket/...)
+ *  -ENOMEM       : NG.
+ *  -EFAULT       : NG.
+ *  -EAFNOSUPPORT : NG. (sys_socket)
+ *  -ENFILE       : NG. (sys_socket)
+ *   other        : NG. (sys_socket)
+ **/
+static int do_tcpcp_set_si(struct sock *sk,
+			  const struct tcpcp_total_si_hdr *user_si,
+			  struct tcpcp_req_entry *r_entry)
+{
+	struct task_struct *tsk = current;
+	struct files_struct *files = tsk->files;
+	struct file *filp = NULL;
+	struct sock *sk_i = NULL;
+	struct tcpcp_si_buf si_buf;
+	struct tcpcp_com_entry *fdr_entry;
+	unsigned int total_si_hdr_len;
+	unsigned int total_ucopy;
+	int fd = 0;
+	int error = 0;
+	int si_cnt = 0;
+	unsigned int fd_all = 0;
+	unsigned int fd_ng = 0;
+	int ret = 0;
+	int new_fd = 0;
+	int old_fd = 0;
+	char *r_ptr;
+	struct fdtable *fdt;
+#ifdef CONFIG_TCPCP_DEBUG
+	/* @@@ for DEBUG @@@ */
+	unsigned int loop_cnt = 0;
+#endif
+
+	/* plug-in. */
+	plugin_dummy();
+
+	/* start. */
+	DPRINTK("TCPCP : %s : start. sk=0x%p, r_entry=0x%p, user_si=0x%p\n",
+		__FUNCTION__, sk, r_entry, user_si);
+
+	/* set read-point. */
+	r_ptr = (char *)user_si;
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : r_ptr=0x%p\n", __FUNCTION__, r_ptr);
+
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : user_si->major=%u\n",
+		__FUNCTION__, user_si->major);
+
+	/* check TCP-SIs version. */
+	if (user_si->major != TCPCP_CURRENT_SI_MAJOR)
+		return -EINVAL;
+
+	/* get count of TCP-SIs. */
+	si_cnt = ntohs(user_si->si_cnt);
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : user_si->si_cnt=%u\n",
+		__FUNCTION__, user_si->si_cnt);
+	DPRINTK("TCPCP : %s : si_cnt         =%u\n",
+		__FUNCTION__, si_cnt);
+
+	/* check si_cnt for ONE processing. */
+	if (!(r_entry->flag & TCPCP_FLAG_ALL)) {
+		if (si_cnt != 1) {
+			DPRINTK("TCPCP : %s : In spite of ONE processing," \
+					" TCP-SIs for ALL is specified.\n",
+					__FUNCTION__);
+			return -EINVAL;
+		}
+	}
+
+	/* move read-point. */
+	total_si_hdr_len = sizeof(struct tcpcp_total_si_hdr);
+	r_ptr += total_si_hdr_len;
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : total_si_hdr_len=%u\n",
+		__FUNCTION__, total_si_hdr_len);
+	DPRINTK("TCPCP : %s : r_ptr=0x%p\n", __FUNCTION__, r_ptr);
+
+	/* get length of TCP-SI. (exclude TCP-SI header) */
+	total_ucopy = ntohl(user_si->total_si_length) * 4 - total_si_hdr_len;
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : user_si->total_si_length=%u\n",
+		__FUNCTION__, user_si->total_si_length);
+	DPRINTK("TCPCP : %s : total_ucopy             =%u\n",
+		__FUNCTION__, total_ucopy);
+	fdt = files_fdtable(files);
+	for (fd = 0; fd < fdt->max_fds; fd++) {
+		/* @@@ for DEBUG @@@ */
+		DPRINTK("TCPCP : %s : fd=%u\n", __FUNCTION__, fd);
+
+		sk_i = tcpcp_get_sk_i(sk, fd, r_entry);
+		if (sk_i == NULL)
+			continue;
+		/* @@@ for DEBUG @@@ */
+		DPRINTK("TCPCP : %s : nothing continue after tcpcp_get_sk_i.\n",
+			__FUNCTION__);
+
+		if (r_entry->flag & TCPCP_FLAG_ALL)
+			/* close FD. (only "ALL") */
+			/* lock_sock and release_sock are unnecessary.
+			 * because spin_lock to files is in do_close. */
+			do_close(fd);
+
+		/*
+		 *  if one, fd value is set in the Request entry
+		 *  by tcpcp_get_sk_i function.
+		 */
+	}
+
+	/* make TCP-SI buffer for setting TCP-SIs to kernel. */
+	error = tcpcp_alloc_si_buf(&si_buf);
+	if (error != 0) {
+		/* only -ENOMEM. */
+		DPRINTK("TCPCP : %s : [Error] can't allocate si_buf."
+			" error=%d\n", __FUNCTION__, error);
+		return error;
+	}
+
+	if (r_entry->flag & TCPCP_FLAG_ALL) {
+		/* add FDR Info. Entry. (only "ALL")*/
+		error = tcpcp_add_com_entry(r_entry->flag, &(r_entry->f_entry));
+		if (error != 0)
+			return -ENOMEM;
+	}
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : r_entry->f_entry=0x%p\n",
+		__FUNCTION__, r_entry->f_entry);
+
+	/* initialize now FDR Info. Entry. */
+	fdr_entry = r_entry->f_entry;
+
+	while ((total_ucopy != 0) || (si_cnt != 0)) {
+		unsigned int si_len;
+
+#ifdef CONFIG_TCPCP_DEBUG
+		/* @@@ for DEBUG @@@ */
+		loop_cnt++;
+		DPRINTK("TCPCP : %s : loop_cnt=%u\n", __FUNCTION__, loop_cnt);
+#endif
+
+		/* copy TCP-SI from userland to Kernel. */
+		error = tcpcp_copy_si_from_user((struct tcpcp_si_hdr *)r_ptr,
+						&si_buf, total_ucopy);
+		if (error != 0) {
+			DPRINTK("TCPCP : %s : [Error] can't copy TCP-SIs from"
+				" user. error=%d\n", __FUNCTION__, error);
+			goto err;
+		}
+
+		si_cnt--;
+		/* @@@ for DEBUG @@@ */
+		DPRINTK("TCPCP : %s : si_cnt=%u\n", __FUNCTION__, si_cnt);
+
+		/* move read-point. */
+		si_len = ntohl(si_buf.si_hdr.si_length) * 4;
+		r_ptr += si_len; 
+		total_ucopy -= si_len;
+		/* @@@ for DEBUG @@@ */
+		DPRINTK("TCPCP : %s : si_len=%u\n", __FUNCTION__, si_len);
+		DPRINTK("TCPCP : %s : r_ptr=0x%p\n", __FUNCTION__, r_ptr);
+		DPRINTK("TCPCP : %s : total_ucopy=%u\n",
+			__FUNCTION__, total_ucopy);
+
+		if (r_entry->flag & TCPCP_FLAG_ALL) {
+			/* create socket. (only "ALL")*/
+#if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)
+			/* @@@ for DEBUG @@@ */
+			DPRINTK("TCPCP : %s : si_buf.si_hdr.id.ip_version=%u\n",
+				__FUNCTION__, si_buf.si_hdr.id.ip_version);
+
+			if (si_buf.si_hdr.id.ip_version == 6)
+				new_fd = tcpcp_sys_socket(PF_INET6, SOCK_STREAM,
+						IPPROTO_TCP);
+			else
+#endif
+				new_fd = tcpcp_sys_socket(PF_INET, SOCK_STREAM,
+						IPPROTO_TCP);
+			/* @@@ for DEBUG @@@ */
+			DPRINTK("TCPCP : %s : new_fd=%d\n",
+				__FUNCTION__, new_fd);
+
+			if (new_fd < 0) {
+				/* set return value */
+				error = new_fd;
+				goto err;
+			}
+
+			/* get SOCKET_I() from new FD. */
+			filp = fcheck_files(files, new_fd);
+			sk_i = SOCKET_I(filp->f_dentry->d_inode)->sk;
+			if (sk_i == NULL)
+				continue;
+
+			/* @@@ for DEBUG @@@ */
+			DPRINTK("TCPCP : %s : nothing continue after"
+				" SOCKET_I\n", __FUNCTION__);
+		} else 
+			sk_i = sk;
+		/* @@@ for DEBUG @@@ */
+		DPRINTK("TCPCP : %s : sk  =0x%p.\n",__FUNCTION__, sk);
+		DPRINTK("TCPCP : %s : sk_i=0x%p.\n",__FUNCTION__, sk_i);
+
+		/* set TCP-SI. */
+		lock_sock(sk_i);
+		ret = do_set_si(sk_i, &si_buf);
+		release_sock(sk_i);
+		/* @@@ for DEBUG @@@ */
+		DPRINTK("TCPCP : %s : after do_set_si. ret=%d\n",
+			__FUNCTION__, ret);
+
+		fd_all++;
+		/* @@@ for DEBUG @@@ */
+		DPRINTK("TCPCP : %s : fd_all=%u\n", __FUNCTION__, fd_all);
+
+		if (!(r_entry->flag & TCPCP_FLAG_ALL)) {
+			/* @@@ for DEBUG @@@ */
+			DPRINTK("TCPCP : %s : Break for loop.\n", __FUNCTION__);
+
+			if (ret != 0) {
+				error = ret;
+				goto err;
+			}
+			break;
+		}
+
+		/* Only ALL, the following processings are performed. */
+		if (ret != 0) {
+			/* In case of NG (count fd_ng and close new_fd.) */
+			fd_ng++;
+			error = do_close(new_fd);
+		} else
+			/* In case of OK */
+			ret = new_fd;
+		/* @@@ for DEBUG @@@ */
+		DPRINTK("TCPCP : %s : fd_ng=%u\n", __FUNCTION__, fd_ng);
+		DPRINTK("TCPCP : %s : ret=%d\n", __FUNCTION__, ret);
+
+		/* get old FD. */
+		old_fd = ntohl(si_buf.si_hdr.fd);
+		/* @@@ for DEBUG @@@ */
+		DPRINTK("TCPCP : %s : si_buf.si_hdr.fd=%d\n",
+			__FUNCTION__, si_buf.si_hdr.fd);
+		DPRINTK("TCPCP : %s : old_fd          =%d\n",
+			__FUNCTION__, old_fd);
+
+		/* make FDR Info. (only "ALL") */
+		error = tcpcp_make_res(old_fd, ret, &fdr_entry);
+		if (error != 0) {
+			/* only -ENOMEM. */
+			DPRINTK("TCPCP : %s : [Error] can't make FDR Info."
+				" error=%d\n", __FUNCTION__, error);
+			/* Caller delete Request Entry with common entries. */
+			goto err;
+		}
+
+		/* clear TCP-SI buffer (set si_buf all zero) */ 
+		tcpcp_clear_si_buf(&si_buf);
+	}
+
+	/* free TCP-SI buffer. */
+	tcpcp_free_si_buf(&si_buf);
+
+	/* set Processing Result Info. */
+	r_entry->res.fd_all = fd_all;
+	r_entry->res.fd_ng = fd_ng;
+	r_entry->res.buf_size = 0;
+	r_entry->res.fdrs_size = sizeof(struct fdr) * fd_all;
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : r_entry->res.fd_all   =%u\n",
+		__FUNCTION__, r_entry->res.fd_all);
+	DPRINTK("TCPCP : %s : r_entry->res.fd_ng    =%u\n",
+		__FUNCTION__, r_entry->res.fd_ng);
+	DPRINTK("TCPCP : %s : r_entry->res.buf_size =%u\n",
+		__FUNCTION__, r_entry->res.buf_size);
+	DPRINTK("TCPCP : %s : r_entry->res.fdrs_size=%u\n",
+		__FUNCTION__, r_entry->res.fdrs_size);
+
+	/* end. */
+	DPRINTK("TCPCP : %s : end.\n", __FUNCTION__);
+	return 0;
+
+err:
+	/* Only in the case of ALL, tcpcp_close_socket is performed. */
+	if (r_entry->flag & TCPCP_FLAG_ALL)
+		/* close socket made in this function */
+		tcpcp_close_socket(r_entry->f_entry);
+
+	/* free memory for send/recv buffer */
+	tcpcp_free_si_buf(&si_buf);
+
+	/* end. */
+	DPRINTK("TCPCP : %s : end. error=%d\n", __FUNCTION__, error);
+	return error;
+}
+
+
+/* ----- start TCP sockets ------------------------------------------------- */
+
+#if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)
+/**
+ * tcpcp_v6bind - Step A : TCP/IPv6 bind.
+ *
+ * This function is based on af_inet6.c:inet6_bind().
+ * Caller must lock socket.
+ * 
+ * [Args]
+ *   (IN) *sk : TCP socket
+ * 
+ * [Return]
+ *   0             : OK.
+ *  -ENODEV        : NG.
+ *  -EADDRNOTAVAIL : NG.
+ *  -EADDRINUSE    : NG.
+ **/
+static int tcpcp_v6bind(struct sock *sk)
+{
+	struct inet_sock *inet = inet_sk(sk);
+	struct ipv6_pinfo *inet6 = inet6_sk(sk);
+	int addr_type;
+	unsigned short snum;
+
+	/* plug-in. */
+	plugin_dummy();
+
+	/* start. */
+	DPRINTK("TCPCP : %s : start. sk=0x%p\n", __FUNCTION__, sk);
+
+	/* get type of IPv6 source address. */
+	addr_type = ipv6_addr_type(&(inet6->saddr));
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : addr_type=%u\n", __FUNCTION__, addr_type);
+
+	/* check type of IPv6 source address. */
+	if ((addr_type == IPV6_ADDR_ANY) || (addr_type & IPV6_ADDR_MULTICAST)) {
+		/* TCPCP not support IPV6_ADDR_ANY and multicast. */
+		DPRINTK("TCPCP : %s : [Error] type of saddr is ANY or"
+			" multicast.\n", __FUNCTION__);
+		return -EADDRNOTAVAIL;
+	}
+
+	if (addr_type != IPV6_ADDR_MAPPED) {
+		struct net_device *dev = NULL;
+
+		if (addr_type & IPV6_ADDR_LINKLOCAL) {
+			dev = dev_get_by_index(sk->sk_bound_dev_if);
+			/* @@@ for DEBUG @@@ */
+			DPRINTK("TCPCP : %s : sk->sk_bound_dev_if=%u\n",
+				__FUNCTION__, sk->sk_bound_dev_if);
+
+			if (!dev) {
+				DPRINTK("TCPCP : %s : [Error] can't get"
+					" device.\n", __FUNCTION__);
+				return -ENODEV;
+			}
+		}
+
+		if (ipv6_chk_addr(&(inet6->saddr), dev, 0) == 0) {
+			if (dev) {
+				dev_put(dev);
+				/* @@@ for DEBUG @@@ */
+				DPRINTK("TCPCP : %s : dev->refcnt.counter=%d\n",
+					__FUNCTION__, dev->refcnt.counter);
+			}
+
+			return -EADDRNOTAVAIL;
+		}
+
+		if (dev) {
+			dev_put(dev);
+			/* @@@ for DEBUG @@@ */
+			DPRINTK("TCPCP : %s : dev->refcnt.counter=%d\n",
+				__FUNCTION__, dev->refcnt.counter);
+		}
+	}
+
+	/* make sure we are allowed to bind here. */
+	snum = ntohs(inet->sport);
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : inet->sport=%u\n", __FUNCTION__, inet->sport);
+	DPRINTK("TCPCP : %s : snum       =%u\n", __FUNCTION__, snum);
+
+	/* bind TCP port. */
+	sk->sk_reuse = 2;
+	if (sk->sk_prot->get_port(sk, snum) != 0) {
+		DPRINTK("TCPCP : %s : [Error] can't bind TCP port.\n",
+			__FUNCTION__);
+
+		inet_reset_saddr(sk);
+		/* @@@ for DEBUG @@@ */
+		DPRINTK("TCPCP : %s : inet->saddr    =0x%x\n",
+			__FUNCTION__, inet_sk(sk)->saddr);
+		DPRINTK("TCPCP : %s : inet->rcv_saddr=0x%x\n",
+			__FUNCTION__, inet_sk(sk)->rcv_saddr);
+
+		return -EADDRINUSE;
+	}
+
+	/* end. */
+	DPRINTK("TCPCP : %s : end.\n", __FUNCTION__);
+	return 0;
+}
+#endif /* defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE) */
+
+/**
+ * tcpcp_v4bind - Step A : TCP/IPv4 bind.
+ *
+ * This function is based on af_inet.c:inet_bind().
+ * Caller must lock socket.
+ * 
+ * [Args]
+ *   (IN) *sk : TCP socket
+ * 
+ * [Return]
+ *   0          : OK.
+ *  -EADDRINUSE : NG.
+ **/
+static int tcpcp_v4bind(struct sock *sk)
+{
+	struct inet_sock *inet = inet_sk(sk);
+	unsigned short snum;
+
+	/* plug-in. */
+	plugin_dummy();
+
+	/* start. */
+	DPRINTK("TCPCP : %s : start. sk=0x%p\n", __FUNCTION__, sk);
+
+	/* make sure we are allowed to bind here. */
+	snum = ntohs(inet->sport);
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : inet->sport=%u\n", __FUNCTION__, inet->sport);
+	DPRINTK("TCPCP : %s : snum       =%u\n", __FUNCTION__, snum);
+
+	/* bind TCP port. */
+	sk->sk_reuse = 2;
+	if (sk->sk_prot->get_port(sk, snum) != 0) {
+		DPRINTK("TCPCP : %s : [Error] can't bind TCP port.\n",
+			__FUNCTION__);
+
+		inet->saddr = inet->rcv_saddr = 0;
+		/* @@@ for DEBUG @@@ */
+		DPRINTK("TCPCP : %s : inet->saddr    =0x%x\n",
+			__FUNCTION__, inet->saddr);
+		DPRINTK("TCPCP : %s : inet->rcv_saddr=0x%x\n",
+			__FUNCTION__, inet->rcv_saddr);
+
+		return -EADDRINUSE;
+	}
+
+	/* end. */
+	DPRINTK("TCPCP : %s : end.\n", __FUNCTION__);
+	return 0;
+}
+
+#if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)
+/**
+ * tcpcp_v6connect - Step B : TCP/IPv6 connect.
+ *
+ * This function is based on tcp_ipv6.c:tcp_v6_connect().
+ * It walks TCP through to the SYN_SENT state.
+ * Caller must lock socket.
+ * 
+ * [Args]
+ *   (IN) *sk : TCP socket
+ * 
+ * [Return]
+ *   0             : OK.
+ *  -EINVAL        : NG.
+ *  -EADDRNOTAVAIL : NG.
+ *  -EPERM         : NG.
+ *  -EAGAIN        : NG.
+ *  -ERESTART      : NG.
+ *   other         : NG. (xfrm_lookup)
+ **/
+static int tcpcp_v6connect(struct sock *sk)
+{
+	struct inet_sock *inet = inet_sk(sk);
+	struct ipv6_pinfo *inet6 = inet6_sk(sk);
+	struct tcp_sock *tp = tcp_sk(sk);
+	struct in6_addr *final_p = NULL, final;
+	struct flowi fl;
+	struct dst_entry *dst;
+	int error;
+
+	/* plug-in. */
+	plugin_dummy();
+
+	/* start. */
+	DPRINTK("TCPCP : %s : start. sk=0x%p\n", __FUNCTION__, sk);
+
+	/* set flow label. */
+	memset(&fl, 0, sizeof(fl));
+	fl.proto = IPPROTO_TCP;
+	ipv6_addr_copy(&(fl.fl6_dst), &(inet6->daddr));
+	ipv6_addr_copy(&(fl.fl6_src), &(inet6->saddr));
+	fl.oif = sk->sk_bound_dev_if;
+	fl.fl_ip_dport = inet->dport;
+	fl.fl_ip_sport = inet->sport;
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : fl.proto=%u\n", __FUNCTION__, fl.proto);
+	DPRINTK("TCPCP : %s : inet6->daddr=%04x:%04x:%04x:%04x:"
+		"%04x:%04x:%04x:%04x\n", __FUNCTION__,
+		ntohs(inet6->daddr.s6_addr16[0]),
+		ntohs(inet6->daddr.s6_addr16[1]),
+		ntohs(inet6->daddr.s6_addr16[2]),
+		ntohs(inet6->daddr.s6_addr16[3]),
+		ntohs(inet6->daddr.s6_addr16[4]),
+		ntohs(inet6->daddr.s6_addr16[5]),
+		ntohs(inet6->daddr.s6_addr16[6]),
+		ntohs(inet6->daddr.s6_addr16[7]));
+	DPRINTK("TCPCP : %s : fl.fl6_dst  =%04x:%04x:%04x:%04x:"
+		"%04x:%04x:%04x:%04x\n", __FUNCTION__,
+		ntohs(fl.fl6_dst.s6_addr16[0]),
+		ntohs(fl.fl6_dst.s6_addr16[1]),
+		ntohs(fl.fl6_dst.s6_addr16[2]),
+		ntohs(fl.fl6_dst.s6_addr16[3]),
+		ntohs(fl.fl6_dst.s6_addr16[4]),
+		ntohs(fl.fl6_dst.s6_addr16[5]),
+		ntohs(fl.fl6_dst.s6_addr16[6]),
+		ntohs(fl.fl6_dst.s6_addr16[7]));
+	DPRINTK("TCPCP : %s : inet6->saddr=%04x:%04x:%04x:%04x:"
+		"%04x:%04x:%04x:%04x\n", __FUNCTION__,
+		ntohs(inet6->saddr.s6_addr16[0]),
+		ntohs(inet6->saddr.s6_addr16[1]),
+		ntohs(inet6->saddr.s6_addr16[2]),
+		ntohs(inet6->saddr.s6_addr16[3]),
+		ntohs(inet6->saddr.s6_addr16[4]),
+		ntohs(inet6->saddr.s6_addr16[5]),
+		ntohs(inet6->saddr.s6_addr16[6]),
+		ntohs(inet6->saddr.s6_addr16[7]));
+	DPRINTK("TCPCP : %s : fl.fl6_src  =%04x:%04x:%04x:%04x:"
+		"%04x:%04x:%04x:%04x\n", __FUNCTION__,
+		ntohs(fl.fl6_src.s6_addr16[0]),
+		ntohs(fl.fl6_src.s6_addr16[1]),
+		ntohs(fl.fl6_src.s6_addr16[2]),
+		ntohs(fl.fl6_src.s6_addr16[3]),
+		ntohs(fl.fl6_src.s6_addr16[4]),
+		ntohs(fl.fl6_src.s6_addr16[5]),
+		ntohs(fl.fl6_src.s6_addr16[6]),
+		ntohs(fl.fl6_src.s6_addr16[7]));
+	DPRINTK("TCPCP : %s : sk->sk_bound_dev_if=%u\n",
+		__FUNCTION__, sk->sk_bound_dev_if);
+	DPRINTK("TCPCP : %s : fl.oif             =%u\n",
+		__FUNCTION__, fl.oif);
+	DPRINTK("TCPCP : %s : inet->dport   =%u\n",
+		__FUNCTION__, inet->dport);
+	DPRINTK("TCPCP : %s : fl.fl_ip_dport=%u\n",
+		__FUNCTION__, fl.fl_ip_dport);
+	DPRINTK("TCPCP : %s : inet->sport   =%u\n",
+		__FUNCTION__, inet->sport);
+	DPRINTK("TCPCP : %s : fl.fl_ip_sport=%u\n",
+		__FUNCTION__, fl.fl_ip_sport);
+
+	/* @@@ for DEBUG @@@ */
+	if (inet6->opt != 0)
+		DPRINTK("TCPCP : %s : inet6->opt->srcrt=0x%p\n",
+			__FUNCTION__, inet6->opt->srcrt);
+
+	/* .... */
+	if ((inet6->opt != 0) && (inet6->opt->srcrt != 0)) {
+		struct rt0_hdr *rt0 = (struct rt0_hdr *)inet6->opt->srcrt;
+		ipv6_addr_copy(&final, &(fl.fl6_dst));
+		ipv6_addr_copy(&(fl.fl6_dst), rt0->addr);
+		final_p = &final;
+		/* @@@ for DEBUG @@@  */
+		DPRINTK("TCPCP : %s : rt0=0x%p\n", __FUNCTION__, rt0);
+		DPRINTK("TCPCP : %s : final     =%04x:%04x:%04x:%04x:"
+			"%04x:%04x:%04x:%04x\n", __FUNCTION__,
+			ntohs(final.s6_addr16[0]),
+			ntohs(final.s6_addr16[1]),
+			ntohs(final.s6_addr16[2]),
+			ntohs(final.s6_addr16[3]),
+			ntohs(final.s6_addr16[4]),
+			ntohs(final.s6_addr16[5]),
+			ntohs(final.s6_addr16[6]),
+			ntohs(final.s6_addr16[7]));
+		DPRINTK("TCPCP : %s : rt0->addr =%04x:%04x:%04x:%04x:"
+			"%04x:%04x:%04x:%04x\n", __FUNCTION__,
+			ntohs(rt0->addr[0].s6_addr16[0]),
+			ntohs(rt0->addr[0].s6_addr16[1]),
+			ntohs(rt0->addr[0].s6_addr16[2]),
+			ntohs(rt0->addr[0].s6_addr16[3]),
+			ntohs(rt0->addr[0].s6_addr16[4]),
+			ntohs(rt0->addr[0].s6_addr16[5]),
+			ntohs(rt0->addr[0].s6_addr16[6]),
+			ntohs(rt0->addr[0].s6_addr16[7]));
+		DPRINTK("TCPCP : %s : fl.fl6_dst=%04x:%04x:%04x:%04x:"
+			"%04x:%04x:%04x:%04x\n", __FUNCTION__,
+			ntohs(fl.fl6_dst.s6_addr16[0]),
+			ntohs(fl.fl6_dst.s6_addr16[1]),
+			ntohs(fl.fl6_dst.s6_addr16[2]),
+			ntohs(fl.fl6_dst.s6_addr16[3]),
+			ntohs(fl.fl6_dst.s6_addr16[4]),
+			ntohs(fl.fl6_dst.s6_addr16[5]),
+			ntohs(fl.fl6_dst.s6_addr16[6]),
+			ntohs(fl.fl6_dst.s6_addr16[7]));
+		DPRINTK("TCPCP : %s : &final =0x%p\n", __FUNCTION__, &final);
+		DPRINTK("TCPCP : %s : final_p=0x%p\n", __FUNCTION__, final_p);
+	}
+
+	/* get Routing Table. */
+	error = tcpcp_ip6_dst_lookup(sk, &dst, &fl);
+	if (error != 0) {
+		DPRINTK("TCPCP : %s : [Error] tcp_ip6_dst_lookup failure."
+			" error=%d\n", __FUNCTION__, error);
+		goto err;
+	}
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : after tcpcp_ip6_dst_lookup.\n", __FUNCTION__);
+
+	/* set daddr from Routing Table ? */
+	if (final_p != NULL) {
+		ipv6_addr_copy(&fl.fl6_dst, final_p);
+		/* @@@ for DEBUG @@@ */
+		DPRINTK("TCPCP : %s : final_p   =%04x:%04x:%04x:%04x:"
+			"%04x:%04x:%04x:%04x\n", __FUNCTION__,
+			ntohs(final_p->s6_addr16[0]),
+			ntohs(final_p->s6_addr16[1]),
+			ntohs(final_p->s6_addr16[2]),
+			ntohs(final_p->s6_addr16[3]),
+			ntohs(final_p->s6_addr16[4]),
+			ntohs(final_p->s6_addr16[5]),
+			ntohs(final_p->s6_addr16[6]),
+			ntohs(final_p->s6_addr16[7]));
+		DPRINTK("TCPCP : %s : fl.fl6_dst=%04x:%04x:%04x:%04x:"
+			"%04x:%04x:%04x:%04x\n", __FUNCTION__,
+			ntohs(fl.fl6_dst.s6_addr16[0]),
+			ntohs(fl.fl6_dst.s6_addr16[1]),
+			ntohs(fl.fl6_dst.s6_addr16[2]),
+			ntohs(fl.fl6_dst.s6_addr16[3]),
+			ntohs(fl.fl6_dst.s6_addr16[4]),
+			ntohs(fl.fl6_dst.s6_addr16[5]),
+			ntohs(fl.fl6_dst.s6_addr16[6]),
+			ntohs(fl.fl6_dst.s6_addr16[7]));
+	}
+
+	/* .... */
+	error = xfrm_lookup(&dst, &fl, sk, 0);
+	if (error < 0) {
+		DPRINTK("TCPCP : %s : [Error] xfrm_lookup failure. error=%d\n",
+			__FUNCTION__, error);
+
+		/* @@@ for DEBUG @@@ */
+		DPRINTK("TCPCP : %s : dst->__refcnt.counter=%d\n",
+			__FUNCTION__, dst->__refcnt.counter);
+
+		dst_release(dst);
+		/* @@@ for DEBUG @@@ */
+		DPRINTK("TCPCP : %s : dst->__refcnt.counter=%d\n",
+			__FUNCTION__, dst->__refcnt.counter);
+
+		goto err;
+	}
+	/* @@@ for DEBUG @@@ */
+        DPRINTK("TCPCP : %s : after xfrm_lookup.\n", __FUNCTION__);
+
+	/* change state from TCP_CLOSE to TCP_SYN_SENT.*/
+	tcp_set_state(sk, TCP_SYN_SENT);
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : sk->sk_state=%u\n", __FUNCTION__, sk->sk_state);
+
+	/* bind a port for a connect operation and hash it. */
+	error = tcpcp_v6_hash_connect(sk);
+	if (error != 0) {
+		/* only -EADDRNOTAVAIL. not return 1. */
+		DPRINTK("TCPCP : %s : [Error] tcp_v6_hash_connect failure."
+			" error=%d\n", __FUNCTION__, error);
+
+		/* @@@ for DEBUG @@@ */
+		DPRINTK("TCPCP : %s : dst->__refcnt.counter =%d\n",
+			__FUNCTION__, dst->__refcnt.counter);
+
+		tcp_set_state(sk, TCP_CLOSE);
+		dst_release(dst);
+		/* @@@ for DEBUG @@@ */
+		DPRINTK("TCPCP : %s : sk->sk_state=%u\n",
+			__FUNCTION__, sk->sk_state);
+		DPRINTK("TCPCP : %s : dst->__refcnt.counter=%d\n",
+			__FUNCTION__, dst->__refcnt.counter);
+
+		goto err;
+	}
+	/* @@@ for DEBUG @@@ */
+        DPRINTK("TCPCP : %s : after tcpcp_v6_hash_connect.\n", __FUNCTION__);
+
+	/* set Routing Table. */
+	ip6_dst_store(sk, dst, NULL);
+	sk->sk_route_caps
+	    = dst->dev->features & ~(NETIF_F_IP_CSUM | NETIF_F_TSO);
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : dst->dev->features=%d\n",
+		__FUNCTION__, dst->dev->features);
+	DPRINTK("TCPCP : %s : sk->sk_route_caps =%d\n",
+		__FUNCTION__, sk->sk_route_caps);
+
+
+
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : dst->header_len    =%d\n",
+		__FUNCTION__, dst->header_len);
+	DPRINTK("TCPCP : %s : tp->ext2_header_len=%u\n",
+		__FUNCTION__, tp->ext2_header_len);
+
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : tp->mss_cache    =%u\n",
+		__FUNCTION__, tp->mss_cache);
+	DPRINTK("TCPCP : %s : tp->mss_cache_std=%u\n",
+		__FUNCTION__, tp->mss_cache_std);
+	DPRINTK("TCPCP : %s : tp->pmtu_cookie  =%u\n",
+		__FUNCTION__, tp->pmtu_cookie);
+
+	/* .... */
+	tcp_sync_mss(sk, dst_mtu(dst));
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : tp->mss_cache    =%u\n",
+                __FUNCTION__, tp->mss_cache);
+        DPRINTK("TCPCP : %s : tp->mss_cache_std=%u\n",
+                __FUNCTION__, tp->mss_cache_std);
+        DPRINTK("TCPCP : %s : tp->pmtu_cookie  =%u\n",
+                __FUNCTION__, tp->pmtu_cookie);
+
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : tp->window_clamp=%u\n",
+		__FUNCTION__, tp->window_clamp);
+
+	/* set window_clamp. */
+	if (tp->window_clamp == 0)
+		tp->window_clamp = dst_metric(dst, RTAX_WINDOW);
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : tp->window_clamp=%u\n",
+		__FUNCTION__, tp->window_clamp);
+
+	/* end. */
+	DPRINTK("TCPCP : %s : end.\n", __FUNCTION__);
+	return 0;
+
+err:
+	inet->dport = 0;
+	sk->sk_route_caps = 0;
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : inet->dport=%u\n",
+		__FUNCTION__, inet->dport);
+	DPRINTK("TCPCP : %s : sk->sk_route_caps=%d\n",
+		__FUNCTION__, sk->sk_route_caps);
+
+	/* end. */
+	DPRINTK("TCPCP : %s : end. error=%d\n", __FUNCTION__, error);
+	return error;
+}
+#endif /* defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE) */
+
+/**
+ * tcpcp_v4connect - Step B : TCP/IPv4 connect.
+ *
+ * This function is based on tcp_ipv4.c:tcp_v4_connect().
+ * It walks TCP through to the SYN_SENT state.
+ * Caller must lock socket.
+ *
+ * [Args]
+ *   (IN) *sk : TCP socket
+ * 
+ * [Return]
+ *   0             : OK.
+ *  -EINVAL        : NG.
+ *  -ENETUNREACH   : NG.
+ *  -ENOBUFS       : NG.
+ *  -EPERM         : NG.
+ *  -EAGAIN        : NG.
+ *  -ERESTART      : NG.
+ *  -EADDRNOTAVAIL : NG.
+ *   other         : NG. (xfrm_lookup)
+ **/
+static int tcpcp_v4connect(struct sock *sk)
+{
+	struct inet_sock *inet = inet_sk(sk);
+	struct tcp_sock *tp = tcp_sk(sk);
+	struct rtable *rt;
+	u32 daddr, nexthop;
+	struct flowi fl;
+	int error;
+
+	/* plug-in. */
+	plugin_dummy();
+
+	/* start. */
+	DPRINTK("TCPCP : %s : start. sk=0x%p\n", __FUNCTION__, sk);
+
+	/* set nexthop. */
+	nexthop = daddr = inet->daddr;
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : inet->daddr=0x%x\n", __FUNCTION__, inet->daddr);
+	DPRINTK("TCPCP : %s : nexthop    =0x%x\n", __FUNCTION__, nexthop);
+
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : inet->opt=0x%p\n", __FUNCTION__, inet->opt);
+	DPRINTK("TCPCP : %s : inet->opt->srr=%u\n",
+		__FUNCTION__, inet->opt->srr);
+
+	if ((inet->opt != NULL) && (inet->opt->srr != 0)) {
+		if (daddr == 0) {
+			DPRINTK("TCPCP : %s : [Error] daddr is 0.0.0.0.\n",
+				__FUNCTION__);
+			return -EINVAL;
+		}
+		nexthop = inet->opt->faddr;
+		/* @@@ for DEBUG @@@ */
+		DPRINTK("TCPCP : %s : inet->opt->faddr=0x%x\n",
+			__FUNCTION__, inet->opt->faddr);
+	}
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : nexthop=0x%x\n", __FUNCTION__, nexthop);
+
+	/*
+	 * This code is based on include/net/route.h:ip_route_connect().
+	 */
+	fl.oif = sk->sk_bound_dev_if;
+	fl.fl4_dst = nexthop;
+	fl.fl4_src = inet->saddr;
+	fl.fl4_tos = RT_CONN_FLAGS(sk);
+	fl.proto = IPPROTO_TCP;
+	fl.fl_ip_sport = inet->sport;
+	fl.fl_ip_dport = inet->dport;
+
+	/* get Routing Table. */
+	if ((nexthop == 0) || (inet->saddr == 0)) {
+		error = tcpcp_ip_route_output_key(&rt, &fl);
+		if (error != 0) {
+			DPRINTK("TCPCP : %s : [Error] tcp_ip_route_output_key"
+				" failure. error=%d\n", __FUNCTION__, error);
+			return error;
+		}
+
+		/* @@@ for DEBUG @@@ */
+		DPRINTK("TCPCP : %s : rt->u.dst.__refcnt.counter =%d\n",
+			__FUNCTION__, rt->u.dst.__refcnt.counter);
+
+		fl.fl4_dst = rt->rt_dst;
+		fl.fl4_src = rt->rt_src;
+		ip_rt_put(rt);
+		/* @@@ for DEBUG @@@ */
+		DPRINTK("TCPCP : %s : rt->rt_dst=0x%x\n",
+			__FUNCTION__, rt->rt_dst);
+		DPRINTK("TCPCP : %s : fl.fl4_dst=0x%x\n",
+			__FUNCTION__, fl.fl4_dst);
+                DPRINTK("TCPCP : %s : rt->rt_src=0x%x\n",
+                        __FUNCTION__, rt->rt_src);
+		DPRINTK("TCPCP : %s : fl.fl4_src=0x%x\n",
+			__FUNCTION__, fl.fl4_src);
+                DPRINTK("TCPCP : %s : rt->u.dst.__refcnt.counter=%d\n",
+                        __FUNCTION__, rt->u.dst.__refcnt.counter);
+
+		rt = NULL;
+	}
+
+	error =  tcpcp_ip_route_output_flow(&rt, &fl, sk, 0);
+	if (error < 0) {
+		DPRINTK("TCPCP : %s : [Error] tcp_ip_route_output_flow failure"
+			" (1). error=%d\n", __FUNCTION__, error);
+		return error;
+	}
+
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : rt->rt_flags=%u\n", __FUNCTION__, rt->rt_flags);
+
+	/* check flags of Routing Table. */
+	if (rt->rt_flags & (RTCF_MULTICAST | RTCF_BROADCAST)) {
+		DPRINTK("TCPCP : %s : [Error] rt_flags is multi/broadcast.\n",
+			__FUNCTION__);
+
+		ip_rt_put(rt);
+		/* @@@ DEBUG @@@ */
+		DPRINTK("TCPCP : %s : rt->u.dst.__refcnt.counter=%d\n",
+			__FUNCTION__, rt->u.dst.__refcnt.counter);
+
+		return -ENETUNREACH;
+	}
+
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : inet->opt     =0x%p\n", __FUNCTION__, inet->opt);
+	DPRINTK("TCPCP : %s : inet->opt->srr=%u\n",
+		__FUNCTION__, inet->opt->srr);
+
+	/* set daddr from Routing Table. */
+	if (inet->opt == NULL || inet->opt->srr == 0) {
+	 	daddr = rt->rt_dst;
+		/* @@@ for DEBUG @@@ */
+		DPRINTK("TCPCP : %s : daddr=0x%x\n", __FUNCTION__, daddr);
+	}
+
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : sysctl_tcp_tw_recycle=%d\n",
+		__FUNCTION__, sysctl_tcp_tw_recycle);
+	DPRINTK("TCPCP : %s : tp->ts_recent_stamp=%lu\n",	
+		__FUNCTION__, tp->ts_recent_stamp);
+	DPRINTK("TCPCP : %s : rt->rt_dst=0%x\n", __FUNCTION__, rt->rt_dst);
+	DPRINTK("TCPCP : %s : daddr     =0x%x\n", __FUNCTION__, daddr);
+
+	if ((tcp_death_row.sysctl_tw_recycle != 0) && (tp->rx_opt.ts_recent_stamp == 0)
+					 && (rt->rt_dst == daddr)) {
+		/*
+		 * This code is based on include/net/route.h:rt_get_peer().
+		 */
+		struct inet_peer *peer;
+
+		if (rt->peer != 0) {
+			peer = rt->peer;
+			/* @@@ for DEBUG @@@ */
+			DPRINTK("TCPCP : %s : rt->peer=0x%p\n",
+				__FUNCTION__, rt->peer);
+			DPRINTK("TCPCP : %s : peer    =0x%p\n",
+				__FUNCTION__, peer);
+		} else {
+			/* @@@ for DEBUG @@@ */
+			DPRINTK("TCPCP : %s : before tcpcp_rt_bind_peer.\n",
+				__FUNCTION__);
+
+			tcpcp_rt_bind_peer(rt, 0);
+			peer = rt->peer;
+
+			/* @@@ for DEBUG @@@ */
+			DPRINTK("TCPCP : %s : after tcpcp_rt_bind_peer.\n",
+				__FUNCTION__);
+			DPRINTK("TCPCP : %s : rt->peer=0x%p\n",
+				__FUNCTION__, rt->peer);
+			DPRINTK("TCPCP : %s : peer    =0x%p\n",
+				__FUNCTION__, peer);
+		}
+
+		/* VJ's idea. 
+		 * we save last timestamp seen from the destination in peer
+		 * table, when entering state TIME-WAIT and initialize
+		 * ts_recent from it, when trying new connection. */
+
+		/* @@@ for DEBUG @@@ */
+		DPRINTK("TCPCP : %s : peer=0x%p\n", __FUNCTION__, peer);
+		if (peer != 0) {
+			DPRINTK("TCPCP : %s : peer->tcp_ts_stamp+TCP_PAWS_MSL"
+				"=%lu\n", __FUNCTION__,
+				peer->tcp_ts_stamp + TCP_PAWS_MSL);
+			DPRINTK("TCPCP : %s : xtime.tv_sec                   "
+				"=%ld\n", __FUNCTION__, xtime.tv_sec);
+		}
+
+		if ((peer != 0)
+		    && (peer->tcp_ts_stamp + TCP_PAWS_MSL >= xtime.tv_sec)) {
+			tp->rx_opt.ts_recent_stamp = peer->tcp_ts_stamp;
+			tp->rx_opt.ts_recent = peer->tcp_ts;
+			/* @@@ for DEBUG @@@ */
+			DPRINTK("TCPCP : %s : peer->tcp_ts_stamp =%lu\n",
+				__FUNCTION__, peer->tcp_ts_stamp);
+			DPRINTK("TCPCP : %s : tp->ts_recent_stamp=%lu\n",
+				__FUNCTION__, tp->ts_recent_stamp);
+			DPRINTK("TCPCP : %s : peer->tcp_ts =%u\n",
+				__FUNCTION__, peer->tcp_ts);
+			DPRINTK("TCPCP : %s : tp->ts_recent=%u\n",
+				__FUNCTION__, tp->ts_recent);
+		}
+	}
+
+	/* change state from TCP_CLOSE to TCP_SYN_SENT. */
+	tcp_set_state(sk, TCP_SYN_SENT);
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : sk->sk_state=%d\n", __FUNCTION__, sk->sk_state);
+
+	/* bind a port for a connect operation and hash it. */
+	error = tcpcp_v4_hash_connect(sk);
+	if (error != 0) {
+		/* only -EADDRNOTAVAIL. */
+		DPRINTK("TCPCP : %s : [Error] tcp_v4_hash_connect failure."
+			" error=%d\n", __FUNCTION__, error);
+		goto err;
+	}
+
+	/*
+	 * This code is based on include/net/route.h:ip_route_newports().
+	 */
+
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : inet->sport       =%u\n",
+		 __FUNCTION__, inet->sport);
+	DPRINTK("TCPCP : %s : rt->fl.fl_ip_sport=%u\n",
+		__FUNCTION__, rt->fl.fl_ip_sport);
+	DPRINTK("TCPCP : %s : inet->dport       =%u\n",
+		__FUNCTION__, inet->dport);
+	DPRINTK("TCPCP : %s : rt->fl.fl_ip_dport=%u\n",
+		__FUNCTION__, rt->fl.fl_ip_dport);
+
+	/* .... */
+	if ((inet->sport != rt->fl.fl_ip_sport) ||
+	    (inet->dport != rt->fl.fl_ip_dport)) {
+
+		memcpy(&fl, &(rt)->fl, sizeof(fl));
+		fl.fl_ip_sport = inet->sport;
+		fl.fl_ip_dport = inet->dport;
+		ip_rt_put(rt);
+		rt = NULL;
+
+		/* @@@ for DEBUG @@@ */
+		DPRINTK("TCPCP : %s : fl.fl_ip_sport=%u\n",
+			__FUNCTION__, fl.fl_ip_sport);
+		DPRINTK("TCPCP : %s : fl.fl_ip_dport=%u\n",
+			__FUNCTION__, fl.fl_ip_dport);
+
+		error = tcpcp_ip_route_output_flow(&rt, &fl, sk, 0);
+		if (error != 0) {
+			DPRINTK("TCPCP : %s : [Error] tcp_ip_route_output_flow"
+				" failure (2). error=%d\n",
+				__FUNCTION__, error);	
+			goto err;
+		}
+	}
+
+	/* @@@ for DEBUG */
+	DPRINTK("TCPCP : %s : &(rt->u.dst)=0x%p\n",
+		__FUNCTION__, &(rt->u.dst));
+	DPRINTK("TCPCP : %s : sk->sk_dst_cache=0x%p\n",
+		__FUNCTION__, sk->sk_dst_cache);
+	DPRINTK("TCPCP : %s : sk->sk_route_caps=%u\n",
+		__FUNCTION__, sk->sk_route_caps);
+
+	/* set Routing Table.  */
+	sk_setup_caps(sk, &(rt->u.dst));
+
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : sk->sk_dst_cache=0x%p\n",
+		__FUNCTION__, sk->sk_dst_cache);
+	DPRINTK("TCPCP : %s : sk->sk_route_caps=%u\n",
+		__FUNCTION__, sk->sk_route_caps);
+
+
+
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : rt->u.dst.header_len=%u\n",
+		__FUNCTION__, rt->u.dst.header_len);
+	DPRINTK("TCPCP : %s : tp->ext2_header_len =%u\n",
+		__FUNCTION__, tp->ext2_header_len);
+
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : tp->mss_cache    =%u\n",
+		__FUNCTION__, tp->mss_cache);
+	DPRINTK("TCPCP : %s : tp->mss_cache_std=%u\n",
+		__FUNCTION__, tp->mss_cache_std);
+	DPRINTK("TCPCP : %s : tp->pmtu_cookie  =%u\n",
+		__FUNCTION__, tp->pmtu_cookie);
+
+	/* .... */
+	tcp_sync_mss(sk, dst_mtu(&(rt->u.dst)));
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : tp->mss_cache    =%u\n",
+		__FUNCTION__, tp->mss_cache);
+	DPRINTK("TCPCP : %s : tp->mss_cache_std=%u\n",
+		__FUNCTION__, tp->mss_cache_std);
+	DPRINTK("TCPCP : %s : tp->pmtu_cookie  =%u\n",
+		__FUNCTION__, tp->pmtu_cookie);
+
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : tp->window_clamp=%u\n",
+		__FUNCTION__, tp->window_clamp);
+
+	/* set window_clamp. */
+	if (tp->window_clamp == 0)
+		tp->window_clamp = dst_metric(&(rt->u.dst), RTAX_WINDOW);
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : tp->window_clamp=%u\n",
+		__FUNCTION__, tp->window_clamp);
+
+	rt = NULL;
+
+	/* end. */
+	DPRINTK("TCPCP : %s : end.\n", __FUNCTION__);
+	return 0;
+
+err:
+	/* This unhashes the socket and releases the local port,
+	 * if necessary. */
+
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : @@@ ERROR OPERATION! @@@\n", __FUNCTION__);
+	DPRINTK("TCPCP : %s : sk->sk_state=%u\n",
+		__FUNCTION__, sk->sk_state);
+	if (rt != NULL)
+		DPRINTK("TCPCP : %s : rt->u.dst.__refcnt.counter =%d\n",
+			__FUNCTION__, rt->u.dst.__refcnt.counter);
+
+	tcp_set_state(sk, TCP_CLOSE);
+	ip_rt_put(rt);
+	sk->sk_route_caps = 0;
+	inet->dport = 0;
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : sk->sk_state=%u\n", __FUNCTION__, sk->sk_state);
+	if (rt != NULL)
+		DPRINTK("TCPCP : %s : rt->u.dst.__refcnt.counter =%d\n",
+			__FUNCTION__, rt->u.dst.__refcnt.counter);
+	DPRINTK("TCPCP : %s : sk->sk_route_caps=%d\n",
+		__FUNCTION__, sk->sk_route_caps);
+	DPRINTK("TCPCP : %s : inet->dport=%u\n", __FUNCTION__, inet->dport);
+
+	/* end. */
+	DPRINTK("TCPCP : %s : end. error=%d\n", __FUNCTION__, error);
+	return error;
+}
+
+/**
+ * do_start - start TCP socket.
+ *
+ * Caller must lock socket.
+ *
+ * [Args]
+ *   (IN) *sk : TCP socket
+ *
+ * [Return]
+ *   0      : OK
+ *  -EINVAL        : NG. (v6connect/v4connect)
+ *  -EADDRNOTAVAIL : NG. (v6connect/v4connect)
+ *  -EPERM         : NG. (v6connect/v4connect)
+ *  -EAGAIN        : NG. (v6connect/v4connect)
+ *  -ERESTART      : NG. (v6connect/v4connect)
+ *   1             : NG. (v6connect)
+ *  -ENETUNREACH   : NG. (v4connect)
+ *  -ENOBUFS       : NG. (v4connect)
+ *  -EADDRINUSE    : NG. (v6bind/v4bind)
+ *  -ENODEV        : NG. (v6bind)
+ *  -EADDRNOTAVAIL : NG. (v6bind)
+ *   other         : NG. (v6connet/v4connet)
+ **/
+static int do_start(struct sock *sk)
+{
+	struct tcp_sock *tp = tcp_sk(sk);
+	struct sk_buff *skb;
+	int error;
+
+	/* plug-in. */
+	plugin_dummy();
+
+	/* start. */
+	DPRINTK("TCPCP : %s : start. sk=0x%p\n", __FUNCTION__, sk);
+
+	if (tp->af_specific->queue_xmit != tcpcp_discard_xmit) {
+		DPRINTK("TCPCP : %s : TCPCP socket stop proccess is not"
+			" performed.\n", __FUNCTION__);
+		return 0;
+	}
+
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : tp->set_flag=%u\n", __FUNCTION__, tp->set_flag);
+
+	if (tp->set_flag == TCPCP_SET_FLAG_ON) {
+		DPRINTK("TCPCP : %s : TCPCP set SIs proccess is performed.\n",
+			__FUNCTION__);
+#if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)
+		if (sk->sk_family == PF_INET6) {
+			/* Step A : bind. */
+			error = tcpcp_v6bind(sk);
+			if (error != 0) {
+				DPRINTK("TCPCP : %s : [Error] can't bind."
+					" error=%d\n", __FUNCTION__, error);
+				return error;
+			}
+
+			/* Step B : connect. */
+			error = tcpcp_v6connect(sk);
+		} else 
+#endif
+		{
+			/* Step A : bind. */
+			error = tcpcp_v4bind(sk);
+			if (error != 0) {
+				DPRINTK("TCPCP : %s : [Error] can't bind."
+					" error=%d\n", __FUNCTION__, error);
+				return error;
+			}
+
+			/* Step B : connect. */
+			error = tcpcp_v4connect(sk);
+		}
+		if (error != 0) {
+			DPRINTK("TCPCP : %s : [Error] can't connect."
+				" error=%d\n", __FUNCTION__, error);
+			return error;
+		}
+
+		/* .... */
+		sk->sk_socket->state = SS_CONNECTED;
+		tcp_set_state(sk, TCP_ESTABLISHED);
+	}
+
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : sk->sk_socket->state=%d\n",
+		__FUNCTION__, sk->sk_socket->state);
+	DPRINTK("TCPCP : %s : sk->sk_state=%d\n",
+		__FUNCTION__, sk->sk_state);
+
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : sk->sk_filter=0x%p\n",
+		__FUNCTION__, sk->sk_filter);
+	DPRINTK("TCPCP : %s : &drop_all    =0x%p\n", __FUNCTION__, &drop_all);
+
+	/* release dummy socket filter. */
+	if (sk->sk_filter != NULL) {
+		sk_filter_release(sk, sk->sk_filter);
+		sk->sk_filter = NULL;
+		/* @@@ for DEBUG @@@ */
+		DPRINTK("TCPCP : %s : socket filter is released.\n",
+			__FUNCTION__);
+		DPRINTK("TCPCP : %s : drop_all.refcnt=%d\n",
+			__FUNCTION__, atomic_read(&(drop_all.refcnt)));
+	}
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : sk->sk_filter=0x%p\n",
+		__FUNCTION__, sk->sk_filter);
+
+	tcpcp_change_xmit(sk, TCPCP_FLAG_START);
+
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : tp->snd_nxt   =%lu\n",
+		__FUNCTION__, (unsigned long) tp->snd_nxt);
+	DPRINTK("TCPCP : %s : tp->rcv_nxt   =%lu\n",
+		__FUNCTION__, (unsigned long) tp->rcv_nxt);
+	DPRINTK("TCPCP : %s : tp->rcv_wup   =%lu\n",
+		__FUNCTION__, (unsigned long) tp->rcv_wup);
+	DPRINTK("TCPCP : %s : tp->copied_seq=%lu\n",
+		__FUNCTION__, (unsigned long) tp->copied_seq);
+
+	/* .... */
+	skb = skb_peek(&sk->sk_write_queue);
+	if (skb == NULL) {
+		DPRINTK("TCPCP : %s : Write queue is empty.\n", __FUNCTION__);
+
+		if (tp->set_flag == TCPCP_SET_FLAG_ON) {
+			DPRINTK("TCPCP : %s : ACK whose payload size of" \
+				" a packet is 0 is transmitted.\n",
+				__FUNCTION__);
+			tcpcp_send_probe0(sk);
+		}
+
+		/* end. */
+		DPRINTK("TCPCP : %s : end.\n", __FUNCTION__);
+		return 0;
+	}
+
+	if (sk->sk_send_head != skb) {
+		DPRINTK("TCPCP : %s : Got something to retransmit.\n",
+			__FUNCTION__);
+
+		/* @@@ for DEBUG @@@ */
+		DPRINTK("TCPCP : %s : skb=0x%p\n", __FUNCTION__, skb);
+		DPRINTK("TCPCP : %s : TCP_SKB_CB(skb)->seq    =%lu\n",
+			__FUNCTION__, (unsigned long) TCP_SKB_CB(skb)->seq);
+		DPRINTK("TCPCP : %s : TCP_SKB_CB(skb)->end_seq=%lu\n",
+			__FUNCTION__, (unsigned long) TCP_SKB_CB(skb)->end_seq);
+		DPRINTK("TCPCP : %s : tp->snd_una             =%lu\n",
+			__FUNCTION__, (unsigned long) tp->snd_una);
+		DPRINTK("TCPCP : %s : sk->sk_wmem_alloc=%lu\n",
+			__FUNCTION__,
+			(unsigned long) atomic_read(&sk->sk_wmem_alloc));
+		DPRINTK("TCPCP : %s : sk->sk_wmem_queued=%lu\n",
+			__FUNCTION__, (unsigned long) sk->sk_wmem_queued);
+		DPRINTK("TCPCP : %s : sk->sk_sndbuf     =%lu\n",
+			__FUNCTION__, (unsigned long) sk->sk_sndbuf);
+		DPRINTK("TCPCP : %s : tp->snd_wnd=%lu\n",
+			__FUNCTION__, (unsigned long) tp->snd_wnd);
+		DPRINTK("TCPCP : %s : tp->packets_out=%lu\n",
+			__FUNCTION__,
+			(unsigned long) tcp_get_pcount(&tp->packets_out));
+
+		tcpcp_retransmit_skb(sk, skb_peek(&sk->sk_write_queue));
+		inet_csk_reset_xmit_timer(sk, ICSK_TIME_RETRANS, inet_csk(sk)->icsk_rto, TCP_RTO_MAX);
+	}
+
+	/* end. */
+	DPRINTK("TCPCP : %s : end.\n", __FUNCTION__);
+	return 0;
+}
+
+/**
+ * do_tcpcp_start - start TCP sockets.
+ *
+ * [Args]
+ *   (IN) *sk       : TCP socket
+ *   (IN) *r_entry  : Request Entry
+ *   (IN) *user_res : Processing Result Info.
+ *
+ * [Return]
+ *   0      : OK.
+ *  -ENOMEM : NG. (no memory)
+ **/
+static int do_tcpcp_start(struct sock *sk, struct tcpcp_req_entry *r_entry,
+			  struct result *user_res)
+{
+	struct task_struct *tsk = current;
+	struct files_struct *files = tsk->files;
+	struct tcpcp_com_entry *fdr_entry;
+	unsigned int fd;
+	unsigned int fd_all = 0;
+	unsigned int fd_ng = 0;
+	int error;
+	struct fdtable *fdt;
+	/* plug-in. */
+	plugin_dummy();
+
+	/* start. */
+	DPRINTK("TCPCP : %s : start. sk=0x%p, r_entry=0x%p, user_res=0x%p\n",
+		__FUNCTION__, sk, r_entry, user_res);
+
+	if (r_entry->flag & TCPCP_FLAG_ALL) {
+ 		/* add FDR Info. Entry. (only "ALL")*/
+		error = tcpcp_add_com_entry(r_entry->flag, &(r_entry->f_entry));
+		if (error != 0)
+			return -ENOMEM;
+	}
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : r_entry->f_entry=0x%p\n",
+		__FUNCTION__, r_entry->f_entry);
+
+	/* initialize now FDR Info. Entry. */
+	fdr_entry = r_entry->f_entry;
+	fdt = files_fdtable(files);
+	/* search FD. */
+	for (fd = 0; fd < fdt->max_fds; fd++) {
+		struct sock *sk_i;
+		int ret;
+
+		/* check FD and get SOCKET_I(). */
+		sk_i = tcpcp_get_sk_i(sk, fd, r_entry);
+		if (sk_i == NULL) {
+			/* @@@ for DEBUG @@@ */
+			DPRINTK("TCPCP : %s : sk_i is NULL.\n", __FUNCTION__);
+
+			continue;
+		}
+
+		/* start TCP socket. */
+		lock_sock(sk_i);
+		ret = do_start(sk_i);
+		release_sock(sk_i);
+		/* @@@ for DEBUG @@@ */
+		DPRINTK("TCPCP : %s : ret=%d\n", __FUNCTION__, ret);
+
+		fd_all++;
+
+		if (!(r_entry->flag & TCPCP_FLAG_ALL)) {
+			/* @@@ for DEBUG @@@ */
+			DPRINTK("TCPCP : %s : Break for loop.\n", __FUNCTION__);
+
+			if (ret != 0)
+				return ret;
+			break;
+		}
+
+		/* Only ALL, the following processings are performed. */
+		if (ret != 0)
+			fd_ng++;
+
+		/* make FDR Info. (only "ALL") */
+		error = tcpcp_make_res(fd, ret, &fdr_entry);
+		if (error != 0) {
+			/* only -ENOMEM. */
+			DPRINTK("TCPCP : %s : [Error] can't make FDR Info."
+				" error=%d\n", __FUNCTION__, error);
+			/* Caller delete Request Entry with common entries. */
+			return error;
+		}
+	}
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : Loop count=%d\n", __FUNCTION__, fd);
+
+#ifdef CONFIG_TCPCP_DEBUG
+	/* @@@ print Process List with lock. (for DEBUG) @@@ */
+	print_list();
+#endif
+
+	/* set Processing Result Info. */
+	user_res->fd_all = fd_all;
+	user_res->fd_ng = fd_ng;
+	user_res->buf_size = 0;
+	user_res->fdrs_size = sizeof(struct fdr) * fd_all;
+	memcpy(&(r_entry->res), user_res, sizeof(struct result));
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : r_entry->res->fd_all   =%u\n",
+		__FUNCTION__, r_entry->res.fd_all);
+	DPRINTK("TCPCP : %s : r_entry->res->fd_ng    =%u\n",
+		__FUNCTION__, r_entry->res.fd_ng);
+	DPRINTK("TCPCP : %s : r_entry->res->buf_size =%u\n",
+		__FUNCTION__, r_entry->res.buf_size);
+	DPRINTK("TCPCP : %s : r_entry->res->fdrs_size=%u\n",
+		__FUNCTION__, r_entry->res.fdrs_size);
+
+	/* end. */
+	DPRINTK("TCPCP : %s : end.\n", __FUNCTION__);
+	return 0;
+}
+
+
+/* ----- get TCP Socket Informations (TCP-SIs),
+         get FD Result (FDR) Informations ---------------------------------- */
+ 
+/**
+ * do_get_si - get TCP-SIs.
+ *
+ * Caller must reset timeout.
+ *
+ * [Args]
+ *   (IN) *r_entry    : Request Entry
+ *   (OUT) *user_si   : TCP-SIs returned to user
+ *   (OUT) *user_size : length of TCP-SIs returned to user
+ *
+ * [Retrun]
+ *   0      : OK.
+ *  -EFAULT : NG.
+ **/
+static int do_get_si(struct tcpcp_req_entry *r_entry,
+		     struct tcpcp_total_si_hdr *user_si,
+		     unsigned int *user_size)
+{
+	struct tcpcp_com_entry *si_entry;
+	char *p_si = NULL;
+	unsigned int data_len;
+	int error;
+
+	/* plug-in. */
+	plugin_dummy();
+
+	/* start. */
+	DPRINTK("TCPCP : %s : start. r_entry=0x%p\n", __FUNCTION__, r_entry);
+
+	/* put size of TCP-SIs to userland. */
+	error = put_user(r_entry->res.buf_size, user_size);
+	if (error != 0)
+		return -EFAULT;
+
+	p_si = (char *)user_si;
+	si_entry = r_entry->s_entry;
+
+	while (si_entry != NULL) {
+		/* @@@ for DEBUG @@@ */
+		DPRINTK("TCPCP : %s : si_entry=0x%p.\n",
+			__FUNCTION__, si_entry);
+
+		data_len = si_entry->data_len;
+
+		/* copy TCP-SIs from Kernel to userland. */
+		error = copy_to_user(p_si, si_entry->data, data_len);
+		if (error != 0)
+			return -EFAULT;
+
+		p_si += data_len;
+		si_entry = si_entry->next;
+	}
+
+	/* end. */
+	DPRINTK("TCPCP : %s : end.\n", __FUNCTION__);
+	return 0;
+}
+
+/**
+ * do_get_res_size - get result structure to get size of FDRs.
+ *
+ * [Args]
+ *   (IN) *sk       : socket
+ *   (IN) *user_res : result structure
+ *
+ * [Return]
+ *   0      : OK.
+ *  -EFAULT : NG.
+ **/
+static int do_get_res_size(struct sock *sk, struct result *user_res)
+{
+	struct tcpcp_req_entry *r_entry;
+
+	/* plug-in. */
+	plugin_dummy();
+
+	/* start. */
+	DPRINTK("TCPCP : %s : start. sk=0x%p, user_res=0x%p\n",
+		 __FUNCTION__, sk, user_res);
+
+#ifdef CONFIG_TCPCP_DEBUG
+	/* @@@ print Process List with lock. (for DEBUG) @@@ */
+	print_list();
+#endif
+
+	/* lookup Request Entry and unlink from Timeout List. */
+	r_entry = tcpcp_reset_timeout(sk);
+	if (r_entry == NULL) {
+		DPRINTK("TCPCP : %s : [Error] can't lookup Request Entry.\n",
+			 __FUNCTION__);
+		return -EFAULT;
+	}
+
+	if (r_entry->res.fdrs_size == 0) {
+		DPRINTK("TCPCP : %s : [Error] fdrs_size is 0.\n", __FUNCTION__);
+		/* delete Request Entry with common entries. */
+		tcpcp_del_req_entry(r_entry);
+		return -EFAULT;
+	}
+
+#ifdef CONFIG_TCPCP_DEBUG
+	/* @@@ print Process List with lock. (for DEBUG) @@@ */
+	print_list();
+#endif
+
+	/* copy FDR Info. */
+	memcpy(user_res, &(r_entry->res), sizeof(struct result));
+
+	/* link to Timeout List. */
+	tcpcp_set_timeout(r_entry);
+
+	/* end. */
+	DPRINTK("TCPCP : %s : end.\n", __FUNCTION__);
+	return 0;
+}
+
+/**
+ * do_get_res - get FDR Info.
+ *
+ * Caller must lock socket.
+ *
+ * [Args]
+ *   (IN) *r_entry    : Request Entry
+ *   (OUT) *user_fdrs : each fd processing result informations returned to user
+ *   (OUT) *user_size : size that each fd processing result informations
+ *                      returned to user
+ *
+ * [Return]
+ *   0      : OK.
+ *  -EFAULT : NG.
+ **/
+static int do_get_res(struct tcpcp_req_entry *r_entry, struct fdr *user_fdrs,
+		      unsigned int *user_size)
+{
+	struct tcpcp_com_entry *fdr_entry;
+	char *p_fdrs;
+	unsigned int data_len;
+	int error;
+
+	/* plug-in. */
+	plugin_dummy();
+
+	/* start. */
+	DPRINTK("TCPCP : %s : start. r_entry=0x%p\n", __FUNCTION__, r_entry);
+
+	/* put size of FDR Info. to userland. */
+	error = put_user(r_entry->res.fdrs_size, user_size);
+	if (error != 0)
+		return -EFAULT;
+
+	p_fdrs = (char *)user_fdrs;
+	fdr_entry = r_entry->f_entry;
+
+	while (fdr_entry != NULL) {
+		/* @@@ for DEBUG @@@ */
+		DPRINTK("TCPCP : %s : fdr_entry=0x%p\n",
+			__FUNCTION__, fdr_entry);
+
+		data_len = fdr_entry->data_len;
+
+		/* copy FDR Info. from Kernel to userland. */
+		error = copy_to_user(p_fdrs, fdr_entry->data, data_len);
+		if (error != 0)
+			return -EFAULT;
+
+		p_fdrs += data_len;
+		fdr_entry = fdr_entry->next;
+	}
+
+	/* end. */
+	DPRINTK("TCPCP : %s : end.\n", __FUNCTION__);
+	return 0;
+}
+
+
+/* ----- Substance of a hook ------------------------------------------------ */
+
+/**
+ * __tcpcp_com_ope
+ *      Substance of tcpcp_make_si_hook, tcpcp_make_si_all_hook,
+ *      tcpcp_stop_hook, tcpcp_stop_all_hook, tcpcp_close_all_hook,
+ *      tcpcp_start_hook, tcpcp_start_all_hook and tcpcp_get_res_size_hook.
+ *
+ * [Args]
+ *   (IN) *sk		: socket
+ *   (IN) optname	: option name of TCPCP operations
+ *   (OUT) *user_res	: result info
+ *
+ * [Return]
+ *   0		: OK.
+ *   other	: skip
+ **/
+static int __tcpcp_com_ope(struct sock *sk, int optname,
+			   struct result *user_res)
+{
+	struct tcpcp_req_entry *r_entry = NULL;
+	unsigned char flag = 0;
+	int error;
+
+	/* plug-in. */
+	plugin_dummy();
+
+	/* start. */
+	DPRINTK("TCPCP : %s : start. sk=0x%p, optname=%d\n",
+		__FUNCTION__, sk, optname);
+
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : sk->sk_socket->state=%d\n",
+		__FUNCTION__, sk->sk_socket->state);
+	DPRINTK("TCPCP : %s : sk->sk_state        =%d\n",
+		__FUNCTION__, sk->sk_state);
+
+	/* set TCPCP operation flag. */
+	switch (optname) {
+	case TCPCP_MAKE_SI:
+		flag = TCPCP_FLAG_MAKE_SI;
+		break;
+	case TCPCP_MAKE_SI_ALL:
+		flag = TCPCP_FLAG_MAKE_SI | TCPCP_FLAG_ALL;
+		break;
+	case TCPCP_STOP:
+		flag = TCPCP_FLAG_STOP;
+		break;
+	case TCPCP_STOP_ALL:
+		flag = TCPCP_FLAG_STOP | TCPCP_FLAG_ALL;
+		break;
+	case TCPCP_CLOSE_ALL:
+		flag = TCPCP_FLAG_CLOSE | TCPCP_FLAG_ALL;
+		break;
+	case TCPCP_START:
+		flag = TCPCP_FLAG_START;
+		break;
+	case TCPCP_START_ALL:
+		flag = TCPCP_FLAG_START | TCPCP_FLAG_ALL;
+		break;
+	case TCPCP_GET_RES_SIZE:
+		error = do_get_res_size(sk, user_res);
+		/* @@@ for DEBUG @@@ */
+		DPRINTK("TCPCP : %s : after do_get_res_size. error=%d\n",
+			__FUNCTION__, error);
+		DPRINTK("TCPCP : %s : user_res->fdrs_size=%u\n",
+			__FUNCTION__, user_res->fdrs_size);
+
+		/* if error, return value is always -EFAULT. */
+		return error;
+	default:
+		return -EINVAL;
+	}
+
+	/* check conflict and add Request Entry. */
+	error = tcpcp_add_req_entry(sk, flag, &r_entry);
+	if (error != 0)
+		return error;
+
+#ifdef CONFIG_TCPCP_DEBUG
+	/* @@@ print Process List with lock. (for DEBUG) @@@ */
+	print_list();
+#endif
+
+	/* distribution of the processing to each operation */
+	if (flag & TCPCP_FLAG_MAKE_SI)
+		/* make TCP-SIs */
+		error = do_tcpcp_make_si(sk, r_entry, user_res);
+	else if (flag & TCPCP_FLAG_STOP)
+		/* stop TCP sockets */
+		error = do_tcpcp_stop(sk, r_entry, user_res);
+	else if (flag & TCPCP_FLAG_CLOSE)
+		/* close TCP sockets */
+		error = do_tcpcp_close(sk, r_entry, user_res);
+	else if (flag & TCPCP_FLAG_START)
+		/* start TCP sockets */
+		error = do_tcpcp_start(sk, r_entry, user_res);
+	else
+		return -EINVAL;
+	if (error != 0) {
+		DPRINTK("TCPCP : %s : [Error] do_tcpcp_*** failure. error=%d\n",
+			__FUNCTION__, error);
+
+		/* delete Request Entry with common entries. */
+		tcpcp_del_req_entry(r_entry);
+		return error;
+	}
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : after do_tcpcp_***.\n", __FUNCTION__);
+
+#ifdef CONFIG_TCPCP_DEBUG
+	/* @@@ print Process List with lock. (for DEBUG) @@@ */
+	print_list();
+#endif
+
+	/* check TCPCP operation flag. */
+	switch (optname) {
+
+	case TCPCP_MAKE_SI:
+	case TCPCP_MAKE_SI_ALL:
+	case TCPCP_STOP_ALL:
+	case TCPCP_CLOSE_ALL:
+	case TCPCP_START_ALL:
+		/* link to Timeout List. */
+		tcpcp_set_timeout(r_entry);
+		break;
+
+	case TCPCP_STOP:
+	case TCPCP_START:
+		/* delete Request Entry with common entries. */
+		tcpcp_del_req_entry(r_entry);
+	}
+
+#ifdef CONFIG_TCPCP_DEBUG
+	/* @@@ print Process List with lock. (for DEBUG) @@@ */
+	print_list();
+#endif
+
+	/* end. */
+	DPRINTK("TCPCP : %s : end.\n", __FUNCTION__);
+	return 0;
+}
+
+/**
+ * __tcpcp_set_si - set SIs from user to Kernel.
+ *
+ * [Args]
+ *   (IN) *sk      : socket
+ *   (IN) optname  : option name of TCPCP operations
+ *   (IN) *user_si : TCP-SI data from user (const)
+ *   (IN) *size    : length of TCP-SI data from user
+ *
+ * [Return]
+ *   0      : OK.
+ *  -EINVAL :
+ *  -ENOMEM :
+ *   other  :
+ **/
+static int __tcpcp_set_si(struct sock *sk, int optname,
+			  const struct tcpcp_total_si_hdr *user_si,
+			  unsigned int size)
+{
+	struct tcpcp_req_entry *r_entry = NULL;
+	unsigned char flag;
+	int error = 0;
+
+	/* plug-in. */
+	plugin_dummy();
+
+	/* start. */
+	DPRINTK("TCPCP : %s : start. sk=0x%p, optname=%d, user_si=0x%p,"
+		" size=%u\n", __FUNCTION__, sk, optname, user_si, size);
+
+	/* check TCP-SIs size. */
+	if (size
+	    < sizeof(struct tcpcp_total_si_hdr) + sizeof(struct tcpcp_si_hdr))
+		return -EINVAL;
+	if (size != ntohl(user_si->total_si_length) * 4)
+		return -EINVAL;
+
+	/* set TCPCP operation flag. */
+	flag = TCPCP_FLAG_SET_SI;
+	if (optname == TCPCP_SET_SI_ALL)
+		flag |= TCPCP_FLAG_ALL;
+								
+	/* release socket (lock_sock() is called at tcp_setsockopt().) */
+	release_sock(sk);
+	DPRINTK("TCPCP : %s : socket is unlocked.\n", __FUNCTION__);
+
+	/* check conflict and add Request Entry. */
+	error = tcpcp_add_req_entry(sk, flag, &r_entry);
+	if (error != 0)
+		goto out;
+
+#ifdef CONFIG_TCPCP_DEBUG
+	/* @@@ print Process List with lock. (for DEBUG) @@@ */
+	print_list();
+#endif
+
+	/* set TCP-SIs to Kernel. */
+	error = do_tcpcp_set_si(sk, user_si, r_entry);
+	if (error != 0) {
+		/* @@@ for DEBUG @@@ */
+		DPRINTK("TCPCP : %s : after do_tcpcp_set_si. error=%d\n",
+			__FUNCTION__, error);
+
+		/* delete Request Entry with common entries. */
+		tcpcp_del_req_entry(r_entry);
+		goto out;
+	}
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : after do_tcpcp_set_si.\n", __FUNCTION__);
+
+	if (optname == TCPCP_SET_SI_ALL) {
+		/* link to Timeout List. (only "ALL") */
+		tcpcp_set_timeout(r_entry);
+		/* @@@ for DEBUG @@@ */
+		DPRINTK("TCPCP : %s : req_entry->timeout=%u\n",
+			__FUNCTION__, r_entry->timeout);
+	} else
+		/* delete Request Entry with common entries. (only "ONE") */
+		tcpcp_del_req_entry(r_entry);
+
+#ifdef CONFIG_TCPCP_DEBUG
+	/* @@@ print Process List with lock. (for DEBUG) @@@ */
+	print_list();
+#endif
+
+out:
+	/* lock socket. */
+	lock_sock(sk);
+	DPRINTK("TCPCP : %s : socket is locked.\n", __FUNCTION__);
+
+	/* end. */
+	DPRINTK("TCPCP : %s : end.\n", __FUNCTION__);
+	return error;
+}
+
+/**
+ * __tcpcp_get_si - get TCP-SI from Kernel.
+ *
+ * [Args]
+ *   (IN)  *sk        : socket
+ *   (OUT) *user_si   : TCP-SIs to get
+ *   (OUT) *user_size : size of user_si
+ *
+ * [Return]
+ *   0      : OK.
+ *  -EFAULT : NG. (....)
+ **/
+static int __tcpcp_get_si(struct sock *sk, struct tcpcp_total_si_hdr *user_si,
+			  unsigned int *user_size)
+{
+	struct tcpcp_req_entry *r_entry;
+	int error;
+
+	/* plug-in. */
+	plugin_dummy();
+
+	/* start. */
+	DPRINTK("TCPCP : %s : start. sk=0x%p\n", __FUNCTION__, sk);
+
+#ifdef CONFIG_TCPCP_DEBUG
+	/* @@@ print Process List with lock. (for DEBUG) @@@ */
+	print_list();
+#endif
+
+	/* lookup Request Entry and unlink from Timeout List. */
+	r_entry = tcpcp_reset_timeout(sk);
+	if (r_entry == NULL)
+		return -EFAULT;
+	if (r_entry->s_entry == NULL) {
+		error = -EFAULT;
+		goto err;
+	}
+
+#ifdef CONFIG_TCPCP_DEBUG
+	/* @@@ print Process List with lock. (for DEBUG) @@@ */
+	print_list();
+#endif
+
+	/* get TCP-SIs. */
+	error = do_get_si(r_entry, user_si, user_size);
+	if (error != 0) {
+		/* only -EFAULT. */
+		DPRINTK("TCPCP : %s : [Error] can't get TCP-SIs. error=%d\n",
+			__FUNCTION__, error);
+		goto err;
+	}
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : after do_get_si.\n", __FUNCTION__);
+
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : user_size        =%u\n",
+		__FUNCTION__, *user_size);
+	DPRINTK("TCPCP : %s : user_si->total_si=%u\n",
+		__FUNCTION__, user_si->total_si_length);
+	DPRINTK("TCPCP : %s : user_si->major   =%u\n",
+		__FUNCTION__, user_si->major);
+	DPRINTK("TCPCP : %s : user_si->minor   =%u\n",
+		__FUNCTION__, user_si->minor);
+	DPRINTK("TCPCP : %s : user_si->si_cnt  =%u\n",
+		__FUNCTION__, user_si->si_cnt);
+
+	if (r_entry->flag & TCPCP_FLAG_ALL) {
+		/* link to Timeout List. (only "ALL") */
+		tcpcp_set_timeout(r_entry);
+		/* @@@ for DEBUG @@@ */
+		DPRINTK("TCPCP : %s : r_entry->timeout=%u\n",
+			__FUNCTION__, r_entry->timeout);
+	} else
+		/* delete Request Entry with common entries. (only "ONE") */
+		tcpcp_del_req_entry(r_entry);
+
+#ifdef CONFIG_TCPCP_DEBUG
+	/* @@@ print Process List with lock. (for DEBUG) @@@ */
+	print_list();
+#endif
+
+	/* end. */
+	DPRINTK("TCPCP : %s : end.\n", __FUNCTION__);
+	return 0;
+
+err:
+	/* delete Request Entry with common entries. */
+	tcpcp_del_req_entry(r_entry);
+
+	/* end. */
+	DPRINTK("TCPCP : %s : end.\n", __FUNCTION__);
+	return error;
+}
+
+/**
+ * __tcpcp_get_res - get FDRs from Kernel.
+ *
+ * [Args]
+ *   (IN)  *sk        : TCP socket
+ *   (OUT) *user_fdrs : FDRs to get
+ *   (OUT) *user_size : size of user_fdrs
+ *
+ * [Return]
+ *   0      : OK.
+ *  -EFAULT : NG. (....)
+ **/	
+static int __tcpcp_get_res(struct sock *sk, struct fdr *user_fdrs,
+			   unsigned int *user_size)
+{
+	struct tcpcp_req_entry *r_entry;
+	int error = 0;
+
+	/* plug-in. */
+	plugin_dummy();
+
+	/* start. */
+	DPRINTK("TCPCP : %s : start. sk=0x%p\n", __FUNCTION__, sk);
+
+#ifdef CONFIG_TCPCP_DEBUG
+	/* @@@ print Process List with lock. (for DEBUG) @@@ */
+	print_list();
+#endif
+
+	/* lookup Request Entry and unlink from Timeout List. */
+	r_entry = tcpcp_reset_timeout(sk);
+	if (r_entry == NULL)
+		return -EFAULT;
+	if (r_entry->f_entry == NULL) {
+		tcpcp_del_req_entry(r_entry);
+		return -EFAULT;
+	}
+
+#ifdef CONFIG_TCPCP_DEBUG
+	/* @@@ print Process List with lock. (for DEBUG) @@@ */
+	print_list();
+#endif
+
+	/* get FDR Info. */
+	error = do_get_res(r_entry, user_fdrs, user_size);
+
+	/* delete Request Entry with common entries. */
+	tcpcp_del_req_entry(r_entry);
+
+#ifdef CONFIG_TCPCP_DEBUG
+	/* @@@ print Process List with lock. (for DEBUG) @@@ */
+	print_list();
+#endif
+
+	/* end. */
+	DPRINTK("TCPCP : %s : end. error=%d\n", __FUNCTION__, error);
+	return error;
+}
+
+/**
+ * tcpcp_close - ....
+ *
+ * [Args]
+ *   (IN) *sk : TCP socket
+ **/
+static void __tcpcp_close(struct sock *sk)
+{
+	/* plug-in. */
+	plugin_dummy();
+
+	/* start. */
+	DPRINTK("TCPCP : %s : start. sk=0x%p\n", __FUNCTION__, sk);
+
+	tcpcp_quick_timeout(sk);
+
+	/* end. */
+	DPRINTK("TCPCP : %s : end.\n", __FUNCTION__);
+	return;
+}
+
+
+/* ----- Initialization and (module) exit ---------------------------------- */
+
+/**
+ * tcpcp_init - processing tcpcp initilaization.
+ **/
+static int __init tcpcp_init(void)
+{
+	/* plug-in. */
+	plugin_dummy();
+
+	/* start. */
+	DPRINTK("TCPCP : %s : start.\n", __FUNCTION__);
+
+	/* initalize tcp_func for TCPCP. (TCP/IPv4) */
+	tcpcp_ipv4_af_specific = ipv4_specific;
+	tcpcp_ipv4_af_specific.queue_xmit = tcpcp_discard_xmit;
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : ipv4_specific.send_check         =0x%p\n",
+		__FUNCTION__, ipv4_specific.send_check);
+	DPRINTK("TCPCP : %s : tcpcp_ipv4_af_specific.send_check=0x%p\n",
+		__FUNCTION__, tcpcp_ipv4_af_specific.send_check);
+	DPRINTK("TCPCP : %s : tcpcp_discard_xmit:              =0x%p\n",
+		__FUNCTION__, tcpcp_discard_xmit);
+	DPRINTK("TCPCP : %s : tcpcp_ipv4_af_specific.queue_xmit=0x%p\n",
+		__FUNCTION__, tcpcp_ipv4_af_specific.queue_xmit);
+
+#if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)
+	/* initialize tcp_func for TCPCP. (TCP/IPv6) */
+	tcpcp_ipv6_af_specific = ipv6_specific;
+	tcpcp_ipv6_af_specific.queue_xmit = tcpcp_discard_xmit;
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : ipv6_specific.send_check         =0x%p\n",
+		__FUNCTION__, ipv6_specific.send_check);
+	DPRINTK("TCPCP : %s : tcpcp_ipv6_af_specific.send_check=0x%p\n",
+		__FUNCTION__, tcpcp_ipv6_af_specific.send_check);
+	DPRINTK("TCPCP : %s : tcpcp_discard_xmit               =0x%p\n",
+		__FUNCTION__, tcpcp_discard_xmit);
+	DPRINTK("TCPCP : %s : tcpcp_ipv6_af_specific.queue_xmit=0x%p\n",
+		__FUNCTION__, tcpcp_ipv6_af_specific.queue_xmit);
+
+	/* initialize tcp_func for TCPCP. (TCP/IPv6 Mapped) */
+	tcpcp_ipv6_af_mapped = ipv6_mapped;
+	tcpcp_ipv6_af_mapped.queue_xmit = tcpcp_discard_xmit;
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : ipv6_mapped.send_check         =0x%p\n",
+		__FUNCTION__, ipv6_mapped.send_check);
+	DPRINTK("TCPCP : %s : tcpcp_ipv6_af_mapped.send_check=0x%p\n",
+		__FUNCTION__, tcpcp_ipv6_af_mapped.send_check);
+	DPRINTK("TCPCP : %s : tcpcp_discard_xmit             =0x%p\n",
+		__FUNCTION__, tcpcp_discard_xmit);
+	DPRINTK("TCPCP : %s : tcpcp_ipv6_af_mapped.queue_xmit=0x%p\n",
+		__FUNCTION__, tcpcp_ipv6_af_mapped.queue_xmit);
+#endif /* defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE) */
+
+	/* lock tcpcp_sem. */
+	down_write(&tcpcp_sem);
+	DPRINTK("TCPCP : %s : tcpcp_sem is locked.\n", __FUNCTION__);
+
+	/* initialize Process List */
+	memset(&proc_list, 0, sizeof(struct tcpcp_list));
+	INIT_LIST_HEAD(&(proc_list.head));
+	proc_list.lock = RW_LOCK_UNLOCKED;
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : proc_list.head     =0x%p\n",
+		__FUNCTION__, &proc_list.head);
+	DPRINTK("TCPCP : %s : proc_list.head.next=0x%p\n",
+		__FUNCTION__, proc_list.head.next);
+	DPRINTK("TCPCP : %s : proc_list.head.prev=0x%p\n",
+		__FUNCTION__, proc_list.head.prev);
+
+	/* initialize Timeout List. */
+	memset(&timeout_list, 0, sizeof(struct tcpcp_list));
+	INIT_LIST_HEAD(&(timeout_list.head));
+	timeout_list.lock = RW_LOCK_UNLOCKED;
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : timeout_list.head     =0x%p\n",
+		__FUNCTION__, &timeout_list.head);
+	DPRINTK("TCPCP : %s : timeout_list.head.next=0x%p\n",
+		__FUNCTION__, timeout_list.head.next);
+	DPRINTK("TCPCP : %s : timeout_list.head.prev=0x%p\n",
+		__FUNCTION__, timeout_list.head.prev);
+
+	/* set hook. */
+	tcpcp_com_ope_hook = __tcpcp_com_ope;
+	tcpcp_get_si_hook = __tcpcp_get_si;
+	tcpcp_get_res_hook = __tcpcp_get_res;
+	tcpcp_set_si_hook = __tcpcp_set_si;
+	tcpcp_close_hook = __tcpcp_close;
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : __tcpcp_com_ope   =0x%p\n",
+		__FUNCTION__, &__tcpcp_com_ope);
+	DPRINTK("TCPCP : %s : tcpcp_com_ope_hook=0x%p\n",
+		__FUNCTION__, tcpcp_com_ope_hook);
+	DPRINTK("TCPCP : %s : __tcpcp_get_si    =0x%p\n",
+		__FUNCTION__, &__tcpcp_get_si);
+	DPRINTK("TCPCP : %s : tcpcp_get_si_hook =0x%p\n",
+		__FUNCTION__, tcpcp_get_si_hook);
+	DPRINTK("TCPCP : %s : __tcpcp_get_res   =0x%p\n",
+		__FUNCTION__, &__tcpcp_get_res);
+	DPRINTK("TCPCP : %s : tcpcp_get_res_hook=0x%p\n",
+		__FUNCTION__, tcpcp_get_res_hook);
+	DPRINTK("TCPCP : %s : __tcpcp_set_si    =0x%p\n",
+		__FUNCTION__, &__tcpcp_set_si);
+	DPRINTK("TCPCP : %s : tcpcp_set_si_hook =0x%p\n",
+		__FUNCTION__, tcpcp_set_si_hook);
+	DPRINTK("TCPCP : %s : __tcpcp_close     =0x%p\n",
+		__FUNCTION__, &__tcpcp_close);
+	DPRINTK("TCPCP : %s : tcpcp_close_hook  =0x%p\n",
+		__FUNCTION__, tcpcp_close_hook);
+
+	/* unlock tcpcp_sem. */
+	up_write(&tcpcp_sem);
+	DPRINTK("TCPCP : %s : tcpcp_sem is unlocked.\n", __FUNCTION__);
+
+	/* print message. */
+	printk(KERN_INFO "TCPCP : %s : initialized." \
+	       " (SI format version %u.%u)\n",
+	       __FUNCTION__, TCPCP_CURRENT_SI_MAJOR, TCPCP_CURRENT_SI_MINOR);
+
+	/* end. */
+	DPRINTK("TCPCP : %s : end.\n", __FUNCTION__);
+	return 0;
+}
+
+/**
+ * tcpcp_exit - processing tcpcp exit.
+ **/
+static void __exit tcpcp_exit(void)
+{
+	/* plug-in. */
+	plugin_dummy();
+
+	/* start. */
+	DPRINTK("TCPCP : %s : start.\n", __FUNCTION__);
+
+	/* lock tcpcp_sem. */
+	down_write(&tcpcp_sem);
+	DPRINTK("TCPCP : %s : tcpcp_sem is locked.\n", __FUNCTION__);
+
+	/* reset hook. */
+	tcpcp_com_ope_hook = NULL;
+	tcpcp_get_si_hook = NULL;
+	tcpcp_get_res_hook = NULL;
+	tcpcp_set_si_hook = NULL;
+	tcpcp_close_hook = NULL;
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : tcpcp_com_ope_hook=0x%p\n",
+		__FUNCTION__, tcpcp_com_ope_hook);
+	DPRINTK("TCPCP : %s : tcpcp_get_si_hook =0x%p\n",
+		__FUNCTION__, tcpcp_get_si_hook);
+	DPRINTK("TCPCP : %s : tcpcp_get_res_hook=0x%p\n",
+		__FUNCTION__, tcpcp_get_res_hook);
+	DPRINTK("TCPCP : %s : tcpcp_set_si_hook =0x%p\n",
+		__FUNCTION__, tcpcp_set_si_hook);
+	DPRINTK("TCPCP : %s : tcpcp_close_hook  =0x%p\n",
+		__FUNCTION__, tcpcp_close_hook);
+
+	/* delete and free all entry. */
+	tcpcp_del_all_entry();
+
+	if (timer_pending(&tcpcp_timer) != 0) {
+		/* sleep Timeout-watcher. */
+		del_timer_sync(&tcpcp_timer);
+		DPRINTK("TCPCP : %s : TCPCP timeout watcher is deleted.\n",
+			__FUNCTION__);
+	}
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : timer_pending=%d\n",
+		__FUNCTION__, timer_pending(&tcpcp_timer));
+
+	/* unlock tcpcp_sem. */
+	up_write(&tcpcp_sem);
+	DPRINTK("TCPCP : %s : tcpcp_sem is unlocked.\n", __FUNCTION__);
+
+#if CONFIG_TCPCP_DEBUG
+	/* @@@ print Process List with lock. (for DEBUG) @@@ */
+	print_list();
+#endif
+
+	/* print messasge. */
+	printk(KERN_INFO "TCPCP : %s : exit.\n", __FUNCTION__);
+
+	/* end. */
+	DPRINTK("TCPCP : %s : end.\n", __FUNCTION__);
+	return;
+}
+
+
+/* ----- for DEBUG --------------------------------------------------------- */
+
+#ifdef CONFIG_TCPCP_DEBUG
+/**
+ * __print_list - print Process List without lock. (for DEBUG)
+ **/
+static void __print_list(void)
+{
+	struct tcpcp_proc_entry *p_entry = NULL;
+	struct tcpcp_req_entry *r_entry = NULL;
+	struct tcpcp_com_entry *c_entry, *next_c_entry = NULL;
+
+	/* start. */
+	DPRINTK("@@@@@@@@@@ print list @@@@@@@@@@\n");
+
+	/* print Process List head. */
+	DPRINTK("[ PH ]\n");
+
+	/* search Process List. */
+	list_for_each_entry(p_entry, &(proc_list.head), node) {
+		/* print Process Entry. */
+		DPRINTK("[ PE ] tgid=%d, flag=%u\n",
+			p_entry->tgid, p_entry->flag);
+
+		/* search Request Entry. */
+		list_for_each_entry(r_entry, &(p_entry->r_list_head), node) {
+			/* print Request Entry. */
+			DPRINTK("  ->[ RE ] sk=0x%p, pid=%d, flag=%u, fd=%d\n",	
+				r_entry->sk, r_entry->pid, r_entry->flag,
+				r_entry->fd);
+
+			/* print TCP-SIs Entries. */
+			c_entry = r_entry->s_entry;
+			while ((c_entry) != NULL) {
+				next_c_entry = c_entry->next;
+				DPRINTK("    ->[SOCK] data_len=%u\n",
+					c_entry->data_len);
+				c_entry = next_c_entry;
+			}
+
+			/* print FDR Info Entries. */
+			c_entry = r_entry->f_entry;
+			while ((c_entry) != NULL) {
+				next_c_entry = c_entry->next;
+				DPRINTK("    ->[REST] data_len=%u\n",
+					c_entry->data_len);
+				c_entry = next_c_entry;
+			}
+		}
+	}
+
+	/* print Timer List head. */
+	DPRINTK("[ TH ]\n");
+
+	/* search Timeout Request List. */
+	list_for_each_entry(r_entry, &(timeout_list.head), timer_node) {
+		/* print Request Entry. */
+		DPRINTK("  ->[ RE ] sk=0x%p, pid=%d, flag=%u, fd=%d,"
+			" timeout=%u\n",
+			r_entry->sk, r_entry->pid, r_entry->flag,
+			r_entry->fd, r_entry->timeout);
+	}
+
+	/* end. */
+	DPRINTK("@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n");
+	return;
+}
+
+/**
+ * print_list - print Process List with lock. (for DEBUG)
+ **/
+static void print_list(void)
+{
+	/* lock Process List (and Timeout List). */
+	write_lock(&(proc_list.lock));
+
+	__print_list();
+
+	/* unlock Process List (and Timeout List). */
+	write_unlock(&(proc_list.lock));
+
+	return;
+}
+
+/**
+ * skb_queue_check - print writr_queue / receive_queue. (for DEBUG)
+ *
+ * [Args]
+ *   (IN) *queue : write_queue / receive_queue of TCP socket
+ **/
+static void skb_queue_check(struct sk_buff_head *queue)
+{
+	struct sk_buff *skb;
+	int cnt = 0;
+
+	DPRINTK("TCPCP : %s : queue->qlen=%u\n", __FUNCTION__, queue->qlen);
+	DPRINTK("TCPCP : %s : queue      =0x%p\n", __FUNCTION__, queue);
+	DPRINTK("TCPCP : %s : queue->next=0x%p\n", __FUNCTION__, queue->next);
+	DPRINTK("TCPCP : %s : queue->prev=0x%p\n", __FUNCTION__, queue->prev);
+
+	skb_queue_walk(queue, skb) {
+		cnt++;
+		DPRINTK("TCPCP : %s : skb[%d]:0x%p\n", __FUNCTION__, cnt, skb);
+	}
+
+	return;
+}
+
+/**
+ * check_fd - .... (for DEBUG)
+ **/
+static void check_fd(void)
+{
+	struct files_struct * files = current->files;
+	struct file * filp;
+	struct sock * sk_i;
+	unsigned int fd;
+	unsigned int file = 0;
+	unsigned int socket_ng = 0;
+	unsigned int socket = 0;
+	unsigned int sockbuf[files->max_fds];
+	unsigned int cnt = 0;
+
+	DPRINTK("TCPCP : %s : *******************\n", __FUNCTION__);
+
+	for (fd = 0; fd < files->max_fds; fd++) {
+		filp = files->fd[fd];
+		if (filp == NULL)
+			continue;
+
+		if (filp->f_dentry->d_inode->i_sock == 0) {
+			file ++;
+			continue;
+		}
+
+		sk_i = SOCKET_I(filp->f_dentry->d_inode)->sk;
+		if (sk_i == NULL) {
+			socket_ng ++;
+			continue;
+		}
+
+		socket ++;
+		sockbuf[cnt] = fd;
+		cnt ++;
+	}
+
+	DPRINTK("TCPCP : %s : file      : %u\n", __FUNCTION__, file);
+	DPRINTK("TCPCP : %s : socket_ng : %u\n", __FUNCTION__, socket_ng);
+	DPRINTK("TCPCP : %s : socket    : %u\n", __FUNCTION__, socket);
+
+	if (cnt == 0) {
+		DPRINTK("TCPCP : %s : *******************\n", __FUNCTION__);
+		return;
+	}
+
+	for (fd = 0; fd < cnt; fd ++) {
+		DPRINTK("TCPCP : %s : sockbuf[%u] : %u\n",
+			__FUNCTION__, fd, sockbuf[fd]);
+	}
+
+	DPRINTK("TCPCP : %s : *******************\n", __FUNCTION__);
+	return;
+}
+#endif
+
+module_init(tcpcp_init);
+module_exit(tcpcp_exit);
diff -urbpBPN osdl/net/ipv4/tcpcp_hooks.c osdl.tcpcp/net/ipv4/tcpcp_hooks.c
--- osdl/net/ipv4/tcpcp_hooks.c	1970-01-01 00:00:00.000000000 +0000
+++ osdl.tcpcp/net/ipv4/tcpcp_hooks.c	2006-02-09 04:48:33.000000000 +0000
@@ -0,0 +1,407 @@
+
+/*
+ * tcpcp_hooks.c - Hooks when using TCP connection passing as a module
+ *
+ * Written 2002,2004 by Werner Almesberger
+ *
+ * Copyright (C) 2005 NTT Corporation
+ */
+
+
+#include <linux/config.h>
+
+#if defined(CONFIG_TCPCP) || defined(CONFIG_TCPCP_MODULE)
+
+#include <linux/module.h>
+#include <linux/rwsem.h>
+#include <linux/kmod.h>
+#include <linux/tcpcp.h>
+
+#include <net/tcp.h>
+
+
+/* ----- Hooks ------------------------------------------------------------- */
+
+int (*tcpcp_com_ope_hook)(struct sock *sk, int optname, struct result *user_res)
+    = NULL;
+int (*tcpcp_get_si_hook)(struct sock *sk, struct tcpcp_total_si_hdr *user_si,
+			 unsigned int *user_size)
+    = NULL;
+int (*tcpcp_get_res_hook)(struct sock *sk, struct fdr *user_fdrs,
+			  unsigned int *user_size)
+    = NULL;
+int (*tcpcp_set_si_hook)(struct sock *sk, int optname,
+			 const struct tcpcp_total_si_hdr *user_si,
+			 unsigned int size)
+    = NULL;
+void (*tcpcp_close_hook)(struct sock *sk) = NULL;
+
+EXPORT_SYMBOL(tcpcp_com_ope_hook);
+EXPORT_SYMBOL(tcpcp_get_si_hook);
+EXPORT_SYMBOL(tcpcp_get_res_hook);
+EXPORT_SYMBOL(tcpcp_set_si_hook);
+EXPORT_SYMBOL(tcpcp_close_hook);
+
+/**
+ * tcpcp_call_com_ope_hook
+ *   - Call hook function of other operations of those other than
+ *     GET_SI, SET_SI, SET_SI_ALL and GET_RES.
+ *     The target operations are MAKE_SI, MAKE_SI_ALL, STOP, STOP_ALL,
+ *     CLOSE_ALL, START, START_ALL and GET_RES_SIZE.
+ *
+ * [Args]
+ *   (IN)  *sk       : socket (if ALL, socket is dummy fd)
+ *   (IN)  optname   : option name
+ *                     (TCPCP_MAKE_SI, TCPCP_MAKE_SI_ALL, TCPCP_STOP,
+ *                      TCPCP_STOP_ALL, TCPCP_CLOSE_ALL, TCPCP_START,
+ *                      TCPCP_START_ALL, TCPCP_GET_RES_SIZE)
+ *   (OUT) *user_res : result info
+ *
+ * [Return]
+ *   0      : OK.
+ *  -ENOSYS : NG. (function not implemented)
+ *   other  : (skip)
+ **/
+int tcpcp_call_com_ope_hook(struct sock *sk, int optname,
+			    struct result *user_res)
+{
+	int error = -ENOSYS;
+
+	/* plug-in. */
+	plugin_dummy();
+
+	/* start. */
+	DPRINTK("TCPCP : %s : start. sk=0x%p, optname=%d\n",
+		__FUNCTION__, sk, optname);
+
+	/* hook is not activated ? */
+	if (!tcpcp_com_ope_hook) {
+		DPRINTK("TCPCP : %s : request TCPCP module.\n",
+			__FUNCTION__);
+		request_module(TCPCP_MODULE_NAME);
+	}
+
+	/* hook is activated ? */
+	if (tcpcp_com_ope_hook)
+		error = tcpcp_com_ope_hook(sk, optname, user_res);
+
+	/* end. */
+	DPRINTK("TCPCP : %s : end. error=%d\n", __FUNCTION__, error);
+	return error;
+}
+
+/**
+ * tcpcp_call_get_si_hook - call hook function for getting TCP-SIs.
+ *
+ * [Args]
+ *   (IN)  *sk        : socket (dummy)
+ *   (OUT) *user_si   : TCP-SIs acquired from Kernel
+ *   (OUT) *user_size : size of user_si
+ *
+ * [Return]
+ *   0      : OK.
+ *  -ENOSYS : NG. (function not implemented)
+ *   other  : (skip)
+ **/
+int tcpcp_call_get_si_hook(struct sock *sk,
+			   struct tcpcp_total_si_hdr *user_si,
+			   unsigned int *user_size)
+{
+	int error = -ENOSYS;
+
+	/* plug-in. */
+	plugin_dummy();
+
+	/* start. */
+	DPRINTK("TCPCP : %s : start. sk=0x%p\n", __FUNCTION__, sk);
+
+	/* hook is not activated ? */
+	if (!tcpcp_get_si_hook) {
+		DPRINTK("TCPCP : %s : request TCPCP module.\n",
+			__FUNCTION__);
+		request_module(TCPCP_MODULE_NAME);
+	}
+
+	/* hook is activated ? */
+	if (tcpcp_get_si_hook)
+		error = tcpcp_get_si_hook(sk, user_si, user_size);
+
+	/* end. */
+	DPRINTK("TCPCP : %s : end. error=%d\n", __FUNCTION__, error);
+	return error;
+}
+
+/**
+ * tcpcp_call_get_res_hook - call hook function for getting FDR Info.
+ *
+ * [Args]
+ *   (IN)  *sk        : socket (dummy)
+ *   (OUT) *user_fdrs : FDRs info acquired from Kernel
+ *   (OUT) *user_size : size of user_fdrs
+ *
+ * [Return]
+ *   0      : OK.
+ *  -ENOSYS : NG. (function not implemented)
+ *   other  : (skip)
+ **/
+int tcpcp_call_get_res_hook(struct sock *sk, struct fdr *user_fdrs,
+			    unsigned int *user_size)
+{
+	int error = -ENOSYS;
+
+	/* plug-in. */
+	plugin_dummy();
+
+	/* start. */
+	DPRINTK("TCPCP : %s : start. sk=0x%p\n", __FUNCTION__, sk);
+
+	/* hook is not activated ? */
+	if (!tcpcp_get_res_hook) {
+		DPRINTK("TCPCP : %s : request TCPCP module.\n",
+			__FUNCTION__);
+		request_module(TCPCP_MODULE_NAME);
+	}
+
+	/* hook is activated ? */
+	if (tcpcp_get_res_hook)
+		error = tcpcp_get_res_hook(sk, user_fdrs, user_size);
+
+	/* end. */
+	DPRINTK("TCPCP : %s : end. error=%d\n", __FUNCTION__, error);
+	return error;
+}
+
+/**
+ * tcpcp_call_set_si_hook - call hook function for setting TCP-SI to Kernel.
+ *
+ * [Args]
+ *   (IN) *sk      : socket
+ *   (IN) optname  : option name (TCPCP_SET_SI or TCPCP_SET_SI_ALL)
+ *   (IN) *user_si : TCP-SI to set to Kernel (const)
+ *   (IN) size     : size of user_si
+ *
+ * [Return]
+ *   0      : OK.
+ *  -ENOSYS : NG. (function not implemented)
+ *   other  : (skip)
+ **/
+int tcpcp_call_set_si_hook(struct sock *sk, int optname,
+			   const struct tcpcp_total_si_hdr *user_si,
+			   unsigned int size)
+{
+	int error = -ENOSYS;
+
+	/* plug-in. */
+	plugin_dummy();
+
+	/* start. */
+	DPRINTK("TCPCP : %s : start. sk=0x%p, optname=%d\n",
+		__FUNCTION__, sk, optname);
+
+	/* hook is not activated ? */
+	if (!tcpcp_set_si_hook) {
+		DPRINTK("TCPCP : %s : request TCPCP module.\n",
+			__FUNCTION__);
+		request_module(TCPCP_MODULE_NAME);
+	}
+
+	/* tcpcp_set_si_hook is activated ? */
+	if (tcpcp_set_si_hook)
+		error = tcpcp_set_si_hook(sk, optname, user_si, size);
+
+	/* end. */
+	DPRINTK("TCPCP : %s : end. error=%d\n", __FUNCTION__, error);
+	return error;
+}
+
+/**
+ * tcpcp_call_close_hook - call hook function for TCPCP_CLOSE (not "ALL").
+ *
+ * [Args]
+ *   (IN) *sk : TCP socket
+ **/
+void tcpcp_call_close_hook(struct sock *sk)
+{
+	/* plug-in. */
+	plugin_dummy();
+
+	/* start. */
+	DPRINTK("TCPCP : %s : start. sk=0x%p\n", __FUNCTION__, sk);
+
+	/* hook is not activate ? */
+	if (!tcpcp_close_hook)
+		/* no need to request module. */
+		return;
+
+	/* hook is activated ? */
+	if (tcpcp_close_hook)
+		tcpcp_close_hook(sk);
+
+	/* end. */
+	DPRINTK("TCPCP : %s : end.\n", __FUNCTION__);
+	return;
+}
+
+
+/* ----- Interface to ipv4/tcp_output.c ------------------------------------ */
+
+struct tcp_func tcpcp_ipv4_af_specific;
+EXPORT_SYMBOL(tcpcp_ipv4_af_specific);
+
+#if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)
+struct tcp_func tcpcp_ipv6_af_specific;
+struct tcp_func tcpcp_ipv6_af_mapped;
+EXPORT_SYMBOL(tcpcp_ipv6_af_specific);
+EXPORT_SYMBOL(tcpcp_ipv6_af_mapped);
+#endif
+
+/**
+ * tcpcp_discard_xmit - queue packet transmission function change.
+ *
+ * [Args]
+ *  (IN) *skb      : socket buffer
+ *  (IN) ipfragok  : parameter used by function for exchange (not used)
+ *                   Although ipfragok of the 2nd argument is not using
+ *                   this function since this function is a pointer
+ *                   function, it leaves in consideration of adjustment
+ *                   with other functions.
+ * [Return]
+ *   0 : OK. (always in this case)
+ **/
+int tcpcp_discard_xmit(struct sk_buff *skb, int ipfragok)
+{
+	/* plug-in. */
+	plugin_dummy();
+
+	/* start. */
+	DPRINTK("TCPCP : %s : start. skb=0x%p\n", __FUNCTION__, skb);
+
+	kfree_skb(skb);
+
+	/* end. */
+	DPRINTK("TCPCP : %s : end.\n", __FUNCTION__);
+	return 0;
+}
+EXPORT_SYMBOL(tcpcp_discard_xmit);
+
+
+/* ----- Interface to ipv4/tcp_input.c ------------------------------------- */
+
+struct sk_filter drop_all = {
+	.refcnt = ATOMIC_INIT(1),	/* never kfree this ... */
+	.len = 0,			/* return 0 */
+};
+EXPORT_SYMBOL(drop_all);
+
+/**
+ * tcpcp_fix_seq - corrects sequence number.
+ *
+ * [Args]
+ *  (IN) *sk    : socket
+ *  (IN) seq    : sequence number of packet transmitted from destination
+ *  (IN) ackseq : ack sequence number of packet transmitted from destination
+ **/
+void tcpcp_fix_seq(struct sock *sk, __u32 seq, __u32 ackseq)
+{
+	struct tcp_sock *tp = tcp_sk(sk);
+
+	/* plug-in. */
+	plugin_dummy();
+
+	/* start. */
+	DPRINTK("TCPCP : %s : start. sk=0x%p\n", __FUNCTION__, sk);
+
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : @@@ before fix seq. @@@\n", __FUNCTION__);
+	DPRINTK("TCPCP : %s : tp->snd_nxt=%u\n", __FUNCTION__, tp->snd_nxt);
+	DPRINTK("TCPCP : %s : ackseq     =%u\n", __FUNCTION__, ackseq);
+	DPRINTK("TCPCP : %s : tp->rcv_nxt=%u\n", __FUNCTION__, tp->rcv_nxt);
+	DPRINTK("TCPCP : %s : seq        =%u\n", __FUNCTION__, seq);
+
+	if (before(tp->snd_nxt, ackseq)) {
+		/* purge write_queue. */
+		sk_stream_writequeue_purge(sk);
+
+		/* initialize packets_out, sk_send_head */
+		tp->packets_out = 0;
+		sk->sk_send_head = NULL;
+
+		/* fix sequence number (send). */
+		tp->snd_nxt = ackseq;
+		tp->snd_una = tp->snd_nxt;
+		tp->write_seq = tp->snd_nxt;
+		tp->snd_sml = tp->snd_nxt;
+		tp->pushed_seq = tp->snd_nxt;
+	}
+
+	if (before(tp->rcv_nxt, seq)) {
+		/* purge receive_queue. */
+		__skb_queue_purge(&sk->sk_receive_queue);
+
+		/* fix sequence number (receive). */
+		tp->rcv_nxt = seq;
+		tp->rcv_wup = tp->rcv_nxt;
+		tp->snd_wl1 = tp->rcv_nxt;
+		tp->copied_seq = tp->rcv_nxt;
+	}
+
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : @@@ after fix seq. @@@\n", __FUNCTION__);
+	DPRINTK("TCPCP : %s : tp->snd_nxt=%u\n", __FUNCTION__, tp->snd_nxt);
+	DPRINTK("TCPCP : %s : tp->snd_una=%u\n", __FUNCTION__, tp->snd_una);
+	DPRINTK("TCPCP : %s : tp->rcv_nxt=%u\n", __FUNCTION__, tp->rcv_nxt);
+
+	/* end. */
+	DPRINTK("TCPCP : %s : end.\n", __FUNCTION__);
+	return;
+}
+EXPORT_SYMBOL(tcpcp_fix_seq);
+
+/**
+ * tcpcp_fix_ts - corrects timestamp.
+ *
+ * [Args]
+ *  (IN) *sk       : socket
+ *  (IN) ack_tsecr : timestamp of the latest packet that succeeds in reception
+ **/
+void tcpcp_fix_ts(struct sock *sk, __u32 ack_tsecr)
+{
+	struct tcp_sock *tp = tcp_sk(sk);
+
+	/* plug-in. */
+	plugin_dummy();
+
+	/* start. */
+	DPRINTK("TCPCP : %s : start. sk=0x%p\n", __FUNCTION__, sk);
+
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : @@@ before fix ts. @@@\n", __FUNCTION__);
+	DPRINTK("TCPCP : %s : ack_tsecr     =%u\n", __FUNCTION__, ack_tsecr);
+	DPRINTK("TCPCP : %s : tp->ts_offset =%u\n",
+		__FUNCTION__, tp->ts_offset);
+	DPRINTK("TCPCP : %s : tcp_time_stamp=%u\n",
+		__FUNCTION__, tcp_time_stamp);
+	DPRINTK("TCPCP : %s : tp_time_stamp =%u\n",
+		__FUNCTION__, tp_time_stamp(tp));
+
+	tp->ts_offset = ack_tsecr - tcp_time_stamp;
+
+	/* @@@ for DEBUG @@@ */
+	DPRINTK("TCPCP : %s : @@@ after fix ts. @@@\n", __FUNCTION__);
+	DPRINTK("TCPCP : %s : tp->ts_offset = ack_tsecr - tcp_time_stamp!\n",
+		__FUNCTION__);
+	DPRINTK("TCPCP : %s : tp_time_stamp(tp) ="
+		" tcp_time_stamp + tp->ts_offset\n", __FUNCTION__);
+	DPRINTK("TCPCP : %s : tp->ts_offset=%u\n", __FUNCTION__, tp->ts_offset);
+	DPRINTK("TCPCP : %s : tcp_time_stamp=%u\n",
+		__FUNCTION__, tcp_time_stamp);
+	DPRINTK("TCPCP : %s : tp_time_stamp =%u\n",
+		__FUNCTION__, tp_time_stamp(tp));
+
+	/* end. */
+	DPRINTK("TCPCP : %s : end.\n", __FUNCTION__);
+	return;
+}
+EXPORT_SYMBOL(tcpcp_fix_ts);
+
+#endif /* defined(CONFIG_TCPCP) || defined(CONFIG_TCPCP_MODULE) */
diff -urbpBPN osdl/net/ipv6/ip6_output.c osdl.tcpcp/net/ipv6/ip6_output.c
--- osdl/net/ipv6/ip6_output.c	2006-01-20 02:32:01.000000000 +0000
+++ osdl.tcpcp/net/ipv6/ip6_output.c	2006-02-09 04:48:34.000000000 +0000
@@ -56,6 +56,10 @@
 #include <net/xfrm.h>
 #include <net/checksum.h>
 
+#if defined(CONFIG_TCPCP) || defined(CONFIG_TCPCP_MODULE)
+#include <linux/tcpcp.h>
+#endif
+
 static int ip6_fragment(struct sk_buff *skb, int (*output)(struct sk_buff *));
 
 static __inline__ void ipv6_select_ident(struct sk_buff *skb, struct frag_hdr *fhdr)
@@ -1227,3 +1231,19 @@ void ip6_flush_pending_frames(struct soc
 	}
 	memset(&inet->cork.fl, 0, sizeof(inet->cork.fl));
 }
+
+#if defined(CONFIG_TCPCP) || defined(CONFIG_TCPCP_MODULE)
+int tcpcp_ip6_dst_lookup(struct sock *sk, struct dst_entry **dst,
+				struct flowi *fl)
+{
+	/* plug-in. */
+        plugin_dummy();
+
+	/* start. */
+	DPRINTK("TCPCP : %s : start.\n", __FUNCTION__);
+
+        return ip6_dst_lookup(sk, dst, fl);
+}
+
+EXPORT_SYMBOL(tcpcp_ip6_dst_lookup);
+#endif
diff -urbpBPN osdl/net/ipv6/tcp_ipv6.c osdl.tcpcp/net/ipv6/tcp_ipv6.c
--- osdl/net/ipv6/tcp_ipv6.c	2006-01-20 02:32:01.000000000 +0000
+++ osdl.tcpcp/net/ipv6/tcp_ipv6.c	2006-02-09 04:48:34.000000000 +0000
@@ -65,6 +65,10 @@
 #include <linux/proc_fs.h>
 #include <linux/seq_file.h>
 
+#if defined(CONFIG_TCPCP) || defined(CONFIG_TCPCP_MODULE)
+#include <linux/tcpcp.h>
+#endif
+
 static void	tcp_v6_send_reset(struct sk_buff *skb);
 static void	tcp_v6_reqsk_send_ack(struct sk_buff *skb, struct request_sock *req);
 static void	tcp_v6_send_check(struct sock *sk, struct tcphdr *th, int len, 
@@ -73,8 +77,8 @@ static void	tcp_v6_send_check(struct soc
 static int	tcp_v6_do_rcv(struct sock *sk, struct sk_buff *skb);
 static int	tcp_v6_xmit(struct sk_buff *skb, int ipfragok);
 
-static struct tcp_func ipv6_mapped;
-static struct tcp_func ipv6_specific;
+struct tcp_func ipv6_mapped;
+struct tcp_func ipv6_specific;
 
 static inline int tcp_v6_bind_conflict(const struct sock *sk,
 				       const struct inet_bind_bucket *tb)
@@ -152,6 +156,10 @@ static int tcp_v6_get_port(struct sock *
 	goto tb_not_found;
 tb_found:
 	if (tb && !hlist_empty(&tb->owners)) {
+#if defined(CONFIG_TCPCP) || defined(CONFIG_TCPCP_MODULE)
+		if (sk->sk_reuse > 1)
+			goto success;	
+#endif
 		if (tb->fastreuse > 0 && sk->sk_reuse &&
 		    sk->sk_state != TCP_LISTEN) {
 			goto success;
@@ -1808,7 +1816,7 @@ static int tcp_v6_remember_stamp(struct 
 	return 0;
 }
 
-static struct tcp_func ipv6_specific = {
+struct tcp_func ipv6_specific = {
 	.queue_xmit	=	tcp_v6_xmit,
 	.send_check	=	tcp_v6_send_check,
 	.rebuild_header	=	tcp_v6_rebuild_header,
@@ -1827,7 +1835,7 @@ static struct tcp_func ipv6_specific = {
  *	TCP over IPv4 via INET6 API
  */
 
-static struct tcp_func ipv6_mapped = {
+struct tcp_func ipv6_mapped = {
 	.queue_xmit	=	ip_queue_xmit,
 	.send_check	=	tcp_v4_send_check,
 	.rebuild_header	=	inet_sk_rebuild_header,
@@ -2120,3 +2128,20 @@ void __init tcpv6_init(void)
 		printk(KERN_ERR "tcpv6_init: Could not register protocol\n");
 	inet6_register_protosw(&tcpv6_protosw);
 }
+
+#if defined(CONFIG_TCPCP) || defined(CONFIG_TCPCP_MODULE)
+int tcpcp_v6_hash_connect(struct sock *sk)
+{
+	/* plug-in. */
+	plugin_dummy();
+
+	/* start. */
+	DPRINTK("TCPCP : %s : start.\n", __FUNCTION__);
+
+	return tcp_v6_hash_connect(sk);
+}
+
+EXPORT_SYMBOL(ipv6_specific);
+EXPORT_SYMBOL(ipv6_mapped);
+EXPORT_SYMBOL(tcpcp_v6_hash_connect);
+#endif
diff -urbpBPN osdl/net/socket.c osdl.tcpcp/net/socket.c
--- osdl/net/socket.c	2006-01-20 02:31:57.000000000 +0000
+++ osdl.tcpcp/net/socket.c	2006-02-09 04:48:33.000000000 +0000
@@ -2100,3 +2100,14 @@ EXPORT_SYMBOL(sock_wake_async);
 EXPORT_SYMBOL(sockfd_lookup);
 EXPORT_SYMBOL(kernel_sendmsg);
 EXPORT_SYMBOL(kernel_recvmsg);
+
+#if defined(CONFIG_TCPCP) || defined(CONFIG_TCPCP_MODULE)
+asmlinkage long tcpcp_sys_socket(int family, int type, int protocol)
+{
+        plugin_dummy();
+
+        return sys_socket(family, type, protocol);
+}
+
+EXPORT_SYMBOL(tcpcp_sys_socket);
+#endif
